# Shell Autocompletion Design

**Date:** 2026-02-21
**Status:** Approved (post-audit)
**Scope:** Bash + Zsh + Fish completion for the `lattice` CLI

---

## Overview

Implement shell autocompletion for the Lattice CLI using Click 8.1's native `shell_complete` system. Expose all commands, subcommands, flags, and enumerated values at every level, with dynamic task ID completion reading from `.lattice/` when a project is initialized.

Shells supported: **bash**, **zsh**, **fish**.

---

## Architecture

### New files

```
src/lattice/completion/
└── __init__.py        # Dynamic completion callbacks (task IDs, statuses, actors, etc.)

src/lattice/cli/
└── complete.py        # `lattice completion` command implementation
```

### Modified files

```
src/lattice/cli/main.py       # Register `completion` command
src/lattice/cli/*.py          # Add shell_complete= to options not already using click.Choice
```

### Activation mechanism

Click 8.1 activates completion via environment variables. The shell eval-s a bootstrap line once at shell startup; thereafter every tab-press invokes the CLI in completion mode without running actual commands:

```bash
# bash
eval "$(_LATTICE_COMPLETE=bash_source lattice)"

# zsh
eval "$(_LATTICE_COMPLETE=zsh_source lattice)"

# fish — file written at install time, sourced automatically
# ~/.config/fish/completions/lattice.fish contains the generated script output
```

**Dev workflow note:** During development with `uv run lattice`, the completion scripts will target the global `lattice` binary (not the dev venv). This is a known limitation. Use `./scripts/publish-global.sh` to sync the global install before testing completions. Do not attempt to make `--install` emit `uv run lattice` — that would break on end-user machines.

---

## `lattice completion` Command

Lives in `src/lattice/cli/complete.py`, registered in `main.py`.

### Interface

```
lattice completion [--shell SHELL] [--print | --install | --uninstall] [--json]

Options:
  --shell [bash|zsh|fish]   Target shell. Auto-detected from $SHELL if omitted.
  --print                   Print the activation script to stdout (default when no other action).
  --install                 Write activation to shell config file (idempotent).
  --uninstall               Remove activation line from shell config file.
  --json                    Machine-readable output for --install / --uninstall result.
```

### Shell detection

1. Read `$SHELL` environment variable → `basename` → normalize to `bash`/`zsh`/`fish`.
2. Final fallback: `bash`.

Note: `/proc/$PPID/comm` is intentionally excluded — it is fragile inside tmux, screen, VS Code terminals, and unavailable on macOS. `$SHELL` covers 99% of real cases; `--shell` is the authoritative override.

### Install targets and behavior

| Shell | File written | What is written |
|-------|-------------|----------------|
| bash  | `~/.bashrc` | `eval "$(_LATTICE_COMPLETE=bash_source lattice)"` |
| zsh   | `~/.zshrc`  | `eval "$(_LATTICE_COMPLETE=zsh_source lattice)"` |
| fish  | `~/.config/fish/completions/lattice.fish` | Full script output from `_LATTICE_COMPLETE=fish_source lattice` (not a source line — the generated completion definitions) |

Fish is special: fish auto-sources every file in `~/.config/fish/completions/`. The file must contain the completion definitions themselves, not a runtime eval. At install time, `--install` captures the output of `_LATTICE_COMPLETE=fish_source lattice` and writes it to `lattice.fish`.

### Idempotency

**bash/zsh:** Before appending, scans for a line matching `_LATTICE_COMPLETE=<shell>_source lattice` using a regex that requires the string to appear on an uncommented line. If found, reports "already installed" and exits cleanly.

**fish:** If `~/.config/fish/completions/lattice.fish` exists and was written by this tool (first-line marker comment `# Generated by lattice completion`), reports "already installed". Otherwise overwrites (fish file is fully regenerated, not appended).

### Uninstall

**bash/zsh:** Removes the `eval "$(_LATTICE_COMPLETE=<shell>_source lattice)"` line(s) from the config file. Writes a backup to `<file>.lattice.bak` before modifying.

**fish:** Deletes `~/.config/fish/completions/lattice.fish` if present and was generated by this tool.

### Output

All messages go to **stderr** so `--print` stdout output is always clean and pipe-safe.

```
# --install success
✓ Completion installed. Reload your shell or run: source ~/.zshrc

# --install already installed
ℹ Completion already configured in ~/.zshrc — no changes made.

# --uninstall success
✓ Completion removed from ~/.zshrc (backup at ~/.zshrc.lattice.bak)

# --print (no stderr message — script goes to stdout only)
```

JSON mode:
```json
{ "ok": true, "data": { "shell": "zsh", "file": "/home/fede/.zshrc", "action": "installed" } }
{ "ok": true, "data": { "shell": "zsh", "file": "/home/fede/.zshrc", "action": "already_installed" } }
{ "ok": true, "data": { "shell": "zsh", "file": "/home/fede/.zshrc", "action": "removed" } }
```

---

## Dynamic Completion Callbacks

All callbacks live in `src/lattice/completion/__init__.py`. Every callback:
- Is wrapped in `try/except Exception` returning `[]` on any error.
- Calls `find_root()` independently to locate `.lattice/` — **never relies on `ctx.obj`**, which is not populated in completion mode.
- Returns `[]` gracefully when no `.lattice/` project is found.

### click.Choice params — no callback needed

Options already using `click.Choice` get completion for free from Click 8.1. These require **no `shell_complete=` callback**:

| Parameter | Already using click.Choice? |
|-----------|----------------------------|
| `--workflow` | yes (`classic`, `opinionated`) |
| `--type` | check at implementation time; convert if not |
| `--priority` | check at implementation time; convert if not |
| `--urgency` | check at implementation time; convert if not |
| `--complexity` | check at implementation time; convert if not |

**Implementation rule:** before adding a `shell_complete=` callback to any option, check if it already uses `click.Choice`. If it does, skip. If it uses `type=str` with a fixed set of values, convert it to `click.Choice` instead — this is cleaner and also adds input validation.

### Static callbacks (minimal I/O — reads config only)

| Parameter | Source | Fallback |
|-----------|--------|---------|
| `--status` | `.lattice/config.json → workflow.statuses` | `["backlog","ready","in_progress","in_review","done","cancelled","needs_human"]` |
| relationship TYPE (link/unlink) | hardcoded | `["blocks","blocked_by","subtask_of","parent_of","related_to","depends_on"]` |

### Dynamic callbacks (reads `.lattice/` data)

| Parameter | Source | Display format |
|-----------|--------|---------------|
| `<task_id>` (all commands) | `.lattice/ids.json` | `LAT-42` with task title as CompletionItem help |
| `<target_task_id>` (link, unlink) | same | same |
| `--assigned-to` / `<actor_id>` | last 50 task snapshots, actor field, deduplicated | `human:fede`, `agent:claude` |
| `<name>` in resource commands | `.lattice/resources/*.json` filenames | resource name |
| `<name>` in session commands | `.lattice/sessions/*.json` filenames | session name |

### Key callback signatures

```python
def complete_task_id(ctx, param, incomplete) -> list[CompletionItem]: ...
def complete_status(ctx, param, incomplete) -> list[CompletionItem]: ...
def complete_actor(ctx, param, incomplete) -> list[CompletionItem]: ...
def complete_resource_name(ctx, param, incomplete) -> list[CompletionItem]: ...
def complete_session_name(ctx, param, incomplete) -> list[CompletionItem]: ...
```

All filter results by `incomplete` prefix before returning.

---

## Command Coverage Matrix

| Command | task_id arg | Other dynamic | Static choices via callback | click.Choice (free) |
|---------|-------------|---------------|---------------------------|---------------------|
| `status` | ✓ | — | `--status` | `--type` etc. if converted |
| `assign` | ✓ | `<actor_id>` | — | — |
| `update` | ✓ | — | `--status` | — |
| `show` | ✓ | — | — | — |
| `comment` | ✓ | — | — | — |
| `comment-edit` | ✓ | comment_id: no completion* | — | — |
| `comment-delete` | ✓ | comment_id: no completion* | — | — |
| `react` / `unreact` | ✓ | comment_id: no completion* | — | — |
| `complete` | ✓ | — | — | — |
| `plan` | ✓ | — | — | — |
| `attach` | ✓ | — | — | `--type` if Choice |
| `link` / `unlink` | ✓ (both args) | relationship TYPE | — | — |
| `branch-link` / `branch-unlink` | ✓ | — | — | — |
| `archive` / `unarchive` | ✓ (variadic)** | — | — | — |
| `list` | — | `--assigned` | `--status`, `--type`, `--priority` | — |
| `next` | — | — | `--status` | — |
| `resource create/acquire/release/heartbeat` | — | `<name>` | — | — |
| `resource status` | — | `<name>` (optional) | — | — |
| `session end` | — | `<name>` | — | — |
| `init` | — | — | `--status` | `--workflow` (free) |

**Notes:**
- `*` Comment IDs are ULIDs with no meaningful prefix — tab-completing them from events is expensive and low-value. Deferred.
- `**` `archive` uses `nargs=-1` (variadic). Click's `shell_complete` on variadic args completes each token independently using the same callback — this works correctly in Click 8.1.

---

## Testing

- `tests/test_completion.py` — unit tests per callback using `tmp_path` with minimal `.lattice/` structures:
  - `complete_task_id`: returns short IDs from `ids.json`, filters by prefix, returns `[]` when no project.
  - `complete_status`: returns statuses from config, falls back to defaults.
  - `complete_actor`: deduplicates across snapshots.
  - `complete_resource_name` / `complete_session_name`: lists directory entries.
- Integration: `lattice completion --print --shell bash` / `zsh` / `fish` returns non-empty output.
- Integration: `lattice completion --install --shell bash` appends correct line to a temp file; second call returns "already_installed".
- Integration: `lattice completion --uninstall --shell bash` removes the line and writes backup.
- No shell-execution tests (completion scripts are shell-specific and not unit-testable in Python).

---

## Non-goals

- No PowerShell support.
- No completion for `--model`, `--session`, `--triggered-by`, `--on-behalf-of`, `--reason` (free-form strings).
- No completion for `update field=value` variadic pairs (custom parsing complexity, deferred).
- No branch name completion from `git` (deferred).
- No comment ID completion (low value, deferred).
