<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lattice Dashboard</title>
<style>
/* === Theme Variables === */
:root,[data-theme="carbon"]{
  --col-min-w:300px;--card-font-size:.85rem;--scroll-shadow:rgba(0,0,0,.3);
  --bg-base:#171717;--surface:#1E1E1E;--surface-hover:#292929;--surface-raised:#252525;--surface-card:#1C1C1C;
  --border:#333333;--border-subtle:#2A2A2A;--border-row:#222222;
  --text-primary:#E0E0E0;--text-secondary:#A0A0A0;--text-muted:#666666;--text-on-accent:#fff;
  --accent-primary:#EA580C;--accent-hover:#C2410C;--accent-glow:rgba(234,88,12,.18);--danger-glow:rgba(220,53,69,.25);
  --color-success:#16A34A;--color-danger:#DC2626;--color-danger-hover:#B91C1C;
  --color-warning:#D97706;--color-warning-bg:rgba(217,119,6,.12);
  --pri-critical-bg:#DC2626;--pri-high-bg:#EA580C;--pri-medium-bg:#2563EB;--pri-low-bg:#525252;
  --shadow-card-hover:0 1px 4px rgba(0,0,0,.4);--shadow-toast:0 2px 10px rgba(0,0,0,.5);
  --shadow-modal:0 8px 32px rgba(0,0,0,.7);--shadow-settings:-2px 0 10px rgba(0,0,0,.5);
  --overlay-bg:rgba(0,0,0,.7);
  --radius-sm:3px;--radius-md:4px;--radius-lg:6px;
  --font-body:ui-monospace,SFMono-Regular,Menlo,"Cascadia Mono",monospace;
  --font-mono:ui-monospace,SFMono-Regular,Menlo,"Cascadia Mono",monospace;
  --text-on-lane:#fff;--text-on-lane-muted:rgba(255,255,255,.75);--lane-btn-border:rgba(255,255,255,.5);
  --text-on-warning:#E0E0E0;
  --chip-human-bg:rgba(22,163,74,.12);--chip-human-text:#4ADE80;--chip-human-border:rgba(22,163,74,.28);--chip-human-hover:rgba(22,163,74,.2);
  --chip-agent-bg:rgba(234,88,12,.12);--chip-agent-text:#FB923C;--chip-agent-border:rgba(234,88,12,.28);--chip-agent-hover:rgba(234,88,12,.2);
  --chip-team-bg:rgba(99,102,241,.12);--chip-team-text:#A5B4FC;--chip-team-border:rgba(99,102,241,.28);--chip-team-hover:rgba(99,102,241,.2);
  --glow-primary:transparent;--glow-primary-strong:transparent
}

[data-theme="linear"]{
  --bg-base:#F7F8FA;--surface:#FFFFFF;--surface-hover:rgba(94,106,210,.06);
  --surface-raised:#EDEEF3;--surface-card:#FFFFFF;
  --border:#E1E4EA;--border-subtle:#EDEEF3;--border-row:#F2F3F7;
  --text-primary:#1B1D2A;--text-secondary:#5E6071;--text-muted:#8B8FA3;--text-on-accent:#FFFFFF;
  --accent-primary:#5E6AD2;--accent-hover:#4E5BBF;--accent-glow:rgba(94,106,210,.15);
  --color-success:#4CB782;--color-danger:#E5484D;--color-danger-hover:#CE2C31;
  --color-warning:#F5A623;--color-warning-bg:rgba(245,166,35,.1);
  --pri-critical-bg:#E5484D;--pri-high-bg:#F76808;--pri-medium-bg:#5E6AD2;--pri-low-bg:#8B8FA3;
  --shadow-card-hover:0 1px 3px rgba(0,0,0,.06),0 1px 2px rgba(0,0,0,.04);
  --shadow-toast:0 4px 12px rgba(0,0,0,.1);
  --shadow-modal:0 16px 48px rgba(0,0,0,.12),0 2px 8px rgba(0,0,0,.08);
  --shadow-settings:-1px 0 12px rgba(0,0,0,.06);
  --overlay-bg:rgba(15,15,20,.45);
  --radius-sm:6px;--radius-md:8px;--radius-lg:12px;
  --font-body:"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  --font-mono:"JetBrains Mono",ui-monospace,SFMono-Regular,Menlo,monospace;
  --glow-primary:transparent;--glow-primary-strong:transparent;
  --text-on-lane:#fff;--text-on-lane-muted:rgba(255,255,255,.8);--lane-btn-border:rgba(255,255,255,.6);
  --text-on-warning:#1B1D2A;
  --chip-human-bg:#e8f5e9;--chip-human-text:#2e7d32;--chip-human-border:#c8e6c9;--chip-human-hover:#c8e6c9;
  --chip-agent-bg:#ede7f6;--chip-agent-text:#5e35b1;--chip-agent-border:#d1c4e9;--chip-agent-hover:#d1c4e9;
  --chip-team-bg:#fff3e0;--chip-team-text:#e65100;--chip-team-border:#ffe0b2;--chip-team-hover:#ffe0b2;
}
[data-theme="vaporwave"]{
  --bg-base:#0d0221;--surface:rgba(26,10,46,.85);--surface-hover:rgba(255,113,206,.1);--surface-raised:rgba(45,20,80,.7);--surface-card:rgba(30,12,55,.6);
  --border:rgba(0,255,209,.2);--border-subtle:rgba(255,113,206,.15);--border-row:rgba(0,255,209,.08);
  --text-primary:#f0d0ff;--text-secondary:rgba(240,208,255,.75);--text-muted:rgba(240,208,255,.45);--text-on-accent:#fff;
  --accent-primary:#FF71CE;--accent-hover:#ff4fc0;--accent-glow:rgba(255,113,206,.25);--danger-glow:rgba(255,0,80,.3);
  --color-success:#00FFD1;--color-danger:#ff0050;--color-danger-hover:#d4003f;
  --color-warning:#ffb347;--color-warning-bg:rgba(255,179,71,.15);
  --pri-critical-bg:rgba(255,0,80,.8);--pri-high-bg:rgba(255,113,206,.7);--pri-medium-bg:rgba(0,255,209,.5);--pri-low-bg:rgba(240,208,255,.15);
  --shadow-card-hover:0 0 20px rgba(255,113,206,.2),0 0 40px rgba(0,255,209,.1);--shadow-toast:0 0 25px rgba(255,113,206,.3);
  --shadow-modal:0 0 60px rgba(255,113,206,.2),0 0 120px rgba(0,255,209,.1),0 8px 32px rgba(0,0,0,.5);
  --shadow-settings:-2px 0 20px rgba(255,113,206,.15);
  --overlay-bg:rgba(13,2,33,.8);
  --radius-sm:6px;--radius-md:10px;--radius-lg:14px;
  --font-body:"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  --font-mono:ui-monospace,SFMono-Regular,Menlo,monospace;
  --text-on-lane:#fff;--text-on-lane-muted:rgba(255,255,255,.85);--lane-btn-border:rgba(255,255,255,.6);
  --text-on-warning:#0d0221;
  --chip-human-bg:rgba(0,255,209,.15);--chip-human-text:#00FFD1;--chip-human-border:rgba(0,255,209,.3);--chip-human-hover:rgba(0,255,209,.25);
  --chip-agent-bg:rgba(255,113,206,.15);--chip-agent-text:#FF71CE;--chip-agent-border:rgba(255,113,206,.3);--chip-agent-hover:rgba(255,113,206,.25);
  --chip-team-bg:rgba(1,205,254,.15);--chip-team-text:#01CDFE;--chip-team-border:rgba(1,205,254,.3);--chip-team-hover:rgba(1,205,254,.25);
  --glow-primary:rgba(255,113,206,.1);--glow-primary-strong:rgba(255,113,206,.2)
}
[data-theme="matrix"]{
  --bg-base:#0a0a0a;--surface:rgba(0,10,0,.85);--surface-hover:rgba(57,255,20,.08);--surface-raised:rgba(57,255,20,.06);--surface-card:rgba(0,15,0,.7);
  --border:rgba(57,255,20,.2);--border-subtle:rgba(57,255,20,.1);--border-row:rgba(57,255,20,.06);
  --text-primary:#39FF14;--text-secondary:rgba(57,255,20,.75);--text-muted:rgba(57,255,20,.4);--text-on-accent:#0a0a0a;
  --accent-primary:#39FF14;--accent-hover:#2ed60f;--accent-glow:rgba(57,255,20,.3);
  --color-success:#39FF14;--color-danger:#ff2040;--color-danger-hover:#cc1a33;
  --color-warning:#bfff00;--color-warning-bg:rgba(191,255,0,.1);
  --pri-critical-bg:#ff2040;--pri-high-bg:#ff6600;--pri-medium-bg:#39FF14;--pri-low-bg:rgba(57,255,20,.2);
  --shadow-card-hover:0 0 15px rgba(57,255,20,.25),0 0 5px rgba(57,255,20,.15);--shadow-toast:0 0 20px rgba(57,255,20,.3);
  --shadow-modal:0 0 60px rgba(57,255,20,.15),0 0 120px rgba(57,255,20,.05);--shadow-settings:-2px 0 20px rgba(57,255,20,.1);
  --overlay-bg:rgba(0,0,0,.85);
  --radius-sm:2px;--radius-md:3px;--radius-lg:4px;
  --font-body:"Courier New",Courier,"Lucida Console",monospace;--font-mono:"Courier New",Courier,"Lucida Console",monospace;
  --text-on-lane:#0a0a0a;--text-on-lane-muted:rgba(10,10,10,.8);--lane-btn-border:rgba(10,10,10,.6);
  --text-on-warning:#0a0a0a;
  --chip-human-bg:rgba(57,255,20,.12);--chip-human-text:#39FF14;--chip-human-border:rgba(57,255,20,.3);--chip-human-hover:rgba(57,255,20,.2);
  --chip-agent-bg:rgba(0,255,128,.12);--chip-agent-text:#00ff80;--chip-agent-border:rgba(0,255,128,.3);--chip-agent-hover:rgba(0,255,128,.2);
  --chip-team-bg:rgba(180,255,20,.12);--chip-team-text:#b4ff14;--chip-team-border:rgba(180,255,20,.3);--chip-team-hover:rgba(180,255,20,.2);
  --glow-primary:rgba(57,255,20,.1);--glow-primary-strong:rgba(57,255,20,.25)
}
[data-theme="holographic"]{
  --bg-base:#0a0a0f;--surface:rgba(16,16,24,.92);--surface-hover:rgba(255,255,255,.05);--surface-raised:rgba(22,22,32,.85);--surface-card:rgba(14,14,22,.9);
  --border:rgba(255,255,255,.1);--border-subtle:rgba(255,255,255,.06);--border-row:rgba(255,255,255,.04);
  --text-primary:#e8e8f0;--text-secondary:rgba(232,232,240,.65);--text-muted:rgba(200,200,220,.4);--text-on-accent:#fff;
  --accent-primary:#6bccff;--accent-hover:#4db8ff;--accent-glow:rgba(107,204,255,.2);--danger-glow:rgba(255,107,107,.25);
  --color-success:#6bff6b;--color-danger:#ff6b6b;--color-danger-hover:#e05555;
  --color-warning:#ffd93d;--color-warning-bg:rgba(255,217,61,.1);
  --pri-critical-bg:rgba(255,107,107,.75);--pri-high-bg:rgba(255,170,60,.7);--pri-medium-bg:rgba(107,204,255,.6);--pri-low-bg:rgba(200,200,220,.15);
  --shadow-card-hover:0 0 16px rgba(107,204,255,.15),0 0 32px rgba(204,107,255,.08);--shadow-toast:0 0 20px rgba(0,0,0,.5);
  --shadow-modal:0 0 50px rgba(107,204,255,.1),0 8px 32px rgba(0,0,0,.6);--shadow-settings:-2px 0 16px rgba(204,107,255,.08);
  --overlay-bg:rgba(5,5,10,.85);
  --radius-sm:6px;--radius-md:8px;--radius-lg:12px;
  --font-body:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  --font-mono:ui-monospace,SFMono-Regular,Menlo,monospace;
  --text-on-lane:#fff;--text-on-lane-muted:rgba(255,255,255,.85);--lane-btn-border:rgba(255,255,255,.6);
  --text-on-warning:#1a1a24;
  --chip-human-bg:rgba(107,255,107,.1);--chip-human-text:#6bff6b;--chip-human-border:rgba(107,255,107,.25);--chip-human-hover:rgba(107,255,107,.18);
  --chip-agent-bg:rgba(107,204,255,.1);--chip-agent-text:#6bccff;--chip-agent-border:rgba(107,204,255,.25);--chip-agent-hover:rgba(107,204,255,.18);
  --chip-team-bg:rgba(255,217,61,.1);--chip-team-text:#ffd93d;--chip-team-border:rgba(255,217,61,.25);--chip-team-hover:rgba(255,217,61,.18);
  --glow-primary:rgba(107,204,255,.06);--glow-primary-strong:rgba(107,204,255,.12)
}
/* === Base === */
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:var(--font-body);background-color:var(--bg-base);color:var(--text-primary);line-height:1.5}
a{color:var(--accent-primary);text-decoration:none}
a:hover{text-decoration:underline}

/* Nav */
.nav{background:var(--surface);border-bottom:1px solid var(--border);padding:8px 16px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;position:sticky;top:0;z-index:10}
.nav-brand{font-weight:700;font-size:1.1rem;margin-right:8px;color:var(--text-primary)}
.nav-tab{padding:4px 12px;border-radius:var(--radius-sm);cursor:pointer;font-size:.875rem;color:var(--text-secondary);border:1px solid transparent}
.nav-tab:hover{background:var(--surface-hover)}
.nav-tab.active{background:var(--accent-primary);color:var(--text-on-accent);border-color:var(--accent-primary)}
.nav-right{margin-left:auto;display:flex;align-items:center;gap:8px}
.badge{display:inline-block;padding:2px 8px;border-radius:10px;font-size:.75rem;font-weight:600}
.badge-stat{background:var(--surface-raised);color:var(--text-secondary)}
.btn{padding:4px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);cursor:pointer;font-size:.875rem;color:var(--text-primary)}
.btn:hover{background:var(--surface-hover)}
.btn-icon{padding:4px 8px;font-size:1rem;line-height:1;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);cursor:pointer;color:var(--text-primary)}
.btn-icon:hover{background:var(--surface-hover)}
.btn-with-icon{display:inline-flex;align-items:center;gap:5px;padding:4px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);cursor:pointer;font-size:0.875rem;color:var(--text-primary)}
.btn-with-icon:hover{background:var(--surface-hover)}
.btn-with-icon svg{flex-shrink:0}

/* Nav Search */
.nav-search{display:flex;align-items:center;position:relative}
.nav-search-btn{background:none;border:1px solid var(--border);border-radius:var(--radius-sm);padding:4px 8px;cursor:pointer;color:var(--text-secondary);font-size:.875rem;display:flex;align-items:center;gap:4px}
.nav-search-btn:hover{background:var(--surface-hover);color:var(--text-primary)}
.nav-search-btn svg{width:14px;height:14px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
.nav-search-input{width:0;border:none;outline:none;background:transparent;font-size:.875rem;color:var(--text-primary);padding:0;transition:width .2s ease,padding .2s ease}
.nav-search.open .nav-search-input{width:180px;padding:4px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--surface)}
.nav-search.open .nav-search-btn{border-color:var(--accent-primary);color:var(--accent-primary)}
.nav-search-kbd{font-size:.65rem;color:var(--text-muted);border:1px solid var(--border);border-radius:3px;padding:1px 4px;margin-left:2px;font-family:var(--font-mono)}

/* Content */
.content{margin:0 auto;padding:16px}

/* Loading & errors */
.loading{text-align:center;padding:48px;color:var(--text-muted)}
.spinner{display:inline-block;width:24px;height:24px;border:3px solid var(--border);border-top-color:var(--accent-primary);border-radius:50%;animation:spin .6s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.error-box{background:var(--color-warning-bg);border:1px solid var(--color-warning);border-radius:var(--radius-md);padding:16px;margin:16px 0;text-align:center}
.error-box .btn{margin-top:8px}
.empty{text-align:center;padding:48px;color:var(--text-muted)}
.empty code{background:var(--surface-raised);padding:2px 6px;border-radius:3px;font-size:.875rem}

/* Toast notifications */
.toast-container{position:fixed;top:60px;right:16px;z-index:200;display:flex;flex-direction:column;gap:8px}
.toast{padding:10px 16px;border-radius:var(--radius-md);font-size:.85rem;color:var(--text-on-accent);box-shadow:var(--shadow-toast);animation:toastIn .3s ease;max-width:360px;word-break:break-word}
.toast-success{background:var(--color-success)}
.toast-error{background:var(--color-danger)}
@keyframes toastIn{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}

/* Board view — scroll wrapper with edge shadows */
.board-scroll-outer{position:relative}
.board-scroll-outer::before,.board-scroll-outer::after{content:"";position:absolute;top:0;bottom:0;width:28px;pointer-events:none;z-index:2;opacity:0;transition:opacity .2s}
.board-scroll-outer::before{left:0;background:linear-gradient(to right,var(--scroll-shadow),transparent)}
.board-scroll-outer::after{right:0;background:linear-gradient(to left,var(--scroll-shadow),transparent)}
.board-scroll-outer.shadow-left::before{opacity:1}
.board-scroll-outer.shadow-right::after{opacity:1}
.board-scroll{overflow-x:auto;overflow-y:visible;-webkit-overflow-scrolling:touch}
.board{display:grid;gap:12px;align-items:start}
.board-col{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md);min-height:auto;transition:box-shadow .2s,border-color .2s}
.board-col-header{padding:8px 12px;font-weight:600;font-size:.875rem;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;border-radius:var(--radius-md) var(--radius-md) 0 0;position:relative}
.board-col-header .count{font-weight:400;color:var(--text-on-lane-muted);font-size:.75rem}
.board-col-header .lane-color-btn{position:absolute;right:4px;top:4px;width:20px;height:20px;border:2px solid var(--lane-btn-border);border-radius:50%;cursor:pointer;padding:0;background:transparent;opacity:0;transition:opacity .2s}
.board-col-header:hover .lane-color-btn{opacity:1}
.board-col-body{padding:8px}
.board-sub-header{font-size:.75rem;font-weight:600;color:var(--text-muted);padding:6px 4px 4px;margin-top:4px;border-top:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
.board-sub-header:first-child{margin-top:0;border-top:none}
.board-sub-header .count{font-weight:400;font-size:.7rem;opacity:.7}

/* Drag and drop states */
.board-col.drag-over{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-glow)}
.board-col.drag-invalid{border-color:var(--color-danger);box-shadow:0 0 0 2px var(--danger-glow)}
.card.dragging{opacity:.4;transform:scale(.95)}
.card{background:var(--surface-card);border:1px solid var(--border-subtle);border-radius:var(--radius-sm);padding:8px 10px;margin-bottom:6px;cursor:grab;font-size:var(--card-font-size,.85rem);transition:box-shadow .15s,opacity .15s,transform .15s}
.card:hover{box-shadow:var(--shadow-card-hover)}
.card:active{cursor:grabbing}
.card-title{font-weight:600;margin-bottom:4px;word-break:break-word}
.card-meta{display:flex;gap:6px;flex-wrap:wrap;align-items:center}

/* Active session indicator (pulsing dot) */
.active-dot{display:inline-block;width:8px;height:8px;border-radius:50%;background:var(--color-success);vertical-align:middle;flex-shrink:0;animation:activePulse 2s ease-in-out infinite}
@keyframes activePulse{0%,100%{opacity:1;box-shadow:0 0 0 0 var(--color-success)}50%{opacity:.7;box-shadow:0 0 0 4px transparent}}
.active-badge{display:inline-flex;align-items:center;gap:4px;padding:1px 7px;border-radius:10px;font-size:.7rem;font-weight:600;background:rgba(22,163,74,.15);color:var(--color-success);border:1px solid rgba(22,163,74,.3);white-space:nowrap}
.active-badge .active-dot{width:6px;height:6px}

/* Heat indicator (based on last_status_changed_at) */
/* Board cards: heat bar is rendered inline via JS; these classes add positioning context */
.card.heat-hot,.card.heat-warm,.card.heat-cooling{position:relative}
/* List view: colored left border */
tr.heat-hot td:first-child{border-left:3px solid #ef4444}
tr.heat-warm td:first-child{border-left:3px solid #f97316}
tr.heat-cooling td:first-child{border-left:3px solid #eab308}
/* Heat bar element inside board cards */
.heat-bar{position:absolute;left:0;bottom:0;pointer-events:none;z-index:1;transition:height .5s linear}

/* Priority badges */
.pri-critical{background:var(--pri-critical-bg);color:var(--text-on-accent)}
.pri-high{background:var(--pri-high-bg);color:var(--text-on-accent)}
.pri-medium{background:var(--pri-medium-bg);color:var(--text-on-accent)}
.pri-low{background:var(--pri-low-bg);color:var(--text-on-accent)}

/* Type badges */
.type-badge{background:var(--surface-raised);color:var(--text-secondary)}

.board-wrapper{position:relative}

/* Status colors for column headers (CSS fallback — JS inline styles override these) */
.status-done .board-col-header{background:#198754;color:var(--text-on-lane)}
.status-cancelled .board-col-header{background:#6c757d;color:var(--text-on-lane)}
.status-in_planning .board-col-header{background:#17a2b8;color:var(--text-on-lane)}
.status-planned .board-col-header{background:#20c997;color:var(--text-on-lane)}
.status-in_implementation .board-col-header{background:#0d6efd;color:var(--text-on-lane)}
.status-implemented .board-col-header{background:#0dcaf0;color:var(--text-on-lane)}
.status-in_review .board-col-header{background:#6f42c1;color:var(--text-on-lane)}
.status-backlog .board-col-header{background:#adb5bd;color:var(--text-on-lane)}
.status-blocked .board-col-header{background:#dc3545;color:var(--text-on-lane)}
.status-needs_human .board-col-header{background:#f59e0b;color:#212529}
.status-in_progress .board-col-header{background:#0d6efd;color:var(--text-on-lane)}
.status-review .board-col-header{background:#6f42c1;color:var(--text-on-lane)}

/* List view */
.filters{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;align-items:center}
.filters select,.filters input{padding:4px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.85rem;background:var(--surface);color:var(--text-primary)}
.filters input{min-width:200px}
.filters label{font-size:.85rem;display:flex;align-items:center;gap:4px;cursor:pointer;color:var(--text-secondary)}
table{width:100%;border-collapse:collapse;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md);overflow:hidden;font-size:.85rem}
th{text-align:left;padding:8px 10px;background:var(--bg-base);border-bottom:2px solid var(--border);font-weight:600;white-space:nowrap;color:var(--text-primary)}
td{padding:6px 10px;border-bottom:1px solid var(--border-row);vertical-align:top;color:var(--text-primary)}
tr:hover td{background:var(--surface-hover)}
.id-cell{font-family:var(--font-mono);font-size:.8rem;color:var(--text-muted);max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}

/* Detail view */
.detail{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md);padding:20px;max-width:900px}
.detail-header{margin-bottom:16px}
.detail-title{font-size:1.3rem;font-weight:700;margin-bottom:4px}
.detail-meta{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
.detail-field{margin-bottom:12px}
.detail-field dt{font-weight:600;font-size:.85rem;color:var(--text-muted);margin-bottom:2px}
.detail-field dd{font-size:.9rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--text-primary)}
.detail-section{margin-top:20px;padding-top:16px;border-top:1px solid var(--border)}
.detail-section h3{font-size:.95rem;font-weight:600;margin-bottom:8px}
.event-item{padding:6px 0;border-bottom:1px solid var(--border-row);font-size:.85rem;display:flex;gap:8px;flex-wrap:wrap}
.event-item:last-child{border-bottom:none}
.event-ts{color:var(--text-muted);font-family:var(--font-mono);font-size:.8rem;white-space:nowrap}
.event-type{font-weight:600}
.event-actor{color:var(--text-muted)}
.back-link{display:inline-block;margin-bottom:12px;font-size:.9rem}
.archived-badge{background:var(--color-warning);color:var(--text-on-warning);padding:2px 8px;border-radius:var(--radius-sm);font-size:.8rem;font-weight:600}
.rel-list,.art-list{list-style:none;padding:0}
.rel-list li,.art-list li{padding:4px 0;font-size:.85rem}

/* Activity view */
.activity-filters{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;align-items:center}
.activity-filters select,.activity-filters input{padding:4px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.85rem;background:var(--surface);color:var(--text-primary)}
.activity-filters input[type="text"]{min-width:180px}
.activity-filters input[type="datetime-local"]{width:170px;font-size:.8rem}
.activity-date-custom{display:flex;gap:6px;align-items:center;font-size:.8rem;color:var(--text-secondary)}
.filter-pills{display:flex;gap:6px;margin-bottom:10px;flex-wrap:wrap}
.filter-pill{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;background:var(--accent-primary);color:var(--text-on-accent,#fff);border-radius:12px;font-size:.75rem;cursor:pointer}
.filter-pill:hover{opacity:.85}
.filter-pill .pill-x{font-weight:bold;margin-left:2px}
.filter-count{font-size:.8rem;color:var(--text-muted);margin-left:auto;white-space:nowrap}
.activity-day-header{font-size:.8rem;font-weight:600;color:var(--text-secondary);padding:10px 0 4px;margin-top:8px;border-bottom:1px solid var(--border-row);text-transform:uppercase;letter-spacing:.5px}
.activity-day-header:first-child{margin-top:0}
.activity-item{display:flex;gap:10px;padding:8px 0;border-bottom:1px solid var(--border-row);font-size:.85rem;align-items:flex-start;cursor:pointer;flex-wrap:wrap}
.activity-item:last-child{border-bottom:none}
.activity-item:hover{background:var(--surface-hover,rgba(128,128,128,.06))}
.activity-item.focused{outline:2px solid var(--accent-primary);outline-offset:-2px;border-radius:var(--radius-sm)}
.activity-item-main{display:flex;gap:10px;align-items:flex-start;width:100%;min-width:0}
.activity-item-actor{flex-shrink:0;font-size:.8rem;color:var(--text-muted);cursor:pointer;max-width:140px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.activity-item-actor:hover{color:var(--accent-primary)}
.activity-item-top{display:flex;gap:8px;align-items:center;flex-wrap:wrap;flex:1;min-width:0}
.activity-item-summary{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.activity-item-meta{display:flex;gap:8px;align-items:center;flex-shrink:0;color:var(--text-muted);font-size:.8rem}
.activity-type-badge{display:inline-block;padding:1px 6px;border-radius:var(--radius-sm);font-size:.75rem;font-weight:600;white-space:nowrap;cursor:pointer;line-height:1.4}
.activity-type-badge:hover{filter:brightness(1.15)}
.activity-item-detail{width:100%;background:var(--surface-raised,var(--surface));border:1px solid var(--border);border-radius:var(--radius-sm);padding:10px 12px;margin-top:6px;color:var(--text-secondary)}
.activity-item.expanded .activity-item-detail{display:block}
.activity-item .activity-item-detail{display:none}
.activity-detail-actions{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;align-items:center}
.activity-detail-actions .btn-sm{padding:3px 10px;font-size:.78rem;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--surface);color:var(--text-primary);cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;gap:4px}
.activity-detail-actions .btn-sm:hover:not(:disabled){background:var(--accent-primary);color:#fff;border-color:var(--accent-primary)}
.activity-detail-actions .btn-sm:disabled{opacity:.35;cursor:not-allowed}
.activity-detail-json{font-family:var(--font-mono);font-size:.78rem;white-space:pre-wrap;word-break:break-all;max-height:250px;overflow-y:auto;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)}
.activity-list{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md);padding:12px 16px}
.activity-scroll-sentinel{height:1px}
.activity-loading-more{text-align:center;padding:12px 0;font-size:.85rem;color:var(--text-muted)}
/* Task picker dialog */
.task-picker-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.4);z-index:200;display:flex;align-items:flex-start;justify-content:center;padding-top:80px}
.task-picker{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md);width:420px;max-height:70vh;display:flex;flex-direction:column;box-shadow:0 8px 32px rgba(0,0,0,.25)}
.task-picker-header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;gap:8px;align-items:center}
.task-picker-header input{flex:1;padding:6px 10px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.9rem;background:var(--surface);color:var(--text-primary)}
.task-picker-header button{background:none;border:none;font-size:1.1rem;cursor:pointer;color:var(--text-muted);padding:4px 8px}
.task-picker-header button:hover{color:var(--text-primary)}
.task-picker-list{overflow-y:auto;flex:1;padding:4px 0}
.task-picker-item{padding:8px 16px;cursor:pointer;display:flex;gap:8px;align-items:center;font-size:.85rem}
.task-picker-item:hover,.task-picker-item.selected{background:var(--accent-primary);color:#fff}
.task-picker-item .tpi-id{font-weight:600;font-family:var(--font-mono);font-size:.8rem;white-space:nowrap;min-width:60px}
.task-picker-item .tpi-title{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.task-picker-item .tpi-status{font-size:.75rem;opacity:.7}
.task-picker-empty{padding:16px;text-align:center;color:var(--text-muted);font-size:.85rem}

/* Settings panel */
.settings-panel{position:fixed;top:0;right:0;width:320px;height:100%;background:var(--surface);border-left:1px solid var(--border);z-index:150;box-shadow:var(--shadow-settings);display:flex;flex-direction:column;transform:translateX(100%);transition:transform .25s ease}
.settings-panel.open{transform:translateX(0)}
.settings-header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;font-weight:600;font-size:.95rem;color:var(--text-primary)}
.settings-close{background:none;border:none;font-size:1.2rem;cursor:pointer;color:var(--text-muted);padding:4px}
.settings-close:hover{color:var(--text-primary)}
.settings-body{padding:16px;overflow-y:auto;flex:1}
.settings-group{margin-bottom:20px}
.settings-group label{display:block;font-size:.85rem;font-weight:600;color:var(--text-secondary);margin-bottom:4px}
.settings-group input[type="text"],.settings-group input[type="url"]{width:100%;padding:6px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.85rem;background:var(--surface);color:var(--text-primary)}
.settings-group .hint{font-size:.75rem;color:var(--text-muted);margin-top:2px}
.settings-group .btn{margin-top:6px}
.lane-color-row{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-size:.85rem}
.lane-color-row .lane-name{min-width:90px;color:var(--text-primary)}
.lane-color-row input[type="color"]{width:32px;height:28px;border:1px solid var(--border);border-radius:var(--radius-sm);padding:1px;cursor:pointer}

/* Modal */
.modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:var(--overlay-bg);z-index:50;display:flex;align-items:center;justify-content:center;animation:fadeIn .2s ease}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
.modal{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-lg);box-shadow:var(--shadow-modal);width:90%;max-width:560px;max-height:90vh;overflow-y:auto;animation:slideUp .2s ease}
@keyframes slideUp{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
.modal-header{padding:16px 20px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;color:var(--text-primary)}
.modal-header h2{font-size:1.1rem;font-weight:700;margin:0}
.modal-body{padding:20px}
.modal-footer{padding:12px 20px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}

/* Form controls */
.form-group{margin-bottom:14px}
.form-group label{display:block;font-size:.85rem;font-weight:600;color:var(--text-secondary);margin-bottom:4px}
.form-control{width:100%;padding:6px 10px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.875rem;font-family:inherit;line-height:1.5;background:var(--surface);color:var(--text-primary)}
.form-control:focus{outline:none;border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-glow)}
textarea.form-control{min-height:80px;resize:vertical}
select.form-control{cursor:pointer}

/* Buttons */
.btn-primary{background:var(--accent-primary);color:var(--text-on-accent);border-color:var(--accent-primary)}
.btn-primary:hover{background:var(--accent-hover)}
.btn-danger{background:var(--color-danger);color:var(--text-on-accent);border-color:var(--color-danger)}
.btn-danger:hover{background:var(--color-danger-hover)}
.btn-sm{padding:2px 8px;font-size:.8rem}
.btn-new-task{background:var(--accent-primary);color:var(--text-on-accent);border-color:var(--accent-primary);font-weight:600}
.btn-new-task:hover{background:var(--accent-hover)}

/* Detail view: inline editing */
.editable{cursor:pointer;border-bottom:1px dashed transparent;transition:border-color .15s}
.editable:hover{border-bottom-color:var(--accent-primary)}
.inline-edit{display:flex;gap:6px;align-items:center}
.inline-edit .form-control{flex:1}
.inline-edit .btn{flex-shrink:0}

/* Detail view: action bar */
.detail-actions{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px}
.detail-actions select{padding:4px 8px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.85rem;background:var(--surface);color:var(--text-primary)}

/* Comment section */
.comment-form{display:flex;gap:8px;margin-top:8px}
.comment-form textarea{flex:1;min-height:60px}
.comment-item{padding:8px;background:var(--surface-card);border:1px solid var(--border-subtle);border-radius:var(--radius-sm);margin-bottom:6px;font-size:.85rem}
.comment-item .comment-meta{font-size:.8rem;color:var(--text-muted);margin-bottom:2px}
.comment-item .comment-body{white-space:pre-wrap}

/* === Linear Theme Overrides === */
/* Linear: tight, dense, professional SaaS feel */
[data-theme="linear"] body{
  background:#F7F8FA;
  font-feature-settings:"cv02","cv03","cv04","cv11";
  -webkit-font-smoothing:antialiased;
  letter-spacing:-.01em
}
[data-theme="linear"] .nav{
  background:rgba(255,255,255,.85);
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  border-bottom:1px solid #E1E4EA;
  padding:6px 16px
}
[data-theme="linear"] .nav-brand{
  font-weight:600;
  font-size:1rem;
  letter-spacing:-.02em;
  color:#1B1D2A
}
[data-theme="linear"] .nav-tab{
  font-size:.8125rem;
  font-weight:500;
  padding:3px 10px;
  border-radius:6px;
  color:#5E6071;
  transition:background .12s,color .12s
}
[data-theme="linear"] .nav-tab:hover{
  background:rgba(94,106,210,.06);
  color:#1B1D2A
}
[data-theme="linear"] .nav-tab.active{
  background:#5E6AD2;
  color:#fff;
  font-weight:600;
  box-shadow:none
}
[data-theme="linear"] .board-col{
  background:#FFFFFF;
  border:1px solid #E1E4EA;
  border-radius:8px;
  box-shadow:0 1px 2px rgba(0,0,0,.03)
}
[data-theme="linear"] .board-col:hover{
  box-shadow:0 1px 4px rgba(0,0,0,.06)
}
[data-theme="linear"] .board-col-header{
  font-size:.8125rem;
  font-weight:600;
  padding:7px 12px;
  letter-spacing:.01em;
  border-radius:8px 8px 0 0
}
[data-theme="linear"] .card{
  background:#FFFFFF;
  border:1px solid #EDEEF3;
  border-radius:6px;
  padding:8px 10px;
  margin-bottom:4px;
  transition:box-shadow .12s,border-color .12s
}
[data-theme="linear"] .card:hover{
  border-color:#D3D5E0;
  box-shadow:0 1px 3px rgba(0,0,0,.06),0 1px 2px rgba(0,0,0,.04)
}
[data-theme="linear"] .badge{
  font-size:.7rem;
  font-weight:600;
  padding:1px 6px;
  border-radius:4px;
  letter-spacing:.02em;
  text-transform:uppercase
}
[data-theme="linear"] .detail{
  background:#FFFFFF;
  border:1px solid #E1E4EA;
  border-radius:10px;
  box-shadow:0 1px 3px rgba(0,0,0,.04)
}
[data-theme="linear"] .detail-title{
  font-size:1.2rem;
  font-weight:700;
  letter-spacing:-.02em
}
[data-theme="linear"] .modal{
  border-radius:12px;
  border:1px solid #E1E4EA;
  box-shadow:0 16px 48px rgba(0,0,0,.12),0 2px 8px rgba(0,0,0,.08)
}
[data-theme="linear"] .settings-panel{
  background:rgba(255,255,255,.95);
  backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);
  border-left:1px solid #E1E4EA
}
[data-theme="linear"] .form-control{
  border-radius:6px;
  font-size:.8125rem;
  padding:5px 10px;
  border:1px solid #E1E4EA;
  transition:border-color .12s,box-shadow .12s
}
[data-theme="linear"] .form-control:focus{
  border-color:#5E6AD2;
  box-shadow:0 0 0 3px rgba(94,106,210,.12)
}
[data-theme="linear"] .btn{
  font-size:.8125rem;
  font-weight:500;
  border-radius:6px;
  padding:4px 12px;
  transition:background .1s,border-color .1s
}
[data-theme="linear"] .btn-primary{
  background:#5E6AD2;
  border-color:#5E6AD2;
  font-weight:600
}
[data-theme="linear"] .btn-primary:hover{
  background:#4E5BBF;
  border-color:#4E5BBF
}
[data-theme="linear"] table{
  border:1px solid #E1E4EA;
  border-radius:8px
}
[data-theme="linear"] th{
  font-size:.75rem;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:.04em;
  color:#8B8FA3;
  background:#F7F8FA;
  padding:6px 10px
}
[data-theme="linear"] td{
  font-size:.8125rem;
  padding:5px 10px
}
[data-theme="linear"] tr:hover td{
  background:rgba(94,106,210,.03)
}
[data-theme="linear"] .activity-list{
  background:#FFFFFF;
  border:1px solid #E1E4EA;
  border-radius:8px;
  box-shadow:0 1px 2px rgba(0,0,0,.03)
}
[data-theme="linear"] .toast-success{
  background:#4CB782;
  border-radius:8px
}
[data-theme="linear"] .toast-error{
  background:#E5484D;
  border-radius:8px
}
[data-theme="linear"] .comment-item{
  background:#F7F8FA;
  border:1px solid #EDEEF3;
  border-radius:6px
}
[data-theme="linear"] .member-chip-human{background:#E8F5E9;color:#2E7D32;border-color:#C8E6C9}
[data-theme="linear"] .member-chip-agent{background:#EDE7F6;color:#5E35B1;border-color:#D1C4E9}
[data-theme="linear"] .member-chip-team{background:#FFF3E0;color:#E65100;border-color:#FFE0B2}
[data-theme="linear"] ::-webkit-scrollbar{width:6px;height:6px}
[data-theme="linear"] ::-webkit-scrollbar-track{background:transparent}
[data-theme="linear"] ::-webkit-scrollbar-thumb{background:#D3D5E0;border-radius:3px}
[data-theme="linear"] ::-webkit-scrollbar-thumb:hover{background:#B0B3C4}

/* === Carbon Theme Overrides === */
[data-theme="carbon"] body{
  background-image:
    repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(255,255,255,.01) 3px,rgba(255,255,255,.01) 4px),
    radial-gradient(ellipse at 50% 0%,rgba(234,88,12,.03) 0%,transparent 50%),
    radial-gradient(ellipse at 0% 100%,rgba(234,88,12,.015) 0%,transparent 40%);
  background-attachment:fixed;
  font-variant-numeric:tabular-nums;letter-spacing:.01em
}
[data-theme="carbon"] .nav{background:#1A1A1A;border-bottom:2px solid #EA580C;padding:6px 16px}
[data-theme="carbon"] .nav-brand{font-weight:700;text-transform:uppercase;font-size:.95rem;letter-spacing:.12em;color:#EA580C}
[data-theme="carbon"] .nav-tab{border-radius:2px;text-transform:uppercase;font-size:.75rem;font-weight:600;letter-spacing:.08em;padding:4px 10px}
[data-theme="carbon"] .nav-tab.active{background:#EA580C;color:#fff;border-radius:2px}
[data-theme="carbon"] .board-col{background:#1E1E1E;border-color:#333;border-radius:3px}
[data-theme="carbon"] .board-col-header{font-size:.78rem;text-transform:uppercase;letter-spacing:.1em;font-weight:700;border-radius:3px 3px 0 0;padding:6px 10px}
[data-theme="carbon"] .card{background:#1C1C1C;border-color:#2A2A2A;border-radius:2px;padding:6px 8px;margin-bottom:4px}
/* Carbon heat bar colors handled via JS inline styles */
[data-theme="carbon"] .card:hover{box-shadow:0 1px 6px rgba(0,0,0,.4);border-color:#EA580C}
[data-theme="carbon"] .card-title{}
[data-theme="carbon"] .board-col.drag-over{border-color:#EA580C;box-shadow:inset 0 0 0 1px #EA580C}
[data-theme="carbon"] .board-col.drag-invalid{border-color:#DC2626;box-shadow:inset 0 0 0 1px #DC2626}
[data-theme="carbon"] .detail{background:#1E1E1E;border-color:#333;border-radius:4px}
[data-theme="carbon"] .detail-title{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;letter-spacing:.02em}
[data-theme="carbon"] .form-control{border-radius:2px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:.82rem}
[data-theme="carbon"] .form-control:focus{box-shadow:0 0 0 2px rgba(234,88,12,.25)}
[data-theme="carbon"] .settings-panel{background:#1A1A1A;border-left:2px solid #333}
[data-theme="carbon"] .modal{background:#1E1E1E;border:1px solid #444;border-radius:4px}
[data-theme="carbon"] .modal-header h2{text-transform:uppercase;font-size:.95rem;letter-spacing:.06em}
[data-theme="carbon"] .toast-success{background:#16A34A;border-radius:2px}
[data-theme="carbon"] .toast-error{background:#DC2626;border-radius:2px}
[data-theme="carbon"] .badge{border-radius:2px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:.72rem;text-transform:uppercase;letter-spacing:.04em}
[data-theme="carbon"] .pri-critical,.pri-high,.pri-medium,.pri-low{border-radius:2px}
[data-theme="carbon"] .activity-list{background:#1E1E1E;border-color:#333}
[data-theme="carbon"] table{background:#1E1E1E;border-color:#333}
[data-theme="carbon"] th{text-transform:uppercase;font-size:.72rem;letter-spacing:.08em;border-bottom:2px solid #EA580C}
[data-theme="carbon"] .comment-item{background:#1C1C1C;border-color:#2A2A2A;border-radius:2px}
[data-theme="carbon"] .member-chip{border-radius:2px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:.72rem;letter-spacing:.02em}
[data-theme="carbon"] ::-webkit-scrollbar{width:6px}
[data-theme="carbon"] ::-webkit-scrollbar-track{background:#171717}
[data-theme="carbon"] ::-webkit-scrollbar-thumb{background:#444;border-radius:1px}
[data-theme="carbon"] ::-webkit-scrollbar-thumb:hover{background:#EA580C}
[data-theme="carbon"] .status-backlog .board-col-header{background:#404040}
[data-theme="carbon"] .status-in_planning .board-col-header{background:#0E7490}
[data-theme="carbon"] .status-planned .board-col-header{background:#0F766E}
[data-theme="carbon"] .status-in_implementation .board-col-header{background:#2563EB}
[data-theme="carbon"] .status-implemented .board-col-header{background:#0284C7}
[data-theme="carbon"] .status-in_review .board-col-header{background:#7C3AED}
[data-theme="carbon"] .status-done .board-col-header{background:#16A34A}
[data-theme="carbon"] .status-cancelled .board-col-header{background:#525252}

/* === Vaporwave Theme Overrides === */
[data-theme="vaporwave"] body{
  background-image:
    repeating-linear-gradient(0deg,transparent,transparent 59px,rgba(0,255,209,.04) 59px,rgba(0,255,209,.04) 60px),
    repeating-linear-gradient(90deg,transparent,transparent 59px,rgba(255,113,206,.04) 59px,rgba(255,113,206,.04) 60px),
    linear-gradient(180deg,#0d0221 0%,#1a0a2e 40%,#2d1450 100%)
}
[data-theme="vaporwave"] .nav{
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
  background:linear-gradient(90deg,rgba(26,10,46,.9),rgba(45,20,80,.85),rgba(26,10,46,.9));
  border-bottom:1px solid rgba(255,113,206,.25);
  box-shadow:0 2px 30px rgba(255,113,206,.1)
}
[data-theme="vaporwave"] .nav-brand{
  letter-spacing:.15em;
  background:linear-gradient(90deg,#FF71CE,#01CDFE,#00FFD1);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  background-clip:text;
  filter:drop-shadow(0 0 10px rgba(255,113,206,.5));
  animation:vw-brand-glow 3s ease-in-out infinite alternate
}
@keyframes vw-brand-glow{
  0%{filter:drop-shadow(0 0 10px rgba(255,113,206,.5))}
  100%{filter:drop-shadow(0 0 20px rgba(0,255,209,.5))}
}
[data-theme="vaporwave"] .nav-tab.active{
  background:linear-gradient(135deg,#FF71CE,#B967FF);
  box-shadow:0 0 15px rgba(255,113,206,.4),0 0 30px rgba(185,103,255,.2);
  border-color:transparent
}
[data-theme="vaporwave"] .board-col{
  backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);
  background:rgba(26,10,46,.5);
  border:1px solid rgba(255,113,206,.12);
  box-shadow:0 0 20px var(--glow-primary)
}
[data-theme="vaporwave"] .board-col:hover{box-shadow:0 0 30px var(--glow-primary-strong)}
[data-theme="vaporwave"] .board-col-header{
  box-shadow:0 2px 15px rgba(0,0,0,.3);
  text-shadow:0 0 10px rgba(255,255,255,.3)
}
[data-theme="vaporwave"] .card{
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
  background:linear-gradient(135deg,rgba(45,20,80,.5),rgba(26,10,46,.6));
  border:1px solid rgba(0,255,209,.1);
  box-shadow:0 0 12px var(--glow-primary);
  transition:box-shadow .2s,transform .2s,border-color .2s
}
[data-theme="vaporwave"] .card:hover{
  box-shadow:0 0 25px rgba(255,113,206,.25),0 0 50px rgba(0,255,209,.1);
  transform:translateY(-2px);
  border-color:rgba(255,113,206,.3)
}
[data-theme="vaporwave"] .card.dragging{
  box-shadow:0 0 40px rgba(255,113,206,.4),0 0 80px rgba(0,255,209,.2)
}
[data-theme="vaporwave"] .board-col.drag-over{
  border-color:#00FFD1;
  box-shadow:0 0 30px rgba(0,255,209,.3)
}
[data-theme="vaporwave"] .board-col.drag-invalid{
  border-color:#ff0050;
  box-shadow:0 0 30px rgba(255,0,80,.3)
}
[data-theme="vaporwave"] .pri-critical{
  box-shadow:0 0 10px rgba(255,0,80,.6);
  animation:vw-pulse-critical 2s ease-in-out infinite
}
[data-theme="vaporwave"] .pri-high{box-shadow:0 0 8px rgba(255,113,206,.5)}
[data-theme="vaporwave"] .pri-medium{box-shadow:0 0 8px rgba(0,255,209,.4)}
[data-theme="vaporwave"] .pri-low{box-shadow:0 0 6px rgba(240,208,255,.1)}
@keyframes vw-pulse-critical{
  0%,100%{box-shadow:0 0 10px rgba(255,0,80,.6)}
  50%{box-shadow:0 0 22px rgba(255,0,80,.9),0 0 44px rgba(255,0,80,.3)}
}
[data-theme="vaporwave"] .detail{
  backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);
  background:linear-gradient(160deg,rgba(45,20,80,.6),rgba(26,10,46,.7));
  box-shadow:0 0 30px var(--glow-primary)
}
[data-theme="vaporwave"] .detail-title{
  background:linear-gradient(90deg,#FF71CE,#01CDFE);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  background-clip:text
}
[data-theme="vaporwave"] .modal{
  backdrop-filter:blur(24px);-webkit-backdrop-filter:blur(24px);
  border:1px solid rgba(255,113,206,.25);
  background:linear-gradient(160deg,rgba(45,20,80,.9),rgba(26,10,46,.95))
}
[data-theme="vaporwave"] .modal-overlay{backdrop-filter:blur(6px)}
[data-theme="vaporwave"] .form-control:focus{
  box-shadow:0 0 0 2px rgba(255,113,206,.3),0 0 20px rgba(255,113,206,.1);
  border-color:#FF71CE
}
[data-theme="vaporwave"] .settings-panel{
  backdrop-filter:blur(24px);-webkit-backdrop-filter:blur(24px);
  background:linear-gradient(180deg,rgba(45,20,80,.95),rgba(26,10,46,.98))
}
[data-theme="vaporwave"] .toast-success{
  background:linear-gradient(135deg,#00FFD1,#00c9a7);
  color:#0d0221;
  box-shadow:0 0 20px rgba(0,255,209,.4)
}
[data-theme="vaporwave"] .toast-error{
  background:linear-gradient(135deg,#ff0050,#ff3377);
  box-shadow:0 0 20px rgba(255,0,80,.4)
}
[data-theme="vaporwave"] .activity-list{
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  background:rgba(26,10,46,.5)
}
[data-theme="vaporwave"] table{
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  background:rgba(26,10,46,.5)
}
[data-theme="vaporwave"] .comment-item{
  backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);
  background:linear-gradient(135deg,rgba(45,20,80,.4),rgba(26,10,46,.5))
}
[data-theme="vaporwave"] ::-webkit-scrollbar{width:8px}
[data-theme="vaporwave"] ::-webkit-scrollbar-track{background:rgba(13,2,33,.5)}
[data-theme="vaporwave"] ::-webkit-scrollbar-thumb{
  background:linear-gradient(180deg,#FF71CE,#B967FF);
  border-radius:4px
}
[data-theme="vaporwave"] ::-webkit-scrollbar-thumb:hover{
  background:linear-gradient(180deg,#ff4fc0,#a64dff)
}
[data-theme="vaporwave"] .status-backlog .board-col-header{background:#4a2870}
[data-theme="vaporwave"] .status-in_planning .board-col-header{background:linear-gradient(135deg,#B967FF,#8B5CF6)}
[data-theme="vaporwave"] .status-planned .board-col-header{background:linear-gradient(135deg,#01CDFE,#05a8cc)}
[data-theme="vaporwave"] .status-in_implementation .board-col-header{background:linear-gradient(135deg,#FF71CE,#d45fad)}
[data-theme="vaporwave"] .status-implemented .board-col-header{background:linear-gradient(135deg,#00FFD1,#00c9a7)}
[data-theme="vaporwave"] .status-in_review .board-col-header{background:linear-gradient(135deg,#B967FF,#FF71CE)}
[data-theme="vaporwave"] .status-done .board-col-header{background:linear-gradient(135deg,#00FFD1,#01CDFE)}
[data-theme="vaporwave"] .status-cancelled .board-col-header{background:#3d2060}
[data-theme="vaporwave"] .badge-stat{
  background:rgba(255,113,206,.12);
  color:#FF71CE;
  border:1px solid rgba(255,113,206,.2)
}
[data-theme="vaporwave"] .btn{
  border-color:rgba(255,113,206,.2);
  background:rgba(45,20,80,.5)
}
[data-theme="vaporwave"] .btn:hover{
  background:rgba(255,113,206,.15);
  border-color:rgba(255,113,206,.4)
}
[data-theme="vaporwave"] a{color:#01CDFE}
[data-theme="vaporwave"] a:hover{color:#00FFD1}
[data-theme="vaporwave"] .member-chip{text-shadow:0 0 8px currentColor}

/* === Matrix Theme Overrides === */
/* Matrix rain background animation */
@keyframes matrix-rain-fall{
  0%{background-position:0% 0%,50% 0%,25% 0%}
  100%{background-position:0% 3000px,50% 4500px,25% 2000px}
}
@keyframes matrix-scanline{
  0%{transform:translateY(-100%)}
  100%{transform:translateY(100vh)}
}
@keyframes matrix-flicker{
  0%,95%,100%{opacity:1}
  96%{opacity:.85}
  97%{opacity:.9}
}
@keyframes matrix-glow-pulse{
  0%,100%{text-shadow:0 0 10px rgba(57,255,20,.4),0 0 20px rgba(57,255,20,.2)}
  50%{text-shadow:0 0 20px rgba(57,255,20,.6),0 0 40px rgba(57,255,20,.3),0 0 60px rgba(57,255,20,.1)}
}
@keyframes matrix-cursor-blink{
  0%,100%{opacity:1}
  50%{opacity:0}
}
[data-theme="matrix"] body{
  background-color:#0a0a0a;
  background-image:
    repeating-linear-gradient(180deg,
      transparent,transparent 2px,rgba(57,255,20,.008) 2px,rgba(57,255,20,.008) 4px),
    linear-gradient(180deg,
      transparent 0%,rgba(57,255,20,.02) 25%,transparent 30%,
      transparent 45%,rgba(57,255,20,.012) 60%,transparent 65%,
      transparent 80%,rgba(57,255,20,.015) 90%,transparent 100%),
    linear-gradient(180deg,
      rgba(57,255,20,.012) 0%,transparent 15%,
      transparent 50%,rgba(57,255,20,.008) 70%,transparent 85%),
    linear-gradient(180deg,
      transparent 10%,rgba(57,255,20,.006) 30%,transparent 50%,
      rgba(57,255,20,.012) 75%,transparent 90%);
  background-size:100% 4px,100% 800px,100% 600px,100% 1000px;
  animation:matrix-rain-fall 20s linear infinite,matrix-flicker 8s ease-in-out infinite;
  font-family:"Courier New",Courier,"Lucida Console",monospace!important;
}
/* Scanline overlay — z-index below content so lines don't penetrate cards */
[data-theme="matrix"] body::before{
  content:"";
  position:fixed;
  top:0;left:0;right:0;bottom:0;
  pointer-events:none;
  z-index:1;
  background:repeating-linear-gradient(
    0deg,
    transparent,
    transparent 1px,
    rgba(0,0,0,.04) 1px,
    rgba(0,0,0,.04) 2px
  );
}
/* Moving scanline bar — z-index below content */
[data-theme="matrix"] body::after{
  content:"";
  position:fixed;
  top:0;left:0;right:0;
  height:4px;
  pointer-events:none;
  z-index:2;
  background:linear-gradient(180deg,transparent,rgba(57,255,20,.08),transparent);
  box-shadow:0 0 20px 8px rgba(57,255,20,.03);
  animation:matrix-scanline 6s linear infinite;
}
[data-theme="matrix"] .nav{
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  background:rgba(0,10,0,.9);
  border-bottom:1px solid rgba(57,255,20,.3);
  box-shadow:0 2px 20px rgba(57,255,20,.1);
}
[data-theme="matrix"] .nav-brand{
  letter-spacing:.2em;
  text-transform:uppercase;
  animation:matrix-glow-pulse 3s ease-in-out infinite;
  font-size:1rem;
}
[data-theme="matrix"] .nav-brand::before{
  content:"> ";
  animation:matrix-cursor-blink 1s step-end infinite;
}
[data-theme="matrix"] .nav-tab{
  font-family:"Courier New",Courier,monospace;
  text-transform:uppercase;
  letter-spacing:.1em;
  font-size:.8rem;
}
[data-theme="matrix"] .nav-tab.active{
  background:rgba(57,255,20,.15);
  color:#39FF14;
  border:1px solid rgba(57,255,20,.5);
  box-shadow:0 0 15px rgba(57,255,20,.2),inset 0 0 15px rgba(57,255,20,.05);
}
[data-theme="matrix"] .board-col{
  backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);
  background:rgba(0,10,0,.6);
  border:1px solid rgba(57,255,20,.15);
  box-shadow:0 0 20px rgba(57,255,20,.05),inset 0 0 30px rgba(57,255,20,.02);
  position:relative;z-index:5;
}
[data-theme="matrix"] .board-col:hover{
  box-shadow:0 0 30px rgba(57,255,20,.12),inset 0 0 40px rgba(57,255,20,.04);
}
[data-theme="matrix"] .board-col-header{
  text-transform:uppercase;
  letter-spacing:.15em;
  font-size:.75rem;
  font-family:"Courier New",Courier,monospace;
  box-shadow:0 2px 15px rgba(0,0,0,.4);
}
[data-theme="matrix"] .card{
  backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
  background:rgba(0,15,0,.85);
  border:1px solid rgba(57,255,20,.12);
  box-shadow:0 0 8px rgba(57,255,20,.06);
  font-family:"Courier New",Courier,monospace;
  position:relative;
}
[data-theme="matrix"] .card::before{
  content:"";
  position:absolute;top:0;left:0;right:0;bottom:0;
  border-radius:inherit;
  pointer-events:none;
  box-shadow:inset 0 0 20px rgba(57,255,20,.03);
}
[data-theme="matrix"] .card:hover{
  box-shadow:0 0 20px rgba(57,255,20,.2),0 0 40px rgba(57,255,20,.05);
  border-color:rgba(57,255,20,.3);
  transform:translateY(-1px);
}
[data-theme="matrix"] .card-title{
  text-shadow:0 0 8px rgba(57,255,20,.2);
}
[data-theme="matrix"] .detail{
  background:rgba(0,10,0,.9);
  border:1px solid rgba(57,255,20,.2);
  box-shadow:0 0 30px rgba(57,255,20,.05);
}
[data-theme="matrix"] .modal{
  background:rgba(0,10,0,.95);
  border:1px solid rgba(57,255,20,.3);
  box-shadow:0 0 60px rgba(57,255,20,.15),0 0 120px rgba(57,255,20,.05);
}
[data-theme="matrix"] .settings-panel{
  background:rgba(0,10,0,.95);
  border-left:1px solid rgba(57,255,20,.2);
  box-shadow:-4px 0 30px rgba(57,255,20,.08);
}
[data-theme="matrix"] .form-control{
  background:rgba(0,10,0,.8);
  border:1px solid rgba(57,255,20,.2);
  color:#39FF14;
  font-family:"Courier New",Courier,monospace;
}
[data-theme="matrix"] .form-control:focus{
  border-color:#39FF14;
  box-shadow:0 0 0 2px rgba(57,255,20,.2),0 0 15px rgba(57,255,20,.1);
}
[data-theme="matrix"] .toast-success{
  background:rgba(0,15,0,.9);
  border:1px solid #39FF14;
  color:#39FF14;
  box-shadow:0 0 20px rgba(57,255,20,.3);
}
[data-theme="matrix"] .toast-error{
  background:rgba(20,0,0,.9);
  border:1px solid #ff2040;
  color:#ff2040;
  box-shadow:0 0 20px rgba(255,32,64,.3);
}
[data-theme="matrix"] .badge{
  font-family:"Courier New",Courier,monospace;
  text-transform:uppercase;
  letter-spacing:.05em;
}
[data-theme="matrix"] .pri-critical{
  background:#ff2040;color:#0a0a0a;
  box-shadow:0 0 10px rgba(255,32,64,.4);
  text-shadow:none;
}
[data-theme="matrix"] .pri-high{
  background:#ff6600;color:#0a0a0a;
  box-shadow:0 0 8px rgba(255,102,0,.3);
  text-shadow:none;
}
[data-theme="matrix"] .pri-medium{
  background:rgba(57,255,20,.2);color:#39FF14;
  border:1px solid rgba(57,255,20,.4);
  box-shadow:0 0 8px rgba(57,255,20,.15);
}
[data-theme="matrix"] .pri-low{
  background:rgba(57,255,20,.08);color:rgba(57,255,20,.5);
  border:1px solid rgba(57,255,20,.15);
}
[data-theme="matrix"] .btn{
  font-family:"Courier New",Courier,monospace;
  text-transform:uppercase;
  letter-spacing:.05em;
  font-size:.8rem;
}
[data-theme="matrix"] .btn-primary{
  background:rgba(57,255,20,.15);
  color:#39FF14;
  border:1px solid rgba(57,255,20,.5);
  box-shadow:0 0 10px rgba(57,255,20,.1);
}
[data-theme="matrix"] .btn-primary:hover{
  background:rgba(57,255,20,.25);
  box-shadow:0 0 20px rgba(57,255,20,.2);
}
[data-theme="matrix"] .btn-new-task{
  background:rgba(57,255,20,.15);
  color:#39FF14;
  border:1px solid rgba(57,255,20,.5);
  box-shadow:0 0 10px rgba(57,255,20,.15);
}
[data-theme="matrix"] .btn-new-task:hover{
  background:rgba(57,255,20,.25);
  box-shadow:0 0 20px rgba(57,255,20,.25);
}
[data-theme="matrix"] table{
  background:rgba(0,10,0,.6);
  border:1px solid rgba(57,255,20,.15);
}
[data-theme="matrix"] th{
  background:rgba(0,10,0,.8);
  border-bottom:2px solid rgba(57,255,20,.3);
  text-transform:uppercase;
  letter-spacing:.1em;
  font-size:.75rem;
}
[data-theme="matrix"] td{
  border-bottom:1px solid rgba(57,255,20,.06);
  font-family:"Courier New",Courier,monospace;
}
[data-theme="matrix"] tr:hover td{
  background:rgba(57,255,20,.05);
}
[data-theme="matrix"] .filters select,
[data-theme="matrix"] .filters input{
  background:rgba(0,10,0,.8);
  border:1px solid rgba(57,255,20,.2);
  color:#39FF14;
  font-family:"Courier New",Courier,monospace;
}
[data-theme="matrix"] ::-webkit-scrollbar{width:6px;height:6px}
[data-theme="matrix"] ::-webkit-scrollbar-track{background:rgba(0,10,0,.4)}
[data-theme="matrix"] ::-webkit-scrollbar-thumb{background:rgba(57,255,20,.25);border-radius:3px}
[data-theme="matrix"] ::-webkit-scrollbar-thumb:hover{background:rgba(57,255,20,.4)}
[data-theme="matrix"] ::selection{background:rgba(57,255,20,.3);color:#39FF14}
[data-theme="matrix"] .activity-list{
  background:rgba(0,10,0,.6);
  border:1px solid rgba(57,255,20,.15);
}
[data-theme="matrix"] .comment-item{
  background:rgba(0,10,0,.5);
  border:1px solid rgba(57,255,20,.1);
}

/* === Holographic Theme Overrides === */
/* Holographic rainbow gradient animation */
@keyframes holoShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@keyframes holoShimmer {
  0% { background-position: 0% 50%; }
  100% { background-position: 200% 50%; }
}
[data-theme="holographic"] body {
  background: #0a0a0f;
  background-image: radial-gradient(ellipse at 30% 70%, rgba(107,204,255,.03) 0%, transparent 50%),
                    radial-gradient(ellipse at 70% 30%, rgba(204,107,255,.03) 0%, transparent 50%);
  background-attachment: fixed;
}
[data-theme="holographic"] .nav {
  background: rgba(12,12,18,.96);
  border-bottom: 2px solid transparent;
  border-image: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff, #ff6b6b) 1;
  backdrop-filter: blur(12px);
}
[data-theme="holographic"] .nav-brand {
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff);
  background-size: 300% 300%;
  animation: holoShift 6s ease-in-out infinite;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  font-weight: 800;
}
[data-theme="holographic"] .nav-tab.active {
  background: rgba(20,20,30,.9);
  border: 1.5px solid transparent;
  background-clip: padding-box;
  position: relative;
}
[data-theme="holographic"] .nav-tab.active::before {
  content: "";
  position: absolute;
  inset: -1.5px;
  border-radius: inherit;
  padding: 1.5px;
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff);
  background-size: 300% 300%;
  animation: holoShift 4s ease-in-out infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
}
[data-theme="holographic"] .board-col {
  background: rgba(14,14,22,.85);
  border: 1.5px solid transparent;
  position: relative;
  overflow: visible;
}
[data-theme="holographic"] .board-col::before {
  content: "";
  position: absolute;
  inset: -1.5px;
  border-radius: var(--radius-md);
  padding: 1.5px;
  background: linear-gradient(135deg, #ff6b6b44, #ffd93d44, #6bff6b44, #6bccff44, #cc6bff44);
  background-size: 300% 300%;
  animation: holoShift 8s ease-in-out infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
  z-index: 0;
}
[data-theme="holographic"] .board-col-header {
  position: relative;
  z-index: 1;
  text-shadow: 0 0 8px rgba(255,255,255,.15);
}
[data-theme="holographic"] .board-col-body {
  position: relative;
  z-index: 1;
}
[data-theme="holographic"] .card {
  background: rgba(16,16,24,.92);
  border: 1.5px solid transparent;
  position: relative;
  overflow: visible;
  transition: transform .2s, box-shadow .3s, opacity .15s;
}
[data-theme="holographic"] .card::before {
  content: "";
  position: absolute;
  inset: -1.5px;
  border-radius: var(--radius-sm);
  padding: 1.5px;
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff, #ff6b6b);
  background-size: 400% 400%;
  animation: holoShimmer 5s linear infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
  opacity: 0.4;
  transition: opacity .3s;
}
[data-theme="holographic"] .card:hover::before {
  opacity: 1;
}
[data-theme="holographic"] .card:hover {
  transform: translateY(-2px);
  box-shadow: 0 0 20px rgba(107,204,255,.12), 0 0 40px rgba(204,107,255,.06);
}
[data-theme="holographic"] .detail {
  background: rgba(14,14,22,.95);
  border: 1.5px solid transparent;
  position: relative;
}
[data-theme="holographic"] .detail::before {
  content: "";
  position: absolute;
  inset: -1.5px;
  border-radius: var(--radius-md);
  padding: 1.5px;
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff);
  background-size: 300% 300%;
  animation: holoShift 6s ease-in-out infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
  z-index: -1;
}
[data-theme="holographic"] .modal {
  background: rgba(12,12,18,.97);
  border: 1.5px solid transparent;
  position: relative;
}
[data-theme="holographic"] .modal::before {
  content: "";
  position: absolute;
  inset: -1.5px;
  border-radius: var(--radius-lg);
  padding: 1.5px;
  background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff);
  background-size: 300% 300%;
  animation: holoShift 5s ease-in-out infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
  z-index: -1;
}
[data-theme="holographic"] .settings-panel {
  background: rgba(12,12,18,.97);
  border-left: 2px solid transparent;
  border-image: linear-gradient(180deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff) 1;
}
[data-theme="holographic"] .form-control:focus {
  border-color: transparent;
  box-shadow: 0 0 0 2px rgba(107,204,255,.3);
  outline: none;
  background-image: linear-gradient(rgba(14,14,22,1), rgba(14,14,22,1)), linear-gradient(135deg, #ff6b6b, #ffd93d, #6bff6b, #6bccff, #cc6bff);
  background-origin: border-box;
  background-clip: padding-box, border-box;
}
[data-theme="holographic"] .toast-success {
  background: linear-gradient(135deg, #1a3a1a, #0d2d0d);
  border: 1px solid #6bff6b;
  color: #6bff6b;
  box-shadow: 0 0 16px rgba(107,255,107,.2);
}
[data-theme="holographic"] .toast-error {
  background: linear-gradient(135deg, #3a1a1a, #2d0d0d);
  border: 1px solid #ff6b6b;
  color: #ff6b6b;
  box-shadow: 0 0 16px rgba(255,107,107,.2);
}
[data-theme="holographic"] ::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
[data-theme="holographic"] ::-webkit-scrollbar-track {
  background: rgba(10,10,15,.5);
}
[data-theme="holographic"] ::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #ff6b6b88, #ffd93d88, #6bff6b88, #6bccff88, #cc6bff88);
  border-radius: 4px;
}
[data-theme="holographic"] ::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #ff6b6bcc, #ffd93dcc, #6bff6bcc, #6bccffcc, #cc6bffcc);
}

/* Member chips for assignment */
.member-chips{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.member-chip{display:inline-flex;align-items:center;gap:3px;padding:3px 10px;border-radius:12px;font-size:.78rem;cursor:pointer;border:1px solid transparent;transition:background .15s,border-color .15s;font-weight:500;user-select:none}
.member-chip:hover{filter:brightness(.9)}
.member-chip-human{background:var(--chip-human-bg);color:var(--chip-human-text);border-color:var(--chip-human-border)}
.member-chip-human:hover{background:var(--chip-human-hover)}
.member-chip-agent{background:var(--chip-agent-bg);color:var(--chip-agent-text);border-color:var(--chip-agent-border)}
.member-chip-agent:hover{background:var(--chip-agent-hover)}
.member-chip-team{background:var(--chip-team-bg);color:var(--chip-team-text);border-color:var(--chip-team-border)}
.member-chip-team:hover{background:var(--chip-team-hover)}

/* Stats view */
.stats-view{max-width:1000px;padding:0 16px}
.stats-cards{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;margin-bottom:20px}
.stats-card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md,8px);padding:16px 20px;text-align:center}
.stats-card-value{font-size:2rem;font-weight:700;color:var(--accent-primary);line-height:1.2}
.stats-card-label{font-size:.8rem;color:var(--text-muted);margin-top:4px;text-transform:uppercase;letter-spacing:.04em}
.stats-section{margin-bottom:20px}
.stats-section h3{font-size:.95rem;font-weight:600;margin-bottom:8px;color:var(--text-primary)}
.stats-bar-row{display:flex;align-items:center;gap:8px;margin-bottom:4px}
.stats-bar-label{width:140px;font-size:.8rem;color:var(--text-secondary);text-align:right;flex-shrink:0}
.stats-bar-track{flex:1;height:18px;background:var(--surface-raised,var(--surface));border-radius:var(--radius-sm,4px);overflow:hidden}
.stats-bar-fill{height:100%;border-radius:var(--radius-sm,4px);min-width:2px;transition:width .3s}
.stats-bar-count{width:30px;font-size:.8rem;font-weight:600;color:var(--text-primary);text-align:right}
.stats-distributions{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:20px}
.stats-dist-card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md,8px);padding:12px}
.stats-dist-card h4{font-size:.85rem;font-weight:600;margin-bottom:8px;color:var(--text-primary)}
.stats-dist-table{width:100%;font-size:.8rem}
.stats-dist-table td{padding:3px 6px;border-bottom:1px solid var(--border)}
.stats-dist-count{text-align:right;font-weight:600;font-variant-numeric:tabular-nums}
.stats-wip-alerts{margin-bottom:16px}
.stats-wip-alert{background:rgba(255,180,0,0.1);border:1px solid rgba(255,180,0,0.4);border-radius:var(--radius-sm,4px);padding:8px 12px;margin-bottom:4px;font-size:.85rem;color:var(--text-primary)}
.stats-stale{border-left:3px solid rgba(255,180,0,0.6);padding-left:12px}
.stats-metrics-heading{font-size:1.05rem;font-weight:700;margin:28px 0 16px;padding-top:16px;border-top:1px solid var(--border);color:var(--text-primary)}
.velocity-chart{display:flex;align-items:flex-end;gap:4px;height:100px;padding:8px 0}
.velocity-bar-wrap{flex:1;display:flex;flex-direction:column;align-items:center;gap:2px}
.velocity-bar{width:100%;border-radius:var(--radius-sm,4px) var(--radius-sm,4px) 0 0;background:var(--accent-primary);min-height:2px;transition:height .3s}
.velocity-bar-label{font-size:.65rem;color:var(--text-muted);white-space:nowrap}
.velocity-bar-count{font-size:.7rem;font-weight:600;color:var(--text-primary)}
.blocked-cards{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:16px}
.blocked-card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md,8px);padding:12px 16px;text-align:center}
.blocked-card-value{font-size:1.5rem;font-weight:700;color:var(--text-primary);line-height:1.2}
.blocked-card-value.danger{color:var(--color-danger)}
.blocked-card-label{font-size:.75rem;color:var(--text-muted);margin-top:2px}
/* Cube (graph view) */
.cube-empty{display:flex;flex-direction:column;align-items:center;justify-content:center;height:calc(100vh - 120px);color:var(--text-muted);text-align:center;padding:40px}
.cube-fallback-icon{font-size:48px;margin-bottom:16px}
.cube-fallback-title{font-size:18px;font-weight:600;margin-bottom:8px;color:var(--text-primary)}
.cube-fallback-msg{max-width:400px;line-height:1.5;margin-bottom:16px}
.cube-fallback-retry{padding:8px 24px;background:var(--accent-primary);color:#fff;border:none;border-radius:var(--radius-md);cursor:pointer}
.cube-fallback-retry:hover{background:var(--accent-hover)}
.cube-mobile-notice{background:var(--color-warning-bg);color:var(--text-primary);padding:8px 12px;font-size:12px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border)}
/* Web (Indra's Web view) */
.web-empty{display:flex;flex-direction:column;align-items:center;justify-content:center;height:calc(100vh - 120px);color:var(--text-muted);text-align:center;padding:40px}
.web-fallback-icon{font-size:48px;margin-bottom:16px}
.web-fallback-title{font-size:18px;font-weight:600;margin-bottom:8px;color:var(--text-primary)}
.web-fallback-msg{max-width:400px;line-height:1.5;margin-bottom:16px}
.web-fallback-retry{padding:8px 24px;background:var(--accent-primary);color:#fff;border:none;border-radius:var(--radius-md);cursor:pointer}
.web-fallback-retry:hover{background:var(--accent-hover)}
.web-mobile-notice{background:var(--color-warning-bg);color:var(--text-primary);padding:8px 12px;font-size:12px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border)}
.web-orphan-badge{position:absolute;top:12px;right:12px;z-index:10;background:rgba(255,180,0,0.15);border:1px solid rgba(255,180,0,0.5);border-radius:var(--radius-md);padding:6px 12px;font-size:.75rem;color:var(--text-primary);cursor:pointer}
.web-orphan-badge:hover{background:rgba(255,180,0,0.25)}
/* Web detail pane — slides in from right */
.web-detail-pane{position:fixed;top:var(--nav-h,52px);right:0;width:420px;max-width:90vw;height:calc(100vh - var(--nav-h,52px));background:var(--surface);border-left:1px solid var(--border);box-shadow:-4px 0 24px rgba(0,0,0,0.2);z-index:100;transform:translateX(100%);transition:transform .25s ease;overflow-y:auto;padding:0}
.web-detail-pane.open{transform:translateX(0)}
.web-detail-pane .pane-header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--surface);z-index:1}
.web-detail-pane .pane-header h2{font-size:1rem;font-weight:700;margin:0;display:flex;align-items:center;gap:8px}
.web-detail-pane .pane-close{background:none;border:none;font-size:20px;cursor:pointer;color:var(--text-secondary);padding:4px 8px;border-radius:var(--radius-sm)}
.web-detail-pane .pane-close:hover{color:var(--text-primary);background:var(--surface-hover)}
.web-detail-pane .pane-body{padding:16px 20px}
.web-detail-pane .pane-status-bar{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px}
.web-detail-pane .pane-field{margin-bottom:10px}
.web-detail-pane .pane-field dt{font-weight:600;font-size:.8rem;color:var(--text-muted);margin-bottom:1px}
.web-detail-pane .pane-field dd{font-size:.85rem;color:var(--text-primary)}
.web-detail-pane .pane-section{margin-top:16px;padding-top:12px;border-top:1px solid var(--border)}
.web-detail-pane .pane-section h3{font-size:.85rem;font-weight:600;margin-bottom:6px}
.web-detail-pane .pane-event{font-size:.8rem;padding:4px 0;display:flex;gap:6px;color:var(--text-secondary)}
.web-detail-pane .pane-event .ev-type{font-weight:600;color:var(--text-primary)}
.web-detail-pane .pane-comment{background:var(--surface-raised,var(--surface));border:1px solid var(--border);border-radius:var(--radius-sm);padding:8px 10px;margin-bottom:6px;font-size:.85rem}
.web-detail-pane .pane-comment-meta{font-size:.75rem;color:var(--text-muted);margin-bottom:4px}
.web-detail-pane .pane-open-full{display:block;width:100%;padding:8px;margin-top:12px;background:var(--accent-primary);color:#fff;border:none;border-radius:var(--radius-sm);cursor:pointer;font-size:.85rem;text-align:center}
.web-detail-pane .pane-open-full:hover{background:var(--accent-hover)}
.web-detail-overlay{position:fixed;top:var(--nav-h,52px);left:0;right:0;bottom:0;z-index:99;display:none}
.web-detail-overlay.open{display:block}
/* Floating detail panel — slides in from right on Board/List card click */
.detail-panel{position:fixed;top:var(--nav-h,52px);right:0;width:480px;max-width:92vw;height:calc(100vh - var(--nav-h,52px));background:var(--surface);border-left:1px solid var(--border);box-shadow:-4px 0 24px rgba(0,0,0,0.18);z-index:100;transform:translateX(100%);transition:transform .25s ease;overflow-y:auto;padding:0}
.detail-panel.open{transform:translateX(0)}
/* detail-panel-overlay removed — board stays interactive when panel is open */
.dp-header{display:flex;align-items:center;justify-content:space-between;padding:14px 20px;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--surface);z-index:1}
.dp-header h2{font-size:1rem;font-weight:700;margin:0;display:flex;align-items:center;gap:8px;min-width:0;overflow:hidden;text-overflow:ellipsis}
.dp-header-actions{display:flex;gap:4px;flex-shrink:0}
.dp-close{background:none;border:none;font-size:28px;line-height:1;cursor:pointer;color:var(--text-secondary);padding:6px 12px;border-radius:var(--radius-sm)}
.dp-close:hover{color:var(--text-primary);background:var(--surface-hover)}
.dp-body{padding:16px 20px}
.dp-body .dp-actions{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:14px}
.dp-body .dp-actions select{font-size:.8rem;padding:3px 6px}
.dp-body .dp-field{margin-bottom:8px}
.dp-body .dp-field dt{font-weight:600;font-size:.78rem;color:var(--text-muted);margin-bottom:1px}
.dp-body .dp-field dd{font-size:.85rem;color:var(--text-primary)}
.dp-body .editable{cursor:pointer;border-bottom:1px dashed transparent;transition:border-color .15s}
.dp-body .editable:hover{border-bottom-color:var(--accent-primary)}
.dp-section{margin-top:14px;padding-top:10px;border-top:1px solid var(--border)}
.dp-section h3{font-size:.85rem;font-weight:600;margin-bottom:6px}
.dp-comment{background:var(--surface-raised,var(--surface));border:1px solid var(--border);border-radius:var(--radius-sm);padding:8px 10px;margin-bottom:6px;font-size:.85rem}
.dp-comment-meta{font-size:.75rem;color:var(--text-muted);margin-bottom:4px}
.dp-event{font-size:.8rem;padding:3px 0;display:flex;gap:6px;color:var(--text-secondary)}
.dp-event .ev-type{font-weight:600;color:var(--text-primary)}
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</head>
<body>

<div class="nav">
  <span class="nav-brand">Lattice</span>
  <div class="nav-search" id="nav-search">
    <button type="button" class="nav-search-btn" id="nav-search-btn" title="Search tasks (/)" aria-label="Search tasks" aria-expanded="false" aria-controls="nav-search-input">
      <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
      <kbd class="nav-search-kbd">/</kbd>
    </button>
    <input type="text" class="nav-search-input" id="nav-search-input" placeholder="Search tasks..." aria-label="Search tasks" tabindex="-1">
  </div>
  <span class="nav-tab" data-view="board">Board</span>
  <span class="nav-tab" data-view="list">List</span>
  <span class="nav-tab" data-view="activity">Activity</span>
  <span class="nav-tab" data-view="stats">Stats</span>
  <span class="nav-tab" data-view="cube" onclick="location.hash='#/cube'">Cube</span>
  <span class="nav-tab" data-view="web" onclick="location.hash='#/web'">Web</span>
  <div class="nav-right" style="position:relative">
    <span id="gh-auth-container" style="display:inline-flex;align-items:center;gap:4px"></span>
    <span id="stats-badges"></span>
    <button type="button" class="btn btn-new-task" id="new-task-btn" title="Create new task">+ New Task</button>
    <button type="button" class="btn btn-with-icon" id="settings-btn" title="Dashboard Settings"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/></svg> Settings</button>
    <button type="button" class="btn btn-with-icon" id="help-btn" title="User Guide"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> Help</button>
    <button type="button" class="btn btn-with-icon" id="refresh-btn" title="Refresh"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10"/><path d="M20.49 15a9 9 0 01-14.85 3.36L1 14"/></svg> Refresh</button>
  </div>
</div>

<div class="content" id="app">
  <div class="loading"><div class="spinner"></div><p>Loading...</p></div>
</div>

<div class="toast-container" id="toast-container"></div>

<!-- Web detail pane (slides from right, overlays graph) -->
<div class="web-detail-overlay" id="web-detail-overlay"></div>
<div class="web-detail-pane" id="web-detail-pane">
  <div class="pane-header">
    <h2 id="web-pane-title">Task</h2>
    <button class="pane-close" id="web-pane-close">&times;</button>
  </div>
  <div class="pane-body" id="web-pane-body">
    <div class="loading"><div class="spinner"></div></div>
  </div>
</div>

<!-- Floating detail panel (slides from right, overlays Board/List) -->
<div class="detail-panel" id="detail-panel" role="dialog" aria-label="Task detail">
  <div class="dp-header">
    <h2 id="dp-title">Task</h2>
    <div class="dp-header-actions">
      <button class="dp-close" id="dp-close">&times;</button>
    </div>
  </div>
  <div class="dp-body" id="dp-body">
    <div class="loading"><div class="spinner"></div></div>
  </div>
</div>

<div class="modal-overlay" id="create-task-modal" style="display:none">
  <div class="modal">
    <div class="modal-header">
      <h2>Create Task</h2>
      <button class="settings-close" id="create-task-close">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label for="ct-title">Title *</label>
        <input type="text" class="form-control" id="ct-title" placeholder="Task title">
      </div>
      <div class="form-group">
        <label for="ct-type">Type</label>
        <select class="form-control" id="ct-type"></select>
      </div>
      <div class="form-group">
        <label for="ct-priority">Priority</label>
        <select class="form-control" id="ct-priority">
          <option value="critical">critical</option>
          <option value="high">high</option>
          <option value="medium" selected>medium</option>
          <option value="low">low</option>
        </select>
      </div>
      <div class="form-group">
        <label for="ct-description">Description</label>
        <textarea class="form-control" id="ct-description" placeholder="Optional description"></textarea>
      </div>
      <div class="form-group">
        <label for="ct-tags">Tags</label>
        <input type="text" class="form-control" id="ct-tags" placeholder="Comma-separated tags">
      </div>
      <div class="form-group">
        <label for="ct-assigned">Assigned To</label>
        <input type="text" class="form-control" id="ct-assigned" placeholder="e.g. human:atin, agent:claude">
        <div id="ct-assigned-chips" class="member-chips"></div>
      </div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn" id="create-task-cancel">Cancel</button>
      <button type="button" class="btn btn-primary" id="create-task-submit">Create Task</button>
    </div>
  </div>
</div>

<div class="settings-panel" id="settings-panel">
  <div class="settings-header">
    <span>Dashboard Settings</span>
    <button class="settings-close" id="settings-close">&times;</button>
  </div>
  <div class="settings-body">
    <div class="settings-group">
      <label for="theme-select">Theme</label>
      <select class="form-control" id="theme-select"></select>
      <div class="hint">Choose a visual theme for the dashboard.</div>
    </div>
    <div class="settings-group">
      <label for="col-width-slider">Column Width <span id="col-width-value" style="font-weight:400;color:var(--text-muted)">300px</span></label>
      <input type="range" id="col-width-slider" min="150" max="800" step="10" value="300" style="width:100%;cursor:pointer">
      <div class="hint">Adjust the width of board columns.</div>
    </div>
    <div class="settings-group">
      <label for="font-size-slider">Font Size <span id="font-size-value" style="font-weight:400;color:var(--text-muted)">14px</span></label>
      <input type="range" id="font-size-slider" min="6" max="100" step="1" value="14" style="width:100%;cursor:pointer">
      <div class="hint">Adjust the font size of board cards.</div>
    </div>
    <div class="settings-group">
      <label for="voice-select">Voice</label>
      <select class="form-control" id="voice-select"></select>
      <div class="hint">Choose how the dashboard speaks to you.</div>
    </div>
    <div class="settings-group">
      <label for="bg-image-input">Background Image URL</label>
      <input type="text" id="bg-image-input" placeholder="https://example.com/bg.jpg">
      <div class="hint">Set a background image for the board view. Leave empty to clear.</div>
      <button type="button" class="btn" id="bg-image-save">Apply</button>
      <button type="button" class="btn" id="bg-image-clear">Clear</button>
    </div>
    <div class="settings-group">
      <label>Lane Colors</label>
      <div class="hint" style="margin-bottom:8px">Click a color to customize each swim lane header.</div>
      <div id="lane-colors-list"></div>
      <button type="button" class="btn" id="lane-colors-save" style="margin-top:8px">Apply Lane Colors</button>
      <button type="button" class="btn" id="lane-colors-reset" style="margin-top:4px">Reset to Defaults</button>
    </div>
    <div class="settings-group">
      <div style="display:flex;align-items:center;gap:8px">
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;flex:1">
          <input type="checkbox" id="heat-map-toggle">
          Heat Map
        </label>
        <button type="button" id="heat-map-info-btn" title="What is Heat Map?" style="background:none;border:1px solid var(--border-subtle);border-radius:var(--radius-sm);cursor:pointer;padding:2px 6px;color:var(--text-muted);font-size:.8rem;display:flex;align-items:center;gap:4px;white-space:nowrap">
          &#x1F441; Info
        </button>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-binarytree@1"></script>
<script src="https://unpkg.com/d3-octree@1"></script>
<script src="https://unpkg.com/d3-force-3d@3"></script>
<script src="https://unpkg.com/force-graph@1/dist/force-graph.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<link rel="stylesheet" href="static/cube3d.css">
<script src="static/cube3d.js" defer></script>
<script>
(function(){
"use strict";

// --- Default lane colors per theme ---
var LANE_COLORS_BY_THEME = {
  "linear": {
  backlog: "#B0B3C4",
  in_planning: "#59A2E0",
  planned: "#4CB782",
  in_progress: "#5E6AD2",
  in_implementation: "#5E6AD2",
  implemented: "#37B5E6",
  review: "#9B6DD7",
  in_review: "#9B6DD7",
  blocked: "#EB5757",
  needs_human: "#F2994A",
  done: "#3BA672",
  cancelled: "#8B8FA3"
},
  "carbon": {
  backlog: "#404040", in_planning: "#0E7490", planned: "#0F766E", in_progress: "#2563EB",
  in_implementation: "#2563EB", implemented: "#0284C7", review: "#7C3AED", in_review: "#7C3AED",
  blocked: "#DC2626", needs_human: "#D97706", done: "#16A34A", cancelled: "#525252"
},
  "vaporwave": {
  backlog: "#4a2870", in_planning: "#B967FF", planned: "#01CDFE", in_progress: "#FF71CE",
  in_implementation: "#FF71CE", implemented: "#00FFD1", review: "#c471ed", in_review: "#c471ed",
  blocked: "#FF4081", needs_human: "#FFD740", done: "#05ffd2", cancelled: "#3d2060"
},
  "matrix": {
  backlog: "#1a3a1a", in_planning: "#0f4f0f", planned: "#1a6b1a", in_progress: "#228B22",
  in_implementation: "#228B22", implemented: "#2eb82e", review: "#39FF14", in_review: "#39FF14",
  blocked: "#FF3333", needs_human: "#CCCC00", done: "#00cc44", cancelled: "#333333"
},
  "holographic": {
  backlog: "#2a2a3a",
  in_planning: "#6b8bff",
  planned: "#6bccff",
  in_progress: "#6bff6b",
  in_implementation: "#6bff6b",
  implemented: "#ffd93d",
  review: "#cc6bff",
  in_review: "#cc6bff",
  blocked: "#ff6b6b",
  needs_human: "#ffb86b",
  done: "#50e890",
  cancelled: "#3a2a2a"
}
};
var DEFAULT_LANE_COLORS = LANE_COLORS_BY_THEME.carbon;

// --- Themes ---
var THEMES = [
  {id: "carbon", name: "Carbon", desc: "Industrial dark engineering dashboard"},
  {id: "holographic", name: "Holographic", desc: "Iridescent rainbow-edge trading card aesthetic"},
  {id: "linear", name: "Linear", desc: "Tight, modern product UI"},
  {id: "matrix", name: "Matrix", desc: "Full hacker terminal: matrix rain, scanlines, green-on-black everything"},
  {id: "vaporwave", name: "Vaporwave", desc: "Pink-purple retro-future dreamscape"}
];

// --- Voice Packs (i18n) ---
var VOICES = {
  "en-oracle": {
    _meta: { label: "Oracle (English)", lang: "en" },
    "nav.brand": "Lattice",
    "nav.board": "Board",
    "nav.list": "List",
    "nav.activity": "Activity",
    "btn.new_task": "+ New Task",
    "btn.refresh": "Refresh",
    "btn.help": "Help",
    "btn.help_title": "User Guide",
    "btn.settings": "Dashboard Settings",
    "btn.create_task": "Create Task",
    "btn.cancel": "Cancel",
    "btn.save": "Save",
    "btn.apply": "Apply",
    "btn.clear": "Clear",
    "btn.apply_lane_colors": "Apply Lane Colors",
    "btn.reset_defaults": "Reset to Defaults",
    "btn.post": "Post",
    "btn.archive": "Archive",
    "btn.retry": "Retry",
    "btn.back": "&larr; Back",
    "loading": "Gathering state...",
    "empty.board": "The board is clear \u2014 a workspace awaits its first intention.",
    "empty.board.cta": "Get Started",
    "empty.list": "No tasks have been set into motion.",
    "empty.list.filtered": "No tasks match the current lens.",
    "empty.activity": "No echoes yet \u2014 all is still.",
    "empty.lane": "Awaiting",
    "toast.task_created": "Intention declared: {title}",
    "toast.status_changed": "State shifted to {status}",
    "toast.priority_changed": "Weight adjusted to {value}",
    "toast.type_changed": "Form reshaped to {value}",
    "toast.title_updated": "Name rewritten",
    "toast.description_updated": "Details refined",
    "toast.assigned": "Entrusted to {value}",
    "toast.unassigned": "Released from assignment",
    "toast.tags_updated": "Markers set",
    "toast.comment_added": "Trace left",
    "toast.task_archived": "Committed to the archive",
    "toast.theme_updated": "Appearance shifted",
    "toast.bg_updated": "Background altered",
    "toast.bg_cleared": "Background released",
    "toast.lane_colors_updated": "Lane palette applied",
    "toast.notes_opened": "Notes unveiled",
    "toast.plans_opened": "Plan unveiled",
    "toast.lane_colors_reset": "Lane palette restored",
    "toast.voice_updated": "Voice changed",
    "toast.moved_to": "Transitioned to {status}",
    "toast.invalid_transition": "That path is not permitted: {from} to {to}",
    "error.title_required": "A task requires a name \u2014 even the smallest intention must be declared.",
    "error.title_empty": "A name cannot be emptied \u2014 identity persists.",
    "error.comment_empty": "An empty trace carries no meaning.",
    "modal.create_title": "New Intention",
    "label.title": "Title *",
    "label.type": "Type",
    "label.priority": "Priority",
    "label.description": "Description",
    "label.tags": "Tags",
    "label.assigned_to": "Assigned To",
    "placeholder.title": "Name this intention...",
    "placeholder.description": "What shape does this take?...",
    "placeholder.tags": "Comma-separated markers",
    "placeholder.assigned": "e.g. human:atin, agent:claude",
    "placeholder.comment": "Leave a trace for the next mind...",
    "settings.title": "Dashboard Settings",
    "settings.theme_label": "Theme",
    "settings.theme_hint": "Choose a visual theme for the dashboard.",
    "settings.voice_label": "Voice",
    "settings.voice_hint": "Choose how the dashboard speaks to you.",
    "settings.bg_label": "Background Image URL",
    "settings.bg_hint": "Set a background image for the board view. Leave empty to clear.",
    "settings.lane_label": "Lane Colors",
    "settings.lane_hint": "Click a color to customize each swim lane header.",
    "detail.short_id": "Short ID",
    "detail.tech_id": "Technical ID",
    "detail.assigned_to": "Assigned to",
    "detail.created_by": "Created by",
    "detail.created": "Created",
    "detail.updated": "Updated",
    "detail.urgency": "Urgency",
    "detail.unassigned": "unassigned",
    "detail.no_description": "(no description \u2014 click to add)",
    "detail.no_tags": "(no tags \u2014 click to add)",
    "detail.notes_exists": "Notes file: ",
    "detail.plans_exists": "Plan file: ",
    "btn.show_plan": "Show Plan",
    "btn.show_notes": "Show Notes",
    "section.description": "Description",
    "section.tags": "Tags",
    "section.custom_fields": "Custom Fields",
    "section.relationships": "Relationships",
    "section.artifacts": "Artifacts",
    "section.plans": "Plan",
    "section.notes": "Notes",
    "section.comments": "Comments",
    "section.history": "History",
    "filter.search": "Search title...",
    "filter.all_statuses": "All statuses",
    "filter.all_types": "All types",
    "filter.all_priorities": "All priorities",
    "filter.show_archived": "Show archived",
    "table.id": "ID",
    "table.title": "Title",
    "table.status": "Status",
    "table.priority": "Priority",
    "table.type": "Type",
    "table.assigned": "Assigned",
    "table.updated": "Updated",
    "stats.tasks": "tasks",
    "nav.stats": "Stats",
    "stats.active_tasks": "Active Tasks",
    "stats.archived_tasks": "Archived",
    "stats.total_events": "Total Events",
    "stats.active_events": "Active Events",
    "stats.wip_exceeded": "WIP Limit Exceeded",
    "stats.by_status": "Status Distribution",
    "stats.by_priority": "By Priority",
    "stats.by_type": "By Type",
    "stats.by_assignee": "By Assignee",
    "stats.by_tag": "By Tag",
    "stats.recently_active": "Recently Active",
    "stats.stale_tasks": "Stale Tasks",
    "stats.busiest_tasks": "Most Active",
    "empty.stats": "No statistics yet.",
    "activity.showing": "Showing {from}\u2013{to} of {total}",
    "activity.load_more": "Load More",
    "activity.no_results": "No events match the current filters.",
    "activity.all_types": "All types",
    "activity.all_actors": "All actors",
    "activity.all_tasks": "All tasks",
    "activity.all_time": "All time",
    "activity.today": "Today",
    "activity.this_week": "This week",
    "activity.this_month": "This month",
    "activity.search": "Search events...",
    "activity.date_today": "Today",
    "activity.date_yesterday": "Yesterday",
    "activity.expand": "Show details",
    "activity.collapse": "Hide details",
    "activity.custom": "Custom range",
    "activity.from": "From",
    "activity.to": "To",
    "activity.view_task": "View Task",
    "activity.view_on_board": "View on Board",
    "activity.view_on_web": "View on Web",
    "activity.pick_task": "Pick a task\u2026",
    "activity.search_tasks": "Search by ID or title\u2026"
  },
  "en-clinical": {
    _meta: { label: "Clinical (English)", lang: "en" },
    "nav.brand": "Lattice",
    "nav.board": "Board",
    "nav.list": "List",
    "nav.activity": "Activity",
    "btn.new_task": "+ New Task",
    "btn.refresh": "Refresh",
    "btn.help": "Help",
    "btn.help_title": "User Guide",
    "btn.settings": "Dashboard Settings",
    "btn.create_task": "Create Task",
    "btn.cancel": "Cancel",
    "btn.save": "Save",
    "btn.apply": "Apply",
    "btn.clear": "Clear",
    "btn.apply_lane_colors": "Apply Lane Colors",
    "btn.reset_defaults": "Reset to Defaults",
    "btn.post": "Post",
    "btn.archive": "Archive",
    "btn.retry": "Retry",
    "btn.back": "&larr; Back",
    "loading": "Loading...",
    "empty.board": "No tasks yet.",
    "empty.board.cta": "+ Create your first task",
    "empty.list": "No tasks yet.",
    "empty.list.filtered": "No tasks match your filters.",
    "empty.activity": "No recent activity.",
    "empty.lane": "No tasks",
    "toast.task_created": "Task created: {title}",
    "toast.status_changed": "Status changed to {status}",
    "toast.priority_changed": "Priority changed to {value}",
    "toast.type_changed": "Type changed to {value}",
    "toast.title_updated": "Title updated",
    "toast.description_updated": "Description updated",
    "toast.assigned": "Assigned to {value}",
    "toast.unassigned": "Unassigned",
    "toast.tags_updated": "Tags updated",
    "toast.comment_added": "Comment added",
    "toast.task_archived": "Task archived",
    "toast.theme_updated": "Theme updated",
    "toast.bg_updated": "Background image updated",
    "toast.bg_cleared": "Background image cleared",
    "toast.lane_colors_updated": "Lane colors updated",
    "toast.notes_opened": "Notes opened",
    "toast.plans_opened": "Plan opened",
    "toast.lane_colors_reset": "Lane colors reset to defaults",
    "toast.voice_updated": "Voice updated",
    "toast.moved_to": "Moved to {status}",
    "toast.invalid_transition": "Invalid transition: {from} to {to}",
    "error.title_required": "Title is required",
    "error.title_empty": "Title cannot be empty",
    "error.comment_empty": "Comment cannot be empty",
    "modal.create_title": "Create Task",
    "label.title": "Title *",
    "label.type": "Type",
    "label.priority": "Priority",
    "label.description": "Description",
    "label.tags": "Tags",
    "label.assigned_to": "Assigned To",
    "placeholder.title": "Task title",
    "placeholder.description": "Optional description",
    "placeholder.tags": "Comma-separated tags",
    "placeholder.assigned": "e.g. human:atin, agent:claude",
    "placeholder.comment": "Add a comment...",
    "settings.title": "Dashboard Settings",
    "settings.theme_label": "Theme",
    "settings.theme_hint": "Choose a visual theme for the dashboard.",
    "settings.voice_label": "Voice",
    "settings.voice_hint": "Choose how the dashboard speaks to you.",
    "settings.bg_label": "Background Image URL",
    "settings.bg_hint": "Set a background image for the board view. Leave empty to clear.",
    "settings.lane_label": "Lane Colors",
    "settings.lane_hint": "Click a color to customize each swim lane header.",
    "detail.short_id": "Short ID",
    "detail.tech_id": "Technical ID",
    "detail.assigned_to": "Assigned to",
    "detail.created_by": "Created by",
    "detail.created": "Created",
    "detail.updated": "Updated",
    "detail.urgency": "Urgency",
    "detail.unassigned": "unassigned",
    "detail.no_description": "(no description \u2014 click to add)",
    "detail.no_tags": "(no tags \u2014 click to add)",
    "detail.notes_exists": "Notes file: ",
    "detail.plans_exists": "Plan file: ",
    "btn.show_plan": "Show Plan",
    "btn.show_notes": "Show Notes",
    "section.description": "Description",
    "section.tags": "Tags",
    "section.custom_fields": "Custom Fields",
    "section.relationships": "Relationships",
    "section.artifacts": "Artifacts",
    "section.plans": "Plan",
    "section.notes": "Notes",
    "section.comments": "Comments",
    "section.history": "History",
    "filter.search": "Search title...",
    "filter.all_statuses": "All statuses",
    "filter.all_types": "All types",
    "filter.all_priorities": "All priorities",
    "filter.show_archived": "Show archived",
    "table.id": "ID",
    "table.title": "Title",
    "table.status": "Status",
    "table.priority": "Priority",
    "table.type": "Type",
    "table.assigned": "Assigned",
    "table.updated": "Updated",
    "stats.tasks": "tasks",
    "nav.stats": "Stats",
    "stats.active_tasks": "Active",
    "stats.archived_tasks": "Archived",
    "stats.total_events": "Events",
    "stats.active_events": "Active Events",
    "stats.wip_exceeded": "WIP Exceeded",
    "stats.by_status": "Status",
    "stats.by_priority": "Priority",
    "stats.by_type": "Type",
    "stats.by_assignee": "Assignee",
    "stats.by_tag": "Tags",
    "stats.recently_active": "Recent",
    "stats.stale_tasks": "Stale",
    "stats.busiest_tasks": "Busiest",
    "empty.stats": "No data.",
    "activity.showing": "Showing {from}\u2013{to} of {total}",
    "activity.load_more": "Load More",
    "activity.no_results": "No matching events.",
    "activity.all_types": "All types",
    "activity.all_actors": "All actors",
    "activity.all_tasks": "All tasks",
    "activity.all_time": "All time",
    "activity.today": "Today",
    "activity.this_week": "This week",
    "activity.this_month": "This month",
    "activity.search": "Search events...",
    "activity.date_today": "Today",
    "activity.date_yesterday": "Yesterday",
    "activity.expand": "Show details",
    "activity.collapse": "Hide details",
    "activity.custom": "Custom range",
    "activity.from": "From",
    "activity.to": "To",
    "activity.view_task": "View Task",
    "activity.view_on_board": "View on Board",
    "activity.view_on_web": "View on Web",
    "activity.pick_task": "Pick a task\u2026",
    "activity.search_tasks": "Search by ID or title\u2026"
  },
  "es-oracle": {
    _meta: { label: "Or\u00e1culo (Espa\u00f1ol)", lang: "es" },
    "nav.board": "Tablero",
    "nav.list": "Lista",
    "nav.activity": "Actividad",
    "btn.new_task": "+ Nueva Tarea",
    "btn.create_task": "Crear Tarea",
    "btn.cancel": "Cancelar",
    "btn.save": "Guardar",
    "btn.apply": "Aplicar",
    "btn.clear": "Limpiar",
    "btn.apply_lane_colors": "Aplicar Colores",
    "btn.reset_defaults": "Restablecer",
    "btn.post": "Publicar",
    "btn.archive": "Archivar",
    "btn.retry": "Reintentar",
    "btn.back": "&larr; Volver",
    "btn.refresh": "Actualizar",
    "btn.help": "Ayuda",
    "btn.help_title": "Gu\u00eda del Usuario",
    "loading": "Reuniendo estado...",
    "empty.board": "El tablero est\u00e1 limpio \u2014 un espacio aguarda su primera intenci\u00f3n.",
    "empty.board.cta": "Comenzar",
    "empty.list": "Ninguna tarea ha sido puesta en movimiento.",
    "empty.list.filtered": "Ninguna tarea coincide con el filtro actual.",
    "empty.activity": "Sin ecos a\u00fan \u2014 todo est\u00e1 en calma.",
    "empty.lane": "Esperando",
    "toast.task_created": "Intenci\u00f3n declarada: {title}",
    "toast.status_changed": "Estado cambiado a {status}",
    "toast.priority_changed": "Prioridad ajustada a {value}",
    "toast.type_changed": "Tipo cambiado a {value}",
    "toast.title_updated": "Nombre actualizado",
    "toast.description_updated": "Descripci\u00f3n actualizada",
    "toast.assigned": "Asignado a {value}",
    "toast.unassigned": "Sin asignar",
    "toast.tags_updated": "Etiquetas actualizadas",
    "toast.comment_added": "Rastro dejado",
    "toast.task_archived": "Tarea archivada",
    "toast.theme_updated": "Apariencia cambiada",
    "toast.bg_updated": "Fondo actualizado",
    "toast.bg_cleared": "Fondo liberado",
    "toast.lane_colors_updated": "Colores de carril aplicados",
    "toast.notes_opened": "Notas abiertas",
    "toast.plans_opened": "Plan abierto",
    "toast.lane_colors_reset": "Colores de carril restablecidos",
    "toast.voice_updated": "Voz cambiada",
    "toast.moved_to": "Transici\u00f3n a {status}",
    "toast.invalid_transition": "Esa transici\u00f3n no est\u00e1 permitida: {from} a {to}",
    "error.title_required": "Una tarea requiere un nombre \u2014 toda intenci\u00f3n debe ser declarada.",
    "error.title_empty": "El nombre no puede quedar vac\u00edo \u2014 la identidad persiste.",
    "error.comment_empty": "Un rastro vac\u00edo no tiene significado.",
    "modal.create_title": "Nueva Intenci\u00f3n",
    "label.title": "T\u00edtulo *",
    "label.type": "Tipo",
    "label.priority": "Prioridad",
    "label.description": "Descripci\u00f3n",
    "label.tags": "Etiquetas",
    "label.assigned_to": "Asignado a",
    "placeholder.title": "Nombra esta intenci\u00f3n...",
    "placeholder.description": "\u00bfQu\u00e9 forma toma esto?...",
    "placeholder.tags": "Marcadores separados por coma",
    "placeholder.comment": "Deja un rastro para la pr\u00f3xima mente...",
    "settings.title": "Configuraci\u00f3n del Panel",
    "settings.theme_label": "Tema",
    "settings.theme_hint": "Elige un tema visual para el panel.",
    "settings.voice_label": "Voz",
    "settings.voice_hint": "Elige c\u00f3mo te habla el panel.",
    "settings.bg_label": "URL de Imagen de Fondo",
    "settings.bg_hint": "Establece una imagen de fondo. Deja vac\u00edo para limpiar.",
    "settings.lane_label": "Colores de Carril",
    "settings.lane_hint": "Haz clic en un color para personalizar cada carril.",
    "detail.short_id": "ID Corto",
    "detail.tech_id": "ID T\u00e9cnico",
    "detail.assigned_to": "Asignado a",
    "detail.created_by": "Creado por",
    "detail.created": "Creado",
    "detail.updated": "Actualizado",
    "detail.urgency": "Urgencia",
    "detail.unassigned": "sin asignar",
    "detail.no_description": "(sin descripci\u00f3n \u2014 clic para a\u00f1adir)",
    "detail.no_tags": "(sin etiquetas \u2014 clic para a\u00f1adir)",
    "detail.notes_exists": "Archivo de notas: ",
    "detail.plans_exists": "Archivo del plan: ",
    "btn.show_plan": "Ver Plan",
    "btn.show_notes": "Ver Notas",
    "section.description": "Descripci\u00f3n",
    "section.tags": "Etiquetas",
    "section.custom_fields": "Campos Personalizados",
    "section.relationships": "Relaciones",
    "section.artifacts": "Artefactos",
    "section.plans": "Plan",
    "section.notes": "Notas",
    "section.comments": "Comentarios",
    "section.history": "Historial",
    "filter.search": "Buscar t\u00edtulo...",
    "filter.all_statuses": "Todos los estados",
    "filter.all_types": "Todos los tipos",
    "filter.all_priorities": "Todas las prioridades",
    "filter.show_archived": "Mostrar archivados",
    "table.id": "ID",
    "table.title": "T\u00edtulo",
    "table.status": "Estado",
    "table.priority": "Prioridad",
    "table.type": "Tipo",
    "table.assigned": "Asignado",
    "table.updated": "Actualizado",
    "stats.tasks": "tareas",
    "nav.stats": "Estad\u00edsticas",
    "stats.active_tasks": "Tareas Activas",
    "stats.archived_tasks": "Archivadas",
    "stats.total_events": "Eventos Totales",
    "stats.active_events": "Eventos Activos",
    "stats.wip_exceeded": "L\u00edmite WIP Excedido",
    "stats.by_status": "Distribuci\u00f3n por Estado",
    "stats.by_priority": "Por Prioridad",
    "stats.by_type": "Por Tipo",
    "stats.by_assignee": "Por Asignado",
    "stats.by_tag": "Por Etiqueta",
    "stats.recently_active": "Activos Recientemente",
    "stats.stale_tasks": "Tareas Estancadas",
    "stats.busiest_tasks": "M\u00e1s Activas",
    "empty.stats": "Sin estad\u00edsticas a\u00fan.",
    "activity.showing": "Mostrando {from}\u2013{to} de {total}",
    "activity.load_more": "Cargar m\u00e1s",
    "activity.no_results": "Ning\u00fan evento coincide con los filtros.",
    "activity.all_types": "Todos los tipos",
    "activity.all_actors": "Todos los actores",
    "activity.all_tasks": "Todas las tareas",
    "activity.all_time": "Todo el tiempo",
    "activity.today": "Hoy",
    "activity.this_week": "Esta semana",
    "activity.this_month": "Este mes",
    "activity.search": "Buscar eventos...",
    "activity.date_today": "Hoy",
    "activity.date_yesterday": "Ayer",
    "activity.expand": "Mostrar detalles",
    "activity.collapse": "Ocultar detalles",
    "activity.custom": "Rango personalizado",
    "activity.from": "Desde",
    "activity.to": "Hasta",
    "activity.view_task": "Ver Tarea",
    "activity.view_on_board": "Ver en Tablero",
    "activity.view_on_web": "Ver en Web",
    "activity.pick_task": "Elegir tarea\u2026",
    "activity.search_tasks": "Buscar por ID o t\u00edtulo\u2026"
  }
};

var currentVoice = "en-oracle";

function t(key) {
  return (VOICES[currentVoice] && VOICES[currentVoice][key]) ||
         (VOICES["en-oracle"] && VOICES["en-oracle"][key]) ||
         key;
}

function tf(key, replacements) {
  var str = t(key);
  if (replacements) {
    Object.keys(replacements).forEach(function(k) {
      str = str.replace("{" + k + "}", replacements[k]);
    });
  }
  return str;
}

// --- State ---
var config = null;
var tasks = [];
var archivedTasks = null;
var currentView = "board";
var pendingSearch = null;
var draggedTaskId = null;
var draggedFromStatus = null;
var boardGraphLinks = [];

// --- Cube (3D view) state ---
// Cube 3D state is managed internally by cube3d.js
// These thin wrappers delegate to the external module's globals:
// renderCube3D(), updateCube3DData(), cleanupCube3D()
var cubeRenderGeneration = 0;  // kept for auto-refresh compatibility
var cubeCurrentRevision = null;

// --- Status display names ---
function getStatusDisplayName(slug) {
  if (!slug) return "";
  var dn = config && config.workflow && config.workflow.display_names;
  if (dn && dn[slug]) return dn[slug];
  return slug.replace(/_/g, " ");
}

// --- Status descriptions (operational contract for each status) ---
function getStatusDescription(slug) {
  if (!slug) return "";
  var desc = config && config.workflow && config.workflow.descriptions;
  if (desc && desc[slug]) return desc[slug];
  return "";
}

// --- Web (Indra's Web view) state ---
var webGraph = null;
var webResizeHandler = null;
var webData = null;
var webRenderGeneration = 0;
var webCurrentRevision = null;

// Web constants
var WEB_TIER_RADIUS = { hub: 20, task: 6 };
var WEB_ACTIVITY_WINDOW_MS = 10 * 60 * 1000; // 10 minutes
var WEB_ACTIVITY_COLORS = { git: "#ffc107", lattice: "#fd7e14", both: "#f0a500" };
var WEB_SPOKE_COLOR = "rgba(100,130,180,0.35)";
var WEB_LINK_COLORS = {
  subtask_of: "rgba(100,130,180,0.35)",
  blocks: "rgba(220,60,60,0.7)",
  depends_on: "rgba(60,140,220,0.7)",
  related_to: "rgba(150,150,150,0.4)",
  spawned_by: "rgba(80,180,100,0.6)",
  duplicate_of: "rgba(180,120,60,0.5)",
  supersedes: "rgba(160,80,180,0.6)"
};
var WEB_LINK_DISTANCE = { "hub-task": 100, "task-task": 60, "cross-cutting": 120 };
var WEB_CHARGE = { hub: -400, task: -50 };
var WEB_COLLISION_RADIUS = { hub: 30, task: 10 };

// --- GitHub Pages Mode ---
var ghMode = {
  enabled: false,
  token: null,
  user: null,
  org: "",
  projectNumber: 0,
  repo: "",
  oauthClientId: "",
  oauthProxyUrl: "",
  projectFieldCache: null,  // cached project field metadata

  init: function() {
    // Detect GitHub Pages hosting
    if (location.hostname.endsWith("github.io") || location.search.includes("gh_mode=1")) {
      this.enabled = true;
      this.token = localStorage.getItem("gh_token");
      this.user = localStorage.getItem("gh_user");
      // Handle OAuth callback
      var params = new URLSearchParams(location.search);
      var code = params.get("code");
      if (code && !this.token) {
        this._exchangeOAuthCode(code);
        return;
      }
      this._updateAuthUI();
    }
  },

  _exchangeOAuthCode: async function(code) {
    try {
      var configResp = await fetch("data/config.json");
      var configData = await configResp.json();
      var gh = configData.github || {};
      this.oauthProxyUrl = gh.oauth_proxy_url || "";
      if (!this.oauthProxyUrl) {
        showToast("OAuth proxy URL not configured", "error");
        return;
      }
      var r = await fetch(this.oauthProxyUrl, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({code: code})
      });
      var data = await r.json();
      if (data.access_token) {
        localStorage.setItem("gh_token", data.access_token);
        this.token = data.access_token;
        // Fetch user info
        var userR = await fetch("https://api.github.com/user", {
          headers: {"Authorization": "Bearer " + data.access_token}
        });
        var userData = await userR.json();
        if (userData.login) {
          localStorage.setItem("gh_user", userData.login);
          this.user = userData.login;
        }
        // Clean URL and reload
        window.history.replaceState({}, "", location.pathname + location.hash);
        location.reload();
      } else {
        showToast("OAuth failed: " + (data.error || "unknown error"), "error");
      }
    } catch(e) {
      showToast("OAuth exchange failed: " + e.message, "error");
    }
  },

  _updateAuthUI: function() {
    var container = document.getElementById("gh-auth-container");
    if (!container) return;
    if (this.token && this.user) {
      container.innerHTML = '<span style="color:var(--text-secondary);font-size:.8rem;margin-right:8px">' + this.user + '</span>' +
        '<button type="button" class="btn" onclick="ghMode.signOut()" style="font-size:.75rem;padding:2px 8px">Sign Out</button>';
    } else {
      container.innerHTML = '<button type="button" class="btn btn-with-icon" onclick="ghMode.signIn()" style="font-size:.75rem;padding:3px 10px">' +
        '<svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>' +
        ' Sign in with GitHub</button>';
    }
  },

  signIn: function() {
    if (!this.oauthClientId) {
      // Try manual token entry fallback
      var token = prompt("Enter a GitHub Personal Access Token with 'repo' and 'project' scopes.\n\nOr configure OAuth: set oauth_client_id in data/config.json.");
      if (token) {
        localStorage.setItem("gh_token", token);
        this.token = token;
        // Fetch user
        fetch("https://api.github.com/user", {headers: {"Authorization": "Bearer " + token}})
          .then(function(r) { return r.json(); })
          .then(function(u) {
            if (u.login) {
              localStorage.setItem("gh_user", u.login);
              ghMode.user = u.login;
            }
            location.reload();
          });
      }
      return;
    }
    var redirectUri = location.origin + location.pathname;
    window.location.href = "https://github.com/login/oauth/authorize?client_id=" +
      encodeURIComponent(this.oauthClientId) +
      "&redirect_uri=" + encodeURIComponent(redirectUri) +
      "&scope=repo,project";
  },

  signOut: function() {
    localStorage.removeItem("gh_token");
    localStorage.removeItem("gh_user");
    this.token = null;
    this.user = null;
    location.reload();
  },

  graphql: async function(query, variables) {
    var r = await fetch("https://api.github.com/graphql", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + this.token,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({query: query, variables: variables || {}})
    });
    var body = await r.json();
    if (body.errors) throw new Error(body.errors[0].message);
    return body.data;
  },

  restApi: async function(path, opts) {
    opts = opts || {};
    opts.headers = opts.headers || {};
    opts.headers["Authorization"] = "Bearer " + this.token;
    opts.headers["Accept"] = "application/vnd.github+json";
    if (opts.body && typeof opts.body === "object") {
      opts.headers["Content-Type"] = "application/json";
      opts.body = JSON.stringify(opts.body);
    }
    var r = await fetch("https://api.github.com" + path, opts);
    if (!r.ok) {
      var errBody = await r.json().catch(function() { return {}; });
      throw new Error(errBody.message || "GitHub API error " + r.status);
    }
    return r.json();
  },

  fetchProjectItems: async function() {
    var query = 'query($org: String!, $num: Int!, $cursor: String) { organization(login: $org) { projectV2(number: $num) { id title items(first: 100, after: $cursor) { pageInfo { hasNextPage endCursor } nodes { id fieldValues(first: 20) { nodes { ... on ProjectV2ItemFieldTextValue { text field { ... on ProjectV2Field { name } } } ... on ProjectV2ItemFieldSingleSelectValue { name optionId field { ... on ProjectV2SingleSelectField { name } } } ... on ProjectV2ItemFieldIterationValue { title field { ... on ProjectV2IterationField { name } } } ... on ProjectV2ItemFieldDateValue { date field { ... on ProjectV2Field { name } } } } } content { ... on Issue { number title url body state labels(first:10) { nodes { name } } assignees(first:5) { nodes { login } } createdAt updatedAt comments { totalCount } } ... on PullRequest { number title url body state createdAt updatedAt } } } } fields(first: 30) { nodes { ... on ProjectV2SingleSelectField { id name options { id name } } ... on ProjectV2Field { id name } } } } } }';
    // Also try user-level if org fails
    var userQuery = query.replace("organization(login: $org)", "user(login: $org)");

    var allItems = [];
    var cursor = null;
    var projectId = null;
    var fields = null;
    var useUser = false;

    while (true) {
      try {
        var data = await this.graphql(useUser ? userQuery : query, {org: this.org, num: this.projectNumber, cursor: cursor});
        var owner = data.organization || data.user;
        var project = owner.projectV2;
        projectId = project.id;
        fields = project.fields.nodes;
        var items = project.items;
        allItems = allItems.concat(items.nodes);
        if (items.pageInfo.hasNextPage) {
          cursor = items.pageInfo.endCursor;
        } else {
          break;
        }
      } catch(e) {
        if (!useUser && e.message.toLowerCase().includes("not found")) {
          useUser = true;
          cursor = null;
          allItems = [];
          continue;
        }
        throw e;
      }
    }

    this.projectFieldCache = {projectId: projectId, fields: fields};
    return this._mapItems(allItems);
  },

  _mapItems: function(items) {
    var statusMap = {"Backlog":"backlog","Todo":"backlog","In Progress":"in_progress","In Review":"review","Needs review":"review","Review":"review","Done":"done","Cancelled":"cancelled","Blocked":"blocked"};
    var priMap = {"Critical":"critical","High":"high","Medium":"medium","Low":"low"};

    return items.map(function(item, idx) {
      var content = item.content || {};
      var fieldValues = (item.fieldValues && item.fieldValues.nodes) || [];

      // Extract status and priority from field values
      var ghStatus = "Todo";
      var ghPriority = "Medium";
      fieldValues.forEach(function(fv) {
        if (!fv || !fv.field) return;
        var fname = fv.field.name || "";
        if (fname === "Status" && fv.name) ghStatus = fv.name;
        if (fname === "Priority" && fv.name) ghPriority = fv.name;
      });

      var issueNumber = content.number;
      var assignees = ((content.assignees && content.assignees.nodes) || []).map(function(a) { return a.login; });
      var labels = ((content.labels && content.labels.nodes) || []).map(function(l) { return l.name; });
      var latticeStatus = statusMap[ghStatus] || "backlog";

      return {
        id: item.id,
        short_id: issueNumber ? "GH-" + issueNumber : "GH-" + (idx + 1),
        title: content.title || "(untitled)",
        status: latticeStatus,
        priority: priMap[ghPriority] || "medium",
        type: "task",
        assigned_to: assignees.length ? "human:" + assignees[0] : null,
        tags: labels.length ? labels.map(function(l) { return l.toLowerCase().replace(/\s+/g, "-"); }) : null,
        created_at: content.createdAt || "",
        updated_at: content.updatedAt || content.createdAt || "",
        done_at: latticeStatus === "done" ? (content.updatedAt || "") : null,
        last_status_changed_at: content.updatedAt || content.createdAt || "",
        comment_count: (content.comments && content.comments.totalCount) || 0,
        reopened_count: 0,
        relationships_out_count: 0,
        evidence_ref_count: 0,
        branch_link_count: 0,
        has_active_session: latticeStatus === "in_progress" && assignees.length > 0,
        description: content.body || null,
        custom_fields: {
          github_url: content.url || "",
          github_issue_number: issueNumber ? String(issueNumber) : "",
          github_project_item_id: item.id,
          _gh_status_name: ghStatus  // preserve original for mutations
        }
      };
    });
  },

  updateItemStatus: async function(itemId, newGhStatus) {
    if (!this.projectFieldCache) throw new Error("Project metadata not loaded");
    // Find the Status field and option
    var statusField = null;
    var targetOption = null;
    (this.projectFieldCache.fields || []).forEach(function(f) {
      if (f.name === "Status" && f.options) {
        statusField = f;
        f.options.forEach(function(opt) {
          if (opt.name === newGhStatus) targetOption = opt;
        });
      }
    });
    if (!statusField || !targetOption) throw new Error("Status '" + newGhStatus + "' not found in project fields");

    var mutation = 'mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) { updateProjectV2ItemFieldValue(input: {projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {singleSelectOptionId: $optionId}}) { projectV2Item { id } } }';
    await this.graphql(mutation, {
      projectId: this.projectFieldCache.projectId,
      itemId: itemId,
      fieldId: statusField.id,
      optionId: targetOption.id
    });
  },

  addComment: async function(issueNumber, body) {
    // Extract owner/repo from the repo config or the first item's URL
    var repoParts = this.repo.split("/");
    if (repoParts.length !== 2) throw new Error("Repo not configured for comments");
    await this.restApi("/repos/" + repoParts[0] + "/" + repoParts[1] + "/issues/" + issueNumber + "/comments", {
      method: "POST",
      body: {body: body}
    });
  },

  updateAssignees: async function(issueNumber, assignees) {
    var repoParts = this.repo.split("/");
    if (repoParts.length !== 2) throw new Error("Repo not configured");
    await this.restApi("/repos/" + repoParts[0] + "/" + repoParts[1] + "/issues/" + issueNumber, {
      method: "PATCH",
      body: {assignees: assignees}
    });
  },

  // Reverse mapping: Lattice status -> GitHub Project status name
  _reverseStatusMap: {"backlog":"Backlog","in_progress":"In Progress","review":"In Review","done":"Done","cancelled":"Cancelled","blocked":"Blocked"}
};

// --- API ---
async function api(path, opts) {
  // GitHub Pages mode: intercept API calls
  if (ghMode.enabled) {
    return ghApi(path, opts);
  }
  var r = await fetch(path, opts);
  var body = await r.json();
  if (!body.ok) throw new Error(body.error ? body.error.message : "API error");
  return body.data;
}

async function apiPost(path, data) {
  if (ghMode.enabled) {
    return ghApiPost(path, data);
  }
  return api(path, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify(data)
  });
}

// GitHub Pages API adapter for GET requests
async function ghApi(path) {
  // Config
  if (path === "/api/config") {
    var r = await fetch("data/config.json");
    var cfg = await r.json();
    // Store GitHub config for later use
    var gh = cfg.github || {};
    ghMode.org = gh.org || "";
    ghMode.projectNumber = gh.project_number || 0;
    ghMode.repo = gh.repo || "";
    ghMode.oauthClientId = gh.oauth_client_id || "";
    ghMode.oauthProxyUrl = gh.oauth_proxy_url || "";
    ghMode._updateAuthUI();
    return cfg;
  }

  // Tasks list
  if (path === "/api/tasks") {
    // If authenticated, fetch live from GitHub API
    if (ghMode.token) {
      try {
        return await ghMode.fetchProjectItems();
      } catch(e) {
        console.warn("Live fetch failed, falling back to snapshot:", e);
      }
    }
    // Fall back to static snapshot
    var r2 = await fetch("data/snapshot.json");
    var snap = await r2.json();
    return snap.data || snap;
  }

  // Graph data — build nodes from tasks array for Cube 3D
  if (path === "/api/graph" || path.startsWith("/api/graph")) {
    var graphNodes = (tasks || []).map(function(t) {
      return {
        id: t.id,
        short_id: t.short_id,
        title: t.title,
        status: t.status,
        priority: t.priority,
        type: t.type,
        assigned_to: t.assigned_to,
        branch_links: [],
        created_at: t.created_at,
        updated_at: t.updated_at,
        description_snippet: (t.description || "").slice(0, 200)
      };
    });
    return {nodes: graphNodes, links: [], revision: graphNodes.length + ":" + (graphNodes[0] && graphNodes[0].updated_at || "")};
  }

  // Archived tasks (not available in GH Pages mode)
  if (path === "/api/archived") {
    return [];
  }

  // Task detail
  var taskMatch = path.match(/^\/api\/tasks\/([^\/]+)$/);
  if (taskMatch) {
    // Find in current tasks array
    var tid = taskMatch[1];
    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].id === tid) return tasks[i];
    }
    throw new Error("Task not found");
  }

  // Task full detail
  var fullMatch = path.match(/^\/api\/tasks\/([^\/]+)\/full$/);
  if (fullMatch) {
    var tid2 = fullMatch[1];
    for (var j = 0; j < tasks.length; j++) {
      if (tasks[j].id === tid2) {
        var t2 = Object.assign({}, tasks[j]);
        t2.recent_events = [];
        t2.comments = [];
        return t2;
      }
    }
    throw new Error("Task not found");
  }

  // Events / comments — not available in static mode
  if (path.match(/\/events$/) || path.match(/\/comments$/)) {
    return [];
  }

  // Activity
  if (path === "/api/activity") {
    return {events: [], has_more: false};
  }

  // Stats
  if (path === "/api/stats") {
    return {};
  }

  // Git
  if (path === "/api/git" || path.startsWith("/api/git/")) {
    return {branches: []};
  }

  throw new Error("Not available in GitHub Pages mode: " + path);
}

// GitHub Pages API adapter for POST requests (mutations)
async function ghApiPost(path, data) {
  if (!ghMode.token) {
    showToast("Sign in with GitHub to make changes", "error");
    throw new Error("Authentication required");
  }

  // Status change
  var statusMatch = path.match(/^\/api\/tasks\/([^\/]+)\/status$/);
  if (statusMatch) {
    var taskId = statusMatch[1];
    var newLatticeStatus = data.status;
    var ghStatusName = ghMode._reverseStatusMap[newLatticeStatus] || newLatticeStatus;
    await ghMode.updateItemStatus(taskId, ghStatusName);
    // Refresh tasks from live API
    tasks = await ghMode.fetchProjectItems();
    return {};
  }

  // Comment
  var commentMatch = path.match(/^\/api\/tasks\/([^\/]+)\/comment$/);
  if (commentMatch) {
    var ctid = commentMatch[1];
    // Find the issue number
    var task = null;
    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].id === ctid) { task = tasks[i]; break; }
    }
    if (task && task.custom_fields && task.custom_fields.github_issue_number) {
      await ghMode.addComment(parseInt(task.custom_fields.github_issue_number), data.body);
      return {};
    }
    throw new Error("Cannot comment: issue number not found");
  }

  // Assign
  var assignMatch = path.match(/^\/api\/tasks\/([^\/]+)\/assign$/);
  if (assignMatch) {
    var atid = assignMatch[1];
    var assignTask = null;
    for (var k = 0; k < tasks.length; k++) {
      if (tasks[k].id === atid) { assignTask = tasks[k]; break; }
    }
    if (assignTask && assignTask.custom_fields && assignTask.custom_fields.github_issue_number) {
      var assignee = (data.assigned_to || "").replace(/^human:/, "");
      await ghMode.updateAssignees(
        parseInt(assignTask.custom_fields.github_issue_number),
        assignee ? [assignee] : []
      );
      tasks = await ghMode.fetchProjectItems();
      return {};
    }
    throw new Error("Cannot assign: issue number not found");
  }

  // Create task -> create GitHub issue
  if (path === "/api/tasks") {
    if (ghMode.repo) {
      var repoParts = ghMode.repo.split("/");
      if (repoParts.length === 2) {
        var issueData = {title: data.title || "New Task"};
        if (data.description) issueData.body = data.description;
        if (data.tags && data.tags.length) issueData.labels = data.tags;
        var created = await ghMode.restApi("/repos/" + repoParts[0] + "/" + repoParts[1] + "/issues", {
          method: "POST",
          body: issueData
        });
        // Refresh tasks
        tasks = await ghMode.fetchProjectItems();
        return {id: "gh_" + created.number, short_id: "GH-" + created.number};
      }
    }
    throw new Error("Cannot create tasks: repo not configured");
  }

  // Config save — store in localStorage in GH Pages mode
  if (path === "/api/config/dashboard") {
    localStorage.setItem("gh_dashboard_config", JSON.stringify(data));
    if (config) config.dashboard = Object.assign(config.dashboard || {}, data);
    return {};
  }

  // Unsupported mutations
  showToast("This action is not yet supported in GitHub Pages mode", "error");
  throw new Error("Not supported in GitHub Pages mode: " + path);
}

// --- Open Notes / Plans in System Editor ---
// Exposed on window because inline onclick handlers can't reach IIFE scope
window.openNotes = async function(taskId) {
  if (ghMode.enabled) {
    // In GitHub mode, try to open the issue URL
    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].id === taskId && tasks[i].custom_fields && tasks[i].custom_fields.github_url) {
        window.open(tasks[i].custom_fields.github_url, "_blank");
        return;
      }
    }
    showToast("No GitHub URL for this task", "error");
    return;
  }
  try {
    await apiPost("/api/tasks/" + taskId + "/open-notes", {});
    showToast(t("toast.notes_opened"));
  } catch (e) {
    showToast(e.message, "error");
  }
};

window.openPlans = async function(taskId) {
  if (ghMode.enabled) {
    // In GitHub mode, open the issue URL
    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].id === taskId && tasks[i].custom_fields && tasks[i].custom_fields.github_url) {
        window.open(tasks[i].custom_fields.github_url, "_blank");
        return;
      }
    }
    showToast("No GitHub URL for this task", "error");
    return;
  }
  try {
    await apiPost("/api/tasks/" + taskId + "/open-plans", {});
    showToast(t("toast.plans_opened"));
  } catch (e) {
    showToast(e.message, "error");
  }
};

// --- Toast Notifications ---
function showToast(message, type) {
  var container = document.getElementById("toast-container");
  var toast = document.createElement("div");
  toast.className = "toast toast-" + (type || "success");
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(function() {
    toast.style.opacity = "0";
    toast.style.transition = "opacity .3s";
    setTimeout(function() { toast.remove(); }, 300);
  }, 3000);
}

// --- Init ---
async function init() {
  var hash = location.hash.slice(1) || "/board";
  var parts = hash.split("/").filter(Boolean);
  currentView = parts[0] || "board";
  updateTabs();

  try {
    var results = await Promise.all([api("/api/config"), api("/api/tasks"), api("/api/graph").catch(function() { return { links: [] }; })]);
    config = results[0];
    tasks = results[1];
    boardGraphLinks = (results[2] && results[2].links) || [];
    // Load voice preference
    var dc = (config && config.dashboard) || {};
    if (dc.voice && VOICES[dc.voice]) {
      currentVoice = dc.voice;
    }
    updateAllBadges();
    applyTheme(getTheme());
    populateThemeSelector();
    populateVoiceSelector();
    updateStaticVoiceStrings();
    populateLaneColorSettings();
    loadColumnWidthSetting();
    loadFontSizeSetting();
    loadBackgroundSetting();
    loadHeatMapSetting();
    await route(hash);
  } catch(e) {
    showError(e.message);
  }
}

function updateTabs() {
  document.querySelectorAll(".nav-tab").forEach(function(el) {
    el.classList.toggle("active", el.dataset.view === currentView);
  });
}

function updateStatsBadges() {
  var el = document.getElementById("stats-badges");
  var total = tasks.length;
  el.innerHTML = '<span class="badge badge-stat">' + total + " " + t("stats.tasks") + "</span>";
}

function updateAllBadges() {
  updateStatsBadges();
}

// --- Cube (3D graph view) ---
// Delegates to cube3d.js external module

async function renderCube() {
  if (typeof renderCube3D === 'function') {
    await renderCube3D();
  } else {
    var app = document.getElementById('app');
    app.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:calc(100vh - 60px);color:var(--text-muted);text-align:center;padding:40px;">'
      + '<div><div style="font-size:48px;margin-bottom:16px;opacity:0.6">\u26a0</div>'
      + '<div style="font-size:18px;font-weight:600;color:var(--text-primary);margin-bottom:8px">3D library unavailable</div>'
      + '<div style="max-width:400px;line-height:1.5">The Cube 3D view requires Three.js. Check your network connection.</div>'
      + '<button onclick="location.reload()" style="margin-top:16px;padding:8px 24px;background:var(--accent-primary);color:#fff;border:none;border-radius:var(--radius-md);cursor:pointer">Retry</button>'
      + '</div></div>';
  }
}

function updateCubeData(data) {
  if (typeof updateCube3DData === 'function') {
    cubeCurrentRevision = (data && data.revision) || null;
    updateCube3DData(data);
  }
}

function cleanupCube() {
  if (typeof cleanupCube3D === 'function') {
    cleanupCube3D();
  }
  cubeCurrentRevision = null;
  cubeRenderGeneration++;
}

// --- Web (Indra's Web view) ---

function buildWebHierarchy(graphData, gitData) {
  var nodes = (graphData && graphData.nodes) || [];
  var links = (graphData && graphData.links) || [];

  // Index nodes by ID and short_id
  var nodeById = {};
  var nodeByShortId = {};
  nodes.forEach(function(n) {
    nodeById[n.id] = n;
    if (n.short_id) nodeByShortId[n.short_id.toUpperCase()] = n;
  });

  // Build parent/child maps from subtask_of links
  var parentMap = {};  // child_id -> parent_id
  var childrenMap = {}; // parent_id -> [child_ids]
  links.forEach(function(link) {
    if (link.type === "subtask_of") {
      var childId = (typeof link.source === "object") ? link.source.id : link.source;
      var parentId = (typeof link.target === "object") ? link.target.id : link.target;
      parentMap[childId] = parentId;
      if (!childrenMap[parentId]) childrenMap[parentId] = [];
      childrenMap[parentId].push(childId);
    }
  });

  // Assign tier per node
  var tierMap = {};
  nodes.forEach(function(n) {
    // Topology-based: nodes with children but no parent → hub
    // Everything else → task
    var hasChildren = childrenMap[n.id] && childrenMap[n.id].length > 0;
    var hasParent = !!parentMap[n.id];
    if (!hasParent && hasChildren) tierMap[n.id] = "hub";
    else tierMap[n.id] = "task";
  });

  // Build branch recency map from git data
  var branchRecency = {}; // branch_name -> last_commit_timestamp_ms
  var gitBranches = (gitData && gitData.available && gitData.branches) || [];
  gitBranches.forEach(function(b) {
    if (b.last_commit_date) {
      branchRecency[b.name] = new Date(b.last_commit_date).getTime();
    }
  });

  // Map branches to tasks via branch_links + implicit convention detection
  var taskBranches = {}; // task_id -> [branch_names]
  var linkedBranches = new Set();

  // Explicit links from branch_links field
  nodes.forEach(function(n) {
    if (n.branch_links && n.branch_links.length > 0) {
      n.branch_links.forEach(function(bl) {
        var bname = bl.branch || bl;
        if (!taskBranches[n.id]) taskBranches[n.id] = [];
        taskBranches[n.id].push(bname);
        linkedBranches.add(bname);
      });
    }
  });

  // Implicit convention: branch name contains short ID (e.g., feat/LAT-47-oauth)
  // Uses word-boundary matching to avoid LAT-4 matching inside LAT-42.
  gitBranches.forEach(function(b) {
    if (linkedBranches.has(b.name)) return;
    var branchUpper = b.name.toUpperCase();
    for (var sid in nodeByShortId) {
      if (!nodeByShortId.hasOwnProperty(sid)) continue;
      // Match short ID with non-alpha boundaries (consistent with CLI extract_short_ids)
      var pattern = new RegExp("(?<![A-Za-z])" + sid.replace(/[-]/g, "\\-") + "(?![A-Za-z])");
      if (pattern.test(branchUpper)) {
        var matchedNode = nodeByShortId[sid];
        if (!taskBranches[matchedNode.id]) taskBranches[matchedNode.id] = [];
        taskBranches[matchedNode.id].push(b.name);
        linkedBranches.add(b.name);
        break;
      }
    }
  });

  // Detect orphan branches (no linked task, not main/master/HEAD)
  var skipBranches = new Set(["main", "master", "HEAD", "develop", "dev"]);
  var orphanBranches = [];
  gitBranches.forEach(function(b) {
    if (!linkedBranches.has(b.name) && !skipBranches.has(b.name)) {
      orphanBranches.push(b);
    }
  });

  // Compute activity state per node
  var now = Date.now();
  var activity = {};  // task_id -> { git: bool, lattice: bool }
  nodes.forEach(function(n) {
    var gitActive = false;
    var latticeActive = (n.status === "in_progress");
    var branches = taskBranches[n.id] || [];
    branches.forEach(function(bname) {
      var ts = branchRecency[bname];
      if (ts && (now - ts) < WEB_ACTIVITY_WINDOW_MS) {
        gitActive = true;
      }
    });
    if (gitActive || latticeActive) {
      activity[n.id] = { git: gitActive, lattice: latticeActive };
    }
  });

  // Build output nodes with tier info
  var outNodes = nodes.map(function(n) {
    return {
      id: n.id,
      short_id: n.short_id,
      title: n.title,
      status: n.status,
      priority: n.priority,
      type: n.type,
      assigned_to: n.assigned_to,
      tier: tierMap[n.id],
      branches: taskBranches[n.id] || [],
      activityState: activity[n.id] || null
    };
  });

  // Build links — include ALL relationship types for full graph connectivity
  var outLinks = [];
  links.forEach(function(link) {
    var sourceId = (typeof link.source === "object") ? link.source.id : link.source;
    var targetId = (typeof link.target === "object") ? link.target.id : link.target;
    // Only include links where both endpoints exist
    if (nodeById[sourceId] && nodeById[targetId]) {
      outLinks.push({
        source: sourceId,
        target: targetId,
        type: link.type
      });
    }
  });

  return {
    nodes: outNodes,
    links: outLinks,
    orphanBranches: orphanBranches,
    activity: activity
  };
}

// Semantic zoom — small compact cards appear first, large cards at higher zoom
var WEB_CARD_SMALL = { task: 1.5, hub: 3.0 };
var WEB_CARD_LARGE = { task: 3.5, hub: 6.0 };
// Cards fade in over this range past threshold (0→1 opacity ramp)
var WEB_DETAIL_FADE_RANGE = 1.0;

// Helper: truncate text to fit a max width on canvas
function webTruncText(ctx, text, maxW) {
  if (!text) return "";
  if (ctx.measureText(text).width <= maxW) return text;
  var t = text;
  while (t.length > 1 && ctx.measureText(t + "\u2026").width > maxW) t = t.slice(0, -1);
  return t + "\u2026";
}

// Word-wrap text into up to maxLines lines that fit within maxW.
// Returns an array of strings. Last line truncated with ellipsis if needed.
function webWrapText(ctx, text, maxW, maxLines) {
  if (!text) return [""];
  if (maxLines < 1) maxLines = 1;
  var words = text.split(/\s+/);
  var lines = [];
  var cur = "";
  for (var i = 0; i < words.length; i++) {
    var test = cur ? (cur + " " + words[i]) : words[i];
    if (ctx.measureText(test).width <= maxW) {
      cur = test;
    } else {
      if (cur) {
        lines.push(cur);
        if (lines.length >= maxLines) { break; }
        cur = words[i];
      } else {
        // Single word wider than maxW — truncate it
        cur = words[i];
      }
    }
  }
  if (cur && lines.length < maxLines) lines.push(cur);
  if (lines.length === 0) lines.push(text);
  // If we ran out of lines but have remaining text, truncate last line
  if (lines.length >= maxLines) {
    // Rebuild remaining text from where we stopped
    var lastLine = lines[maxLines - 1];
    var remaining = words.slice(i).join(" ");
    if (remaining) {
      // There's overflow — truncate the last line with ellipsis
      lastLine = webTruncText(ctx, lastLine + " " + remaining, maxW);
    } else if (ctx.measureText(lastLine).width > maxW) {
      lastLine = webTruncText(ctx, lastLine, maxW);
    }
    lines[maxLines - 1] = lastLine;
    lines.length = maxLines;
  }
  return lines;
}

// Helper: draw a rounded rect on canvas
function webRoundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// Helper: pick best card anchor direction based on node position in the graph.
// Returns { dx, dy } unit-ish direction pointing away from center, so cards
// fan outward. Avoids all cards stacking to one side.
function webCardDir(node) {
  var nx = node.x || 0;
  var ny = node.y || 0;
  var len = Math.sqrt(nx * nx + ny * ny) || 1;
  // Normalize, but bias horizontally (cards are wider than tall)
  var dx = (nx / len);
  var dy = (ny / len) * 0.6;
  // Re-normalize so magnitude ≈ 1
  var len2 = Math.sqrt(dx * dx + dy * dy) || 1;
  return { dx: dx / len2, dy: dy / len2 };
}

// Draw a detail card on canvas next to (or centered on) a node.
// opts: { lines, statusColor, actColor, fadeAlpha, centered, large }
// Each line: { text, bold, color, maxLines? }
// If maxLines > 1, text is word-wrapped into multiple rendered lines.
function webDrawCard(ctx, node, radius, globalScale, opts) {
  var lines = opts.lines;
  var statusColor = opts.statusColor;
  var actColor = opts.actColor;
  var fa = (opts.fadeAlpha != null) ? opts.fadeAlpha : 1;
  var centered = !!opts.centered;
  var large = !!opts.large;

  // Large cards: wider, bigger font, more padding
  var baseFs = large ? 13 : 10;
  var baseW = large ? 200 : 130;
  var basePad = large ? 10 : 6;
  var baseCorner = large ? 5 : 3;

  var fs = baseFs / globalScale;
  if (fs > (large ? 16 : 12)) fs = (large ? 16 : 12);
  var lineH = fs * (large ? 1.45 : 1.35);
  var pad = basePad / globalScale;
  var cardW = baseW / globalScale;
  var cornerR = baseCorner / globalScale;
  var textMaxW = cardW - pad * 2 - 8 / globalScale;

  // Expand lines: word-wrap any line with maxLines > 1
  var rendered = [];
  lines.forEach(function(line) {
    ctx.font = (line.bold ? "bold " : "") + fs + "px sans-serif";
    if (line.maxLines && line.maxLines > 1) {
      var wrapped = webWrapText(ctx, line.text, textMaxW, line.maxLines);
      wrapped.forEach(function(wt) {
        rendered.push({ text: wt, bold: line.bold, color: line.color });
      });
    } else {
      rendered.push(line);
    }
  });

  var cardH = pad * 2 + rendered.length * lineH;

  var cardX, cardY;
  if (centered) {
    // Center card directly over the node circle (hub overlay)
    cardX = node.x - cardW / 2;
    cardY = node.y - cardH / 2;
  } else {
    // Fan outward from graph center
    var dir = webCardDir(node);
    var gap = radius + 6;
    var cx = node.x + dir.dx * (gap + cardW / 2);
    var cy = node.y + dir.dy * (gap + cardH / 2);
    cardX = cx - cardW / 2;
    cardY = cy - cardH / 2;

    // Connector line from node to card
    ctx.save();
    ctx.globalAlpha = ctx.globalAlpha * fa;
    ctx.beginPath();
    ctx.moveTo(node.x + dir.dx * radius, node.y + dir.dy * radius);
    ctx.lineTo(cardX + cardW / 2 - dir.dx * cardW / 2, cardY + cardH / 2 - dir.dy * cardH / 2);
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 0.5;
    ctx.stroke();
    ctx.restore();
  }

  // Store card bounds on node for hit detection
  node.__cardBounds = { x: cardX, y: cardY, w: cardW, h: cardH };

  ctx.save();
  ctx.globalAlpha = ctx.globalAlpha * fa;

  // Card background
  webRoundRect(ctx, cardX, cardY, cardW, cardH, cornerR);
  ctx.fillStyle = "rgba(30,30,40,0.88)";
  ctx.fill();

  // Status color left stripe
  if (statusColor) {
    var stripeW = (large ? 4 : 3) / globalScale;
    webRoundRect(ctx, cardX, cardY, stripeW, cardH, cornerR);
    ctx.fillStyle = statusColor;
    ctx.fill();
  }

  // Activity dot top-right
  if (actColor) {
    var dotR = 3 / globalScale;
    ctx.beginPath();
    ctx.arc(cardX + cardW - pad, cardY + pad + dotR, dotR, 0, 2 * Math.PI);
    ctx.fillStyle = actColor;
    ctx.fill();
  }

  // Render expanded text lines
  var textY = cardY + pad + fs * 0.85;
  rendered.forEach(function(line) {
    ctx.font = (line.bold ? "bold " : "") + fs + "px sans-serif";
    ctx.fillStyle = line.color || "rgba(255,255,255,0.9)";
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    ctx.fillText(webTruncText(ctx, line.text, textMaxW), cardX + pad + 4 / globalScale, textY);
    textY += lineH;
  });

  ctx.restore();
}

function drawWebNode(node, ctx, globalScale) {
  var tier = node.tier || "task";
  var radius = WEB_TIER_RADIUS[tier] || 4;
  var color = getLaneColor(node.status);
  var alpha = 1.0;

  // Dimming for done/blocked
  if (node.status === "done" || node.status === "cancelled") alpha = 0.3;
  else if (node.status === "blocked") alpha = 0.4;

  ctx.globalAlpha = alpha;

  // Activity glow ring
  var act = node.activityState;
  if (act) {
    var glowColor;
    if (act.git && act.lattice) glowColor = WEB_ACTIVITY_COLORS.both;
    else if (act.git) glowColor = WEB_ACTIVITY_COLORS.git;
    else glowColor = WEB_ACTIVITY_COLORS.lattice;

    ctx.save();
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(node.x, node.y, radius + 4, 0, 2 * Math.PI, false);
    ctx.strokeStyle = glowColor;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }

  // Main circle
  ctx.beginPath();
  ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI, false);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.lineWidth = 0.5;
  ctx.stroke();

  // Inner white ring for hubs (parent indicator)
  if (tier === "hub") {
    ctx.beginPath();
    ctx.arc(node.x, node.y, radius * 0.6, 0, 2 * Math.PI, false);
    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  var textColor = getComputedStyle(document.documentElement)
    .getPropertyValue("--text-primary").trim() || "#212529";

  // Determine card state: none / small / large
  var smallThresh = WEB_CARD_SMALL[tier] || 1.5;
  var largeThresh = WEB_CARD_LARGE[tier] || 3.5;
  var showSmall = globalScale >= smallThresh;
  var showLarge = globalScale >= largeThresh;

  // Fade factor: ramp from 0→1 over WEB_DETAIL_FADE_RANGE past the active threshold
  var activeThresh = showLarge ? largeThresh : (showSmall ? smallThresh : 0);
  var cardFade = showSmall ? Math.min(1, (globalScale - activeThresh) / WEB_DETAIL_FADE_RANGE) : 0;

  var sid = node.short_id || node.id.substring(0, 10);
  var statusLabel = getStatusDisplayName(node.status || "");
  var actColor = null;
  if (act) {
    if (act.git && act.lattice) actColor = WEB_ACTIVITY_COLORS.both;
    else if (act.git) actColor = WEB_ACTIVITY_COLORS.git;
    else actColor = WEB_ACTIVITY_COLORS.lattice;
  }

  if (showSmall) {
    var lines = [];
    var isLargeCard = false;

    if (showLarge) {
      // Large card: full detail, physically bigger — title wraps up to 4 lines
      isLargeCard = true;
      lines.push({ text: sid, bold: true, color: "rgba(255,255,255,1)" });
      if (node.title) lines.push({ text: node.title, bold: false, color: "rgba(255,255,255,0.85)", maxLines: 4 });
      lines.push({ text: statusLabel, bold: false, color: color });
      if (node.assigned_to) lines.push({ text: "\ud83d\udc64 " + node.assigned_to, bold: false, color: "rgba(200,200,255,0.7)" });
      if (tier === "hub" && node.type) lines.push({ text: "\ud83c\udfaf " + node.type, bold: false, color: "rgba(255,255,255,0.5)" });
      if (node.branches && node.branches.length > 0) {
        lines.push({ text: "\u2514 " + node.branches[0], bold: false, color: "rgba(180,220,255,0.6)" });
      }
      if (node.priority) lines.push({ text: "\u26a1 " + node.priority, bold: false, color: "rgba(255,220,150,0.7)" });
    } else {
      // Small card: compact — ID + title (2 lines) + status
      lines.push({ text: sid, bold: true, color: "rgba(255,255,255,1)" });
      if (node.title) lines.push({ text: node.title, bold: false, color: "rgba(255,255,255,0.8)", maxLines: 2 });
      lines.push({ text: statusLabel, bold: false, color: color });
    }

    // Hub cards center on the node; others fan outward
    var isHubCentered = (tier === "hub");

    webDrawCard(ctx, node, radius, globalScale, {
      lines: lines,
      statusColor: color,
      actColor: actColor,
      fadeAlpha: cardFade,
      centered: isHubCentered,
      large: isLargeCard
    });

    // Short label below circle (skip for centered hubs — card is right there)
    if (!isHubCentered) {
      var fontSize = 8 / globalScale;
      if (fontSize > 12) fontSize = 12;
      if (fontSize >= 2) {
        ctx.font = fontSize + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = textColor;
        ctx.fillText(sid, node.x, node.y + radius + 2);
      }
    }
  } else {
    // No card — just text labels
    node.__cardBounds = null;
    var fontSize2;
    if (tier === "hub") {
      fontSize2 = 12 / globalScale;
      if (fontSize2 > 14) fontSize2 = 14;
      if (fontSize2 < 3) { ctx.globalAlpha = 1.0; return; }
      var label = node.short_id || node.title || node.id.substring(0, 8);
      ctx.font = "bold " + fontSize2 + "px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillStyle = textColor;
      ctx.fillText(label, node.x, node.y + radius + 3);
    } else {
      fontSize2 = 8 / globalScale;
      if (fontSize2 > 9) fontSize2 = 9;
      if (fontSize2 >= 4) {
        var dlabel = node.short_id || node.id.substring(0, 6);
        ctx.font = fontSize2 + "px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = textColor;
        ctx.fillText(dlabel, node.x, node.y + radius + 1);
      }
    }
  }

  ctx.globalAlpha = 1.0;
}

// Expand the pointer hit area to include card bounds (makes cards clickable)
function drawWebNodePointerArea(node, color, ctx) {
  var tier = node.tier || "task";
  var radius = WEB_TIER_RADIUS[tier] || 4;

  // Always paint the circle hit area
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(node.x, node.y, radius + 2, 0, 2 * Math.PI, false);
  ctx.fill();

  // If a card is visible, extend hit area to cover it
  var cb = node.__cardBounds;
  if (cb) {
    ctx.fillRect(cb.x, cb.y, cb.w, cb.h);
  }
}

function buildWebTooltipHTML(node) {
  var tierBadge = { hub: "Hub", task: "Task" };
  var html = '<div style="background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:8px 12px;font-size:12px;max-width:300px;box-shadow:0 4px 12px rgba(0,0,0,0.15);color:var(--text-primary);line-height:1.4">';
  html += '<div style="display:flex;gap:6px;align-items:center;margin-bottom:4px">';
  html += '<span style="background:var(--surface-raised);border:1px solid var(--border);border-radius:4px;padding:1px 6px;font-size:10px;font-weight:600;text-transform:uppercase">' + esc(tierBadge[node.tier] || "Task") + '</span>';
  html += '<span style="font-weight:700;font-family:var(--font-mono)">' + esc(node.short_id || node.id.substring(0, 12)) + '</span>';
  html += '</div>';
  html += '<div style="font-weight:500;margin-bottom:6px">' + esc(node.title || '') + '</div>';
  if (node.status) {
    html += '<div style="display:flex;gap:6px;align-items:center;margin-bottom:2px"><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:' + esc(getLaneColor(node.status)) + '"></span><span style="color:var(--text-muted);font-size:11px;min-width:50px">Status</span><span>' + esc(node.status) + '</span></div>';
  }
  if (node.assigned_to) {
    html += '<div style="display:flex;gap:6px;margin-bottom:2px"><span style="color:var(--text-muted);font-size:11px;min-width:50px">Assignee</span><span>' + esc(node.assigned_to) + '</span></div>';
  }
  // Activity indicators
  var act = node.activityState;
  if (act) {
    var indicators = [];
    if (act.git) indicators.push('<span style="color:' + WEB_ACTIVITY_COLORS.git + '">\u26a1 Git active</span>');
    if (act.lattice) indicators.push('<span style="color:' + WEB_ACTIVITY_COLORS.lattice + '">\u25cf In progress</span>');
    html += '<div style="margin-top:4px;display:flex;gap:8px">' + indicators.join("") + '</div>';
  }
  // Branch names
  if (node.branches && node.branches.length > 0) {
    html += '<div style="margin-top:4px;color:var(--text-muted);font-size:10px">';
    node.branches.forEach(function(b) { html += '<div>\u2514 ' + esc(b) + '</div>'; });
    html += '</div>';
  }
  html += '<div style="color:var(--text-muted);font-size:10px;margin-top:6px;border-top:1px solid var(--border);padding-top:4px">Click to open task</div>';
  html += '</div>';
  return html;
}

function buildWebLegendHTML(hasOrphans) {
  var html = '<div style="'
    + 'position:absolute;bottom:16px;left:16px;z-index:10;'
    + 'background:var(--surface);border:1px solid var(--border);'
    + 'border-radius:var(--radius-md);padding:10px 14px;'
    + 'font-size:.75rem;color:var(--text-secondary);'
    + 'max-width:220px;box-shadow:var(--shadow-card-hover);opacity:0.92;'
    + '">';
  html += '<div style="font-weight:600;margin-bottom:6px;color:var(--text-primary)">Node Tiers</div>';
  var tiers = [
    { label: "Hub (parent)", r: 10, tier: "hub" },
    { label: "Task", r: 5, tier: "task" }
  ];
  tiers.forEach(function(t) {
    html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">'
      + '<span style="display:inline-block;width:' + (t.r * 2) + 'px;height:' + (t.r * 2) + 'px;border-radius:50%;background:var(--text-muted);flex-shrink:0"></span>'
      + '<span>' + t.label + '</span></div>';
  });
  html += '<div style="border-top:1px solid var(--border-subtle);margin:8px 0"></div>';
  html += '<div style="font-weight:600;margin-bottom:6px;color:var(--text-primary)">Relationships</div>';
  var relTypes = [
    { label: "Subtask of", color: WEB_LINK_COLORS.subtask_of, dash: false },
    { label: "Blocks", color: WEB_LINK_COLORS.blocks, dash: false },
    { label: "Depends on", color: WEB_LINK_COLORS.depends_on, dash: false },
    { label: "Related to", color: WEB_LINK_COLORS.related_to, dash: true },
    { label: "Spawned by", color: WEB_LINK_COLORS.spawned_by, dash: false }
  ];
  relTypes.forEach(function(r) {
    var lineStyle = "display:inline-block;width:24px;height:2px;background:" + r.color + ";flex-shrink:0;";
    if (r.dash) lineStyle += "background:repeating-linear-gradient(90deg," + r.color + " 0," + r.color + " 4px,transparent 4px,transparent 7px);";
    html += '<div style="display:flex;align-items:center;gap:6px;margin-bottom:3px">'
      + '<span style="' + lineStyle + '"></span>'
      + '<span>' + r.label + '</span></div>';
  });
  html += '<div style="border-top:1px solid var(--border-subtle);margin:8px 0"></div>';
  html += '<div style="font-weight:600;margin-bottom:6px;color:var(--text-primary)">Activity</div>';
  var activities = [
    { label: "Git active (<10m)", color: WEB_ACTIVITY_COLORS.git },
    { label: "In progress", color: WEB_ACTIVITY_COLORS.lattice },
    { label: "Both", color: WEB_ACTIVITY_COLORS.both }
  ];
  activities.forEach(function(a) {
    html += '<div style="display:flex;align-items:center;gap:6px;margin-bottom:3px">'
      + '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;border:2px solid ' + a.color + ';flex-shrink:0;box-shadow:0 0 4px ' + a.color + '"></span>'
      + '<span>' + a.label + '</span></div>';
  });
  html += '</div>';
  return html;
}

async function renderWeb() {
  var app = document.getElementById("app");
  app.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  cleanupWeb();

  webRenderGeneration++;
  var myGeneration = webRenderGeneration;

  // CDN fallback checks
  if (typeof ForceGraph === "undefined") {
    app.innerHTML = '<div class="web-empty">'
      + '<div class="web-fallback-icon">\u26a0</div>'
      + '<div class="web-fallback-title">Graph library unavailable</div>'
      + '<div class="web-fallback-msg">The Web view requires the force-graph library. Check your network connection.</div>'
      + '<button class="web-fallback-retry" onclick="location.reload()">Retry</button>'
      + '</div>';
    return;
  }
  if (typeof d3 === "undefined" || typeof d3.forceX !== "function") {
    app.innerHTML = '<div class="web-empty">'
      + '<div class="web-fallback-icon">\u26a0</div>'
      + '<div class="web-fallback-title">Layout library unavailable</div>'
      + '<div class="web-fallback-msg">The Web view requires d3-force. Check your network connection.</div>'
      + '<button class="web-fallback-retry" onclick="location.reload()">Retry</button>'
      + '</div>';
    return;
  }

  // Fetch both endpoints in parallel
  var graphData, gitData;
  try {
    var results = await Promise.all([
      api("/api/graph"),
      api("/api/git").catch(function() { return { available: false }; })
    ]);
    graphData = results[0];
    gitData = results[1];
  } catch (e) {
    if (myGeneration !== webRenderGeneration) return;
    app.innerHTML = '<div class="web-empty"><p>Failed to load data: ' + esc(e.message) + '</p></div>';
    return;
  }
  if (myGeneration !== webRenderGeneration) return;

  // Build hierarchy
  var hierarchy = buildWebHierarchy(graphData, gitData);
  var webNodes = hierarchy.nodes;
  var webLinks = hierarchy.links;

  webData = { graphRevision: graphData.revision, gitData: gitData, hierarchy: hierarchy };
  webCurrentRevision = (graphData.revision || "") + ":" + (gitData.head_commit || "");

  // Empty state
  if (webNodes.length === 0) {
    app.innerHTML = '<div class="web-empty">'
      + '<p>No tasks to visualize.</p>'
      + '<p style="color:var(--text-muted);font-size:.875rem;">Create some tasks to see the coordination web.</p>'
      + '</div>';
    return;
  }

  // Build container
  app.innerHTML = '<div id="web-container" style="'
    + 'position:relative;width:100%;height:calc(100vh - 60px);overflow:hidden;'
    + 'background:var(--bg-base);">'
    + '<span class="sr-only">' + esc(webNodes.length + ' nodes in Indra\'s Web visualization. Use Board or List for full accessibility.') + '</span>'
    + '</div>';
  var container = document.getElementById("web-container");
  container.setAttribute("role", "img");
  container.setAttribute("aria-label", "Indra's Web — coordination landscape");

  // Mobile notice
  if (window.innerWidth < 768) {
    container.insertAdjacentHTML("afterbegin",
      '<div class="web-mobile-notice">'
      + '<span>Web works best on larger screens. Pinch to zoom, drag to pan.</span>'
      + '<button onclick="this.parentNode.remove()" style="background:none;border:none;cursor:pointer;color:inherit;font-size:16px">\u2715</button>'
      + '</div>');
  }

  // Legend
  container.insertAdjacentHTML("beforeend", buildWebLegendHTML(hierarchy.orphanBranches.length > 0));

  // Orphan badge
  if (hierarchy.orphanBranches.length > 0) {
    var orphanNames = hierarchy.orphanBranches.map(function(b) { return b.name; });
    container.insertAdjacentHTML("beforeend",
      '<div class="web-orphan-badge" title="' + esc(orphanNames.join(", ")) + '">'
      + '\u26a0 ' + hierarchy.orphanBranches.length + ' orphan branch' + (hierarchy.orphanBranches.length > 1 ? 'es' : '')
      + '</div>');
  }

  var w = container.offsetWidth;
  var h = container.offsetHeight;

  try {
    webGraph = ForceGraph()(container)
      .graphData({ nodes: webNodes, links: webLinks })
      .width(w).height(h)
      .nodeId("id")
      .nodeLabel(function(node) { return buildWebTooltipHTML(node); })
      .linkSource("source").linkTarget("target")
      .linkColor(function(link) {
        return WEB_LINK_COLORS[link.type] || WEB_SPOKE_COLOR;
      })
      .linkWidth(function(link) {
        if (link.type === "blocks") return 2.5;
        if (link.type === "depends_on") return 2;
        if (link.type === "subtask_of") {
          var src = (typeof link.source === "object") ? link.source : null;
          var tgt = (typeof link.target === "object") ? link.target : null;
          if (src && tgt && (src.tier === "hub" || tgt.tier === "hub")) return 2;
        }
        return 1;
      })
      .linkLineDash(function(link) {
        if (link.type === "related_to") return [4, 3];
        if (link.type === "duplicate_of") return [2, 2];
        return null;
      })
      .linkDirectionalArrowLength(function(link) {
        // Arrows for directional relationship types
        if (link.type === "blocks" || link.type === "depends_on" || link.type === "spawned_by" || link.type === "supersedes") return 6;
        return 0;
      })
      .linkDirectionalArrowRelPos(1)
      .onNodeClick(function(node) {
        if (node && node.id) openWebDetailPane(node.id);
      })
      .nodeCanvasObjectMode(function() { return "replace"; })
      .nodeCanvasObject(drawWebNode)
      .nodePointerAreaPaint(drawWebNodePointerArea);
  } catch (err) {
    app.innerHTML = '<div class="web-empty">'
      + '<div class="web-fallback-icon">\u26a0</div>'
      + '<div class="web-fallback-title">Graph rendering failed</div>'
      + '<div class="web-fallback-msg">' + esc(err.message) + '</div>'
      + '<button class="web-fallback-retry" onclick="location.hash=\'#/web\'">Retry</button>'
      + '</div>';
    return;
  }

  // Hierarchy-aware forces — modify the existing link force in-place
  // (replacing it with a new d3.forceLink causes "node not found" on direct navigation
  // because the new force hasn't been initialized with the simulation's node set yet)
  var existingLinkForce = webGraph.d3Force("link");
  if (existingLinkForce) {
    existingLinkForce
      .distance(function(link) {
        // Cross-cutting links (blocks, depends_on, etc.) get longer distance
        // so they create visible threads across the graph
        if (link.type !== "subtask_of") return WEB_LINK_DISTANCE["cross-cutting"];
        var src = (typeof link.source === "object") ? link.source : null;
        var tgt = (typeof link.target === "object") ? link.target : null;
        if (src && (src.tier === "hub" || (tgt && tgt.tier === "hub"))) return WEB_LINK_DISTANCE["hub-task"];
        return WEB_LINK_DISTANCE["task-task"];
      })
      .strength(function(link) {
        // Subtask_of links are strong (hold hierarchy together)
        // Cross-cutting links are weaker (don't distort layout)
        if (link.type === "subtask_of") {
          var src = (typeof link.source === "object") ? link.source : null;
          if (src && src.tier === "hub") return 0.7;
          return 0.5;
        }
        if (link.type === "blocks" || link.type === "depends_on") return 0.3;
        return 0.15;
      });
  }
  webGraph
    .d3Force("charge", d3.forceManyBody().strength(function(d) {
      return WEB_CHARGE[d.tier] || -30;
    }))
    .d3Force("x", d3.forceX(0).strength(0.03))
    .d3Force("y", d3.forceY(0).strength(0.03))
    .d3Force("collision", d3.forceCollide(function(d) {
      return WEB_COLLISION_RADIUS[d.tier] || 8;
    }).strength(0.7))
    .d3Force("center", null);

  // Resize handler
  webResizeHandler = function() {
    if (!webGraph) return;
    var c = document.getElementById("web-container");
    if (!c) return;
    webGraph.width(c.offsetWidth).height(c.offsetHeight);
  };
  window.addEventListener("resize", webResizeHandler);

  // Zoom to fit after stabilization
  webGraph.d3ReheatSimulation();
  setTimeout(function() {
    if (webGraph) webGraph.zoomToFit(400, 40);
  }, 2000);
}

function updateWebData(graphData, gitData) {
  if (!webGraph) return;
  if (!graphData) return;
  var newRevision = (graphData.revision || "") + ":" + ((gitData && gitData.head_commit) || "");
  if (webCurrentRevision && newRevision === webCurrentRevision) return;
  webCurrentRevision = newRevision;

  var hierarchy = buildWebHierarchy(graphData, gitData);
  var webNodes = hierarchy.nodes;

  if (webNodes.length === 0) {
    webData = null;
    renderWeb();
    return;
  }

  webData = { graphRevision: graphData.revision, gitData: gitData, hierarchy: hierarchy };
  webGraph.graphData({ nodes: webNodes, links: hierarchy.links });

  // Update orphan badge
  var container = document.getElementById("web-container");
  if (container) {
    var oldBadge = container.querySelector(".web-orphan-badge");
    if (oldBadge) oldBadge.remove();
    if (hierarchy.orphanBranches.length > 0) {
      var orphanNames = hierarchy.orphanBranches.map(function(b) { return b.name; });
      container.insertAdjacentHTML("beforeend",
        '<div class="web-orphan-badge" title="' + esc(orphanNames.join(", ")) + '">'
        + '\u26a0 ' + hierarchy.orphanBranches.length + ' orphan branch' + (hierarchy.orphanBranches.length > 1 ? 'es' : '')
        + '</div>');
    }
  }
}

function cleanupWeb() {
  closeWebDetailPane();
  if (webResizeHandler) {
    window.removeEventListener("resize", webResizeHandler);
    webResizeHandler = null;
  }
  if (webGraph) {
    webGraph.pauseAnimation();
    var container = document.getElementById("web-container");
    if (container) container.innerHTML = "";
    webGraph = null;
  }
  webData = null;
  webCurrentRevision = null;
  webRenderGeneration++;
}

// --- Web Detail Pane ---

function openWebDetailPane(taskId) {
  var pane = document.getElementById("web-detail-pane");
  var overlay = document.getElementById("web-detail-overlay");
  var body = document.getElementById("web-pane-body");
  var title = document.getElementById("web-pane-title");

  // Measure nav height and set CSS var so pane sits below it
  var nav = document.querySelector(".nav");
  if (nav) document.documentElement.style.setProperty("--nav-h", nav.offsetHeight + "px");

  body.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  title.textContent = "Loading\u2026";
  pane.classList.add("open");
  overlay.classList.add("open");

  Promise.all([
    api("/api/tasks/" + taskId),
    api("/api/tasks/" + taskId + "/events")
  ]).then(function(results) {
    var task = results[0];
    var events = results[1];

    // Header
    var sid = task.short_id || task.id.substring(0, 12);
    title.innerHTML = '<span style="color:var(--accent-primary);font-family:var(--font-mono)">' + esc(sid) + '</span> ' + esc(task.title || "Untitled");

    var html = '';

    // Status bar
    html += '<div class="pane-status-bar">';
    if (task.status) html += '<span class="badge" style="background:' + esc(getLaneColor(task.status)) + ';color:#fff;padding:2px 8px;border-radius:4px;font-size:.8rem" title="' + esc(getStatusDescription(task.status)) + '">' + esc(getStatusDisplayName(task.status)) + '</span>';
    if (task.priority) html += '<span class="badge pri-' + esc(task.priority) + '" style="padding:2px 8px;border-radius:4px;font-size:.8rem">' + esc(task.priority) + '</span>';
    if (task.type) html += '<span class="badge type-badge" style="padding:2px 8px;border-radius:4px;font-size:.8rem">' + esc(task.type) + '</span>';
    html += '</div>';

    // Fields
    var fields = [
      ["Assigned", task.assigned_to],
      ["Created by", task.created_by],
      ["Created", task.created_at],
      ["Updated", task.updated_at]
    ];
    fields.forEach(function(f) {
      if (f[1]) {
        html += '<div class="pane-field"><dt>' + esc(f[0]) + '</dt><dd>' + esc(String(f[1])) + '</dd></div>';
      }
    });

    // Description
    if (task.description) {
      html += '<div class="pane-section"><h3>Description</h3>';
      html += '<pre style="white-space:pre-wrap;font-size:.85rem;margin:0;color:var(--text-primary)">' + esc(task.description) + '</pre>';
      html += '</div>';
    }

    // Tags
    if (task.tags && task.tags.length) {
      html += '<div class="pane-section"><h3>Tags</h3>';
      task.tags.forEach(function(tag) { html += '<span class="badge badge-stat" style="margin-right:4px">' + esc(tag) + '</span>'; });
      html += '</div>';
    }

    // Relationships
    if (task.relationships_out && task.relationships_out.length) {
      html += '<div class="pane-section"><h3>Relationships</h3>';
      task.relationships_out.forEach(function(r) {
        html += '<div style="font-size:.85rem;margin-bottom:3px">' + esc(r.type) + ' \u2192 <a href="javascript:void(0)" onclick="openWebDetailPane(\'' + esc(r.target_task_id) + '\')" style="color:var(--accent-primary)">' + esc(r.target_task_id.substring(0, 12)) + '</a></div>';
      });
      html += '</div>';
    }

    // Comments
    var comments = (events || []).filter(function(ev) { return ev.type === "comment_added"; });
    if (comments.length) {
      html += '<div class="pane-section"><h3>Comments (' + comments.length + ')</h3>';
      comments.forEach(function(ev) {
        html += '<div class="pane-comment">';
        html += '<div class="pane-comment-meta">' + esc(ev.actor || "") + ' \u00b7 ' + esc(ev.ts || "") + '</div>';
        html += '<div>' + esc((ev.data && ev.data.body) || "") + '</div>';
        html += '</div>';
      });
      html += '</div>';
    }

    // Recent events (non-comment, last 10)
    var nonComments = (events || []).filter(function(ev) { return ev.type !== "comment_added"; }).slice(0, 10);
    if (nonComments.length) {
      html += '<div class="pane-section"><h3>History</h3>';
      nonComments.forEach(function(ev) {
        html += '<div class="pane-event">';
        html += '<span style="color:var(--text-muted);font-size:.75rem;min-width:60px">' + esc((ev.ts || "").substring(11, 19)) + '</span>';
        html += '<span class="ev-type">' + esc(ev.type || "") + '</span>';
        html += '<span>' + esc(ev.actor || "") + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    // Open full detail link
    html += '<button class="pane-open-full" onclick="closeWebDetailPane(); location.hash=\'#/task/' + esc(taskId) + '\'">Open Full Detail View</button>';

    body.innerHTML = html;

  }).catch(function(e) {
    body.innerHTML = '<div style="color:var(--color-danger);padding:20px">' + esc(e.message) + '</div>';
  });
}

function closeWebDetailPane() {
  var pane = document.getElementById("web-detail-pane");
  var overlay = document.getElementById("web-detail-overlay");
  if (pane) pane.classList.remove("open");
  if (overlay) overlay.classList.remove("open");
}

// Wire pane close handlers (once, at boot)
document.addEventListener("DOMContentLoaded", function() {
  var closeBtn = document.getElementById("web-pane-close");
  if (closeBtn) closeBtn.addEventListener("click", closeWebDetailPane);
  var overlay = document.getElementById("web-detail-overlay");
  if (overlay) overlay.addEventListener("click", closeWebDetailPane);
});

// --- Floating Detail Panel (Board / List) ---

function openDetailPanel(taskId) {
  var pane = document.getElementById("detail-panel");
  var body = document.getElementById("dp-body");
  var title = document.getElementById("dp-title");

  // Measure nav height so pane starts below it
  var nav = document.querySelector(".nav");
  if (nav) document.documentElement.style.setProperty("--nav-h", nav.offsetHeight + "px");

  // Remember which element triggered the panel for focus restoration
  _detailPanelTrigger = document.activeElement;
  _detailPanelTaskId = taskId;

  body.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  title.textContent = "Loading\u2026";
  pane.classList.add("open");

  var openGeneration = taskId; // stale-callback guard

  Promise.all([
    api("/api/tasks/" + taskId),
    api("/api/tasks/" + taskId + "/events")
  ]).then(function(results) {
    if (_detailPanelTaskId !== openGeneration) return; // user clicked a different card
    _renderPanelContent(taskId, results[0], results[1]);
  }).catch(function(e) {
    if (_detailPanelTaskId !== openGeneration) return;
    body.innerHTML = '<div style="color:var(--color-danger);padding:20px">' + esc(e.message) + '</div>';
  });

}

function closeDetailPanel() {
  var pane = document.getElementById("detail-panel");
  if (pane) pane.classList.remove("open");

  // Restore focus
  if (_detailPanelTrigger && _detailPanelTrigger.focus) {
    try { _detailPanelTrigger.focus(); } catch(e) {}
  }
  _detailPanelTaskId = null;
  _detailPanelTrigger = null;
}

function _renderPanelContent(taskId, task, events) {
  var body = document.getElementById("dp-body");
  var title = document.getElementById("dp-title");
  var isArchived = !!task.archived;

  // Header
  var sid = task.short_id || task.id.substring(0, 12);
  title.innerHTML = '<span style="color:var(--accent-primary);font-family:var(--font-mono)">' + esc(sid) + '</span> ' + esc(task.title || "Untitled");
  if (task.has_active_session) title.innerHTML += ' <span class="active-badge"><span class="active-dot"></span>Active</span>';

  var html = '';

  // Status / priority / type dropdowns (or read-only badges)
  if (!isArchived) {
    html += '<div class="dp-actions">';
    var transitions = (config && config.workflow && config.workflow.transitions) || {};
    var allowed = transitions[task.status] || [];
    html += '<select id="dp-status" title="Change status">';
    html += '<option value="' + esc(task.status) + '" selected>' + esc(getStatusDisplayName(task.status)) + '</option>';
    allowed.forEach(function(s) {
      html += '<option value="' + esc(s) + '">' + esc(getStatusDisplayName(s)) + '</option>';
    });
    html += '</select>';

    html += '<select id="dp-priority" title="Change priority">';
    ["critical","high","medium","low"].forEach(function(p) {
      html += '<option value="' + esc(p) + '"' + (p === task.priority ? ' selected' : '') + '>' + esc(p) + '</option>';
    });
    html += '</select>';

    var types = (config && config.task_types) || [];
    html += '<select id="dp-type" title="Change type">';
    types.forEach(function(ty) {
      html += '<option value="' + esc(ty) + '"' + (ty === task.type ? ' selected' : '') + '>' + esc(ty) + '</option>';
    });
    html += '</select>';
    html += '</div>';
  } else {
    html += '<div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px">';
    if (task.status) html += '<span class="badge" style="background:' + esc(getLaneColor(task.status)) + ';color:#fff;padding:2px 8px;border-radius:4px;font-size:.8rem" title="' + esc(getStatusDescription(task.status)) + '">' + esc(getStatusDisplayName(task.status)) + '</span>';
    if (task.priority) html += '<span class="badge pri-' + esc(task.priority) + '" style="padding:2px 8px;border-radius:4px;font-size:.8rem">' + esc(task.priority) + '</span>';
    if (task.type) html += '<span class="badge type-badge" style="padding:2px 8px;border-radius:4px;font-size:.8rem">' + esc(task.type) + '</span>';
    html += ' <span class="archived-badge">ARCHIVED</span></div>';
  }

  // Title (editable)
  if (!isArchived) {
    html += '<div class="dp-field"><dt>Title</dt><dd><span class="editable" id="dp-title-edit" title="Click to edit">' + esc(task.title || "Untitled") + '</span></dd></div>';
  }

  // Info fields
  html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">';
  if (task.short_id) html += '<div class="dp-field"><dt>Short ID</dt><dd style="font-weight:600;color:var(--accent-primary)">' + esc(task.short_id) + '</dd></div>';

  if (!isArchived) {
    html += '<div class="dp-field"><dt>Assigned to</dt><dd><span class="editable" id="dp-assigned" title="Click to edit">' + esc(task.assigned_to || "Unassigned") + '</span></dd></div>';
  } else {
    html += '<div class="dp-field"><dt>Assigned to</dt><dd>' + esc(task.assigned_to || "Unassigned") + '</dd></div>';
  }

  if (task.created_by) html += '<div class="dp-field"><dt>Created by</dt><dd>' + esc(task.created_by) + '</dd></div>';
  if (task.created_at) html += '<div class="dp-field"><dt>Created</dt><dd>' + esc(task.created_at) + '</dd></div>';
  if (task.updated_at) html += '<div class="dp-field"><dt>Updated</dt><dd>' + esc(task.updated_at) + '</dd></div>';
  html += '</div>';

  // Description (editable)
  html += '<div class="dp-section"><h3>Description</h3>';
  if (!isArchived) {
    html += '<pre class="editable" id="dp-description" style="white-space:pre-wrap;font-size:.85rem;min-height:16px;margin:0;color:var(--text-primary)" title="Click to edit">' + esc(task.description || "No description") + '</pre>';
  } else {
    html += '<pre style="white-space:pre-wrap;font-size:.85rem;margin:0;color:var(--text-primary)">' + esc(task.description || "") + '</pre>';
  }
  html += '</div>';

  // Tags (editable)
  html += '<div class="dp-section"><h3>Tags</h3>';
  if (!isArchived) {
    var tagStr = (task.tags && task.tags.length) ? task.tags.join(", ") : "";
    html += '<span class="editable" id="dp-tags" title="Click to edit">' + esc(tagStr || "No tags") + '</span>';
  } else if (task.tags && task.tags.length) {
    task.tags.forEach(function(tag) { html += '<span class="badge badge-stat" style="margin-right:4px">' + esc(tag) + '</span>'; });
  }
  html += '</div>';

  // Plan & Notes — always show Plan, show Notes only if file exists
  html += '<div class="dp-section"><h3>' + esc(t("section.plans")) + ' & ' + esc(t("section.notes")) + '</h3>';
  html += '<div style="display:flex;gap:8px;flex-wrap:wrap">';
  html += '<button class="btn btn-primary btn-sm" onclick="openPlans(\'' + esc(task.id) + '\')">' + esc(t("btn.show_plan")) + '</button>';
  if (task.notes_exists) {
    html += '<button class="btn btn-primary btn-sm" onclick="openNotes(\'' + esc(task.id) + '\')">' + esc(t("btn.show_notes")) + '</button>';
  }
  html += '</div></div>';

  // Comments
  var comments = (events || []).filter(function(ev) { return ev.type === "comment_added"; });
  html += '<div class="dp-section"><h3>Comments (' + comments.length + ')</h3>';
  if (!isArchived) {
    html += '<div style="display:flex;flex-direction:column;gap:6px;margin-bottom:8px">';
    html += '<textarea class="form-control" id="dp-comment-text" placeholder="Add a comment\u2026" style="min-height:50px;font-size:.85rem"></textarea>';
    html += '<button class="btn btn-primary btn-sm" id="dp-comment-submit" style="align-self:flex-end">Post</button>';
    html += '</div>';
  }
  if (comments.length) {
    comments.forEach(function(ev) {
      html += '<div class="dp-comment">';
      html += '<div class="dp-comment-meta">' + esc(ev.actor || "") + ' \u00b7 ' + esc(ev.ts || "") + '</div>';
      html += '<div>' + esc((ev.data && ev.data.body) || "") + '</div>';
      html += '</div>';
    });
  }
  html += '</div>';

  // History (last 10 non-comment events)
  var nonComments = (events || []).filter(function(ev) { return ev.type !== "comment_added"; }).slice(0, 10);
  if (nonComments.length) {
    html += '<div class="dp-section"><h3>History</h3>';
    nonComments.forEach(function(ev) {
      html += '<div class="dp-event">';
      html += '<span style="color:var(--text-muted);font-size:.75rem;min-width:55px">' + esc((ev.ts || "").substring(11, 19)) + '</span>';
      html += '<span class="ev-type">' + esc(ev.type || "") + '</span>';
      html += '<span>' + esc(ev.actor || "") + '</span>';
      html += '</div>';
    });
    html += '</div>';
  }

  // Archive button
  if (!isArchived) {
    html += '<div class="dp-section" style="border-top:none;margin-top:8px">';
    html += '<button class="btn btn-danger btn-sm" id="dp-archive-btn">Archive</button>';
    html += '</div>';
  }

  body.innerHTML = html;

  // Wire interactive elements
  if (!isArchived) {
    _wirePanelActions(taskId, task);
  }
}

function _wirePanelActions(taskId, task) {
  // Status change
  var statusSel = document.getElementById("dp-status");
  if (statusSel) {
    statusSel.addEventListener("change", async function() {
      var newStatus = this.value;
      if (newStatus === task.status) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/status", { status: newStatus });
        showToast(tf("toast.moved_to", {status: newStatus}), "success");
        await _refreshAfterPanelEdit(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.status;
      }
    });
  }

  // Priority change
  var priSel = document.getElementById("dp-priority");
  if (priSel) {
    priSel.addEventListener("change", async function() {
      var newPri = this.value;
      if (newPri === task.priority) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/update", { fields: { priority: newPri } });
        showToast(tf("toast.priority_changed", {value: newPri}), "success");
        await _refreshAfterPanelEdit(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.priority;
      }
    });
  }

  // Type change
  var typeSel = document.getElementById("dp-type");
  if (typeSel) {
    typeSel.addEventListener("change", async function() {
      var newType = this.value;
      if (newType === task.type) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/update", { fields: { type: newType } });
        showToast(tf("toast.type_changed", {value: newType}), "success");
        await _refreshAfterPanelEdit(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.type;
      }
    });
  }

  // Title inline edit
  var titleEl = document.getElementById("dp-title-edit");
  if (titleEl) {
    titleEl.addEventListener("click", function() {
      _inlineEdit(titleEl, task.title || "", function(newVal) {
        if (!newVal.trim()) { showToast(t("error.title_empty"), "error"); return Promise.reject(); }
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { title: newVal.trim() } })
          .then(function() {
            showToast(t("toast.title_updated"), "success");
            _refreshAfterPanelEdit(taskId);
          });
      });
    });
  }

  // Description inline edit
  var descEl = document.getElementById("dp-description");
  if (descEl) {
    descEl.addEventListener("click", function() {
      _inlineEditTextarea(descEl, task.description || "", function(newVal) {
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { description: newVal } })
          .then(function() {
            showToast(t("toast.description_updated"), "success");
            _refreshAfterPanelEdit(taskId);
          });
      });
    });
  }

  // Assigned to inline edit (with member chips)
  var assignEl = document.getElementById("dp-assigned");
  if (assignEl) {
    assignEl.addEventListener("click", function() {
      if (assignEl.dataset.editing === "true") return;
      assignEl.dataset.editing = "true";

      var wrapper = document.createElement("div");
      var row = document.createElement("div");
      row.className = "inline-edit";
      var input = document.createElement("input");
      input.type = "text";
      input.className = "form-control";
      input.value = task.assigned_to || "";
      var saveBtn = document.createElement("button");
      saveBtn.className = "btn btn-primary btn-sm";
      saveBtn.textContent = t("btn.save");
      var cancelBtn = document.createElement("button");
      cancelBtn.className = "btn btn-sm";
      cancelBtn.textContent = t("btn.cancel");

      row.appendChild(input);
      row.appendChild(saveBtn);
      row.appendChild(cancelBtn);
      wrapper.appendChild(row);

      var chips = buildMemberChips(input);
      wrapper.appendChild(chips);

      var parent = assignEl.parentNode;
      parent.replaceChild(wrapper, assignEl);
      input.focus();
      input.select();

      function cancel() { parent.replaceChild(assignEl, wrapper); assignEl.dataset.editing = "false"; }

      cancelBtn.addEventListener("click", cancel);
      input.addEventListener("keydown", function(e) {
        if (e.key === "Escape") cancel();
        if (e.key === "Enter") saveBtn.click();
      });
      saveBtn.addEventListener("click", function() {
        var assignedTo = input.value.trim() || null;
        apiPost("/api/tasks/" + taskId + "/assign", { assigned_to: assignedTo })
          .then(function() {
            showToast(assignedTo ? tf("toast.assigned", {value: assignedTo}) : t("toast.unassigned"), "success");
            _refreshAfterPanelEdit(taskId);
          })
          .catch(function(e) {
            showToast(e.message, "error");
            cancel();
          });
      });
    });
  }

  // Tags inline edit
  var tagsEl = document.getElementById("dp-tags");
  if (tagsEl) {
    tagsEl.addEventListener("click", function() {
      var tagStr = (task.tags && task.tags.length) ? task.tags.join(", ") : "";
      _inlineEdit(tagsEl, tagStr, function(newVal) {
        var newTags = newVal.split(",").map(function(t){ return t.trim(); }).filter(Boolean);
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { tags: newTags } })
          .then(function() {
            showToast(t("toast.tags_updated"), "success");
            _refreshAfterPanelEdit(taskId);
          });
      });
    });
  }

  // Comment submit
  var commentBtn = document.getElementById("dp-comment-submit");
  if (commentBtn) {
    commentBtn.addEventListener("click", async function() {
      if (commentBtn.disabled) return;
      var textarea = document.getElementById("dp-comment-text");
      var text = textarea.value.trim();
      if (!text) { showToast(t("error.comment_empty"), "error"); return; }
      commentBtn.disabled = true;
      try {
        await apiPost("/api/tasks/" + taskId + "/comment", { body: text });
        showToast(t("toast.comment_added"), "success");
        textarea.blur();
        textarea.value = "";
        await _refreshAfterPanelEdit(taskId);
      } catch(e) {
        showToast(e.message, "error");
      } finally {
        commentBtn.disabled = false;
      }
    });

    var commentTextarea = document.getElementById("dp-comment-text");
    if (commentTextarea) {
      commentTextarea.addEventListener("keydown", function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          commentBtn.click();
        }
      });
    }
  }

  // Archive button
  var archiveBtn = document.getElementById("dp-archive-btn");
  if (archiveBtn) {
    archiveBtn.addEventListener("click", async function() {
      if (!confirm("Archive this task? It will be moved to the archive.")) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/archive", {});
        showToast(t("toast.task_archived"), "success");
        closeDetailPanel();
        tasks = await api("/api/tasks");
        updateAllBadges();
        if (currentView === "board") renderBoard();
        else if (currentView === "list") { renderList(); }
      } catch(e) {
        showToast(e.message, "error");
      }
    });
  }
}

async function _refreshAfterPanelEdit(taskId) {
  // Re-fetch tasks to update board/list behind the panel
  tasks = await api("/api/tasks");
  updateAllBadges();

  // Re-render the underlying view
  if (currentView === "board") renderBoard();
  else if (currentView === "list") renderList();

  // Re-render panel content if still open and no active edit
  if (_detailPanelTaskId === taskId) {
    var body = document.getElementById("dp-body");
    // Skip if user is mid-edit (has an active input/textarea)
    if (body && !body.querySelector("input:focus, textarea:focus")) {
      var results = await Promise.all([
        api("/api/tasks/" + taskId),
        api("/api/tasks/" + taskId + "/events")
      ]);
      if (_detailPanelTaskId === taskId) {
        _renderPanelContent(taskId, results[0], results[1]);
      }
    }
  }
}

// Wire panel close handlers (once, at boot)
document.addEventListener("DOMContentLoaded", function() {
  var closeBtn = document.getElementById("dp-close");
  if (closeBtn) closeBtn.addEventListener("click", closeDetailPanel);

  // Escape key closes panel (unless user is in an active inline edit)
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape" && _detailPanelTaskId) {
      var active = document.activeElement;
      var inPanel = document.getElementById("detail-panel");
      // Don't close if user is typing in an input/textarea inside the panel
      if (active && inPanel && inPanel.contains(active) && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
      closeDetailPanel();
    }
  });
});

// --- Routing ---
async function route(hash) {
  var h = (hash || "/board").replace(/^#?\/?/, "/");
  var parts = h.split("/").filter(Boolean);
  var view = parts[0] || "board";

  // Close floating detail panel on any hash navigation
  if (_detailPanelTaskId) closeDetailPanel();

  // Clean up cube when navigating to a different main view
  if (currentView === "cube" && view !== "cube" && view !== "task") {
    cleanupCube();
  }
  // Clean up web when navigating to a different main view
  if (currentView === "web" && view !== "web" && view !== "task") {
    cleanupWeb();
  }

  currentView = view === "task" ? currentView : view;
  updateTabs();

  if (view === "board") renderBoard();
  else if (view === "list") renderList();
  else if (view === "activity") await renderActivity();
  else if (view === "stats") await renderStats();
  else if (view === "cube") await renderCube();
  else if (view === "web") await renderWeb();
  else if (view === "task" && parts[1]) await renderDetail(parts[1]);
  else renderBoard();
}

window.addEventListener("hashchange", function() { route(location.hash.slice(1)); });

// --- Dashboard config helpers ---
function getDashboardConfig() {
  return (config && config.dashboard) || {};
}

function getLaneColor(status) {
  var dc = getDashboardConfig();
  if (dc.lane_colors && dc.lane_colors[status]) return dc.lane_colors[status];
  var themeDefaults = LANE_COLORS_BY_THEME[getTheme()] || DEFAULT_LANE_COLORS;
  return themeDefaults[status] || "#6c757d";
}

function getBackgroundImage() {
  var dc = getDashboardConfig();
  return dc.background_image || "";
}

function getTheme() {
  var dc = getDashboardConfig();
  return dc.theme || "carbon";
}

function applyTheme(themeId) {
  document.documentElement.dataset.theme = themeId || "carbon";
}

function populateThemeSelector() {
  var select = document.getElementById("theme-select");
  if (!select) return;
  var current = getTheme();
  select.innerHTML = "";
  THEMES.forEach(function(t) {
    var opt = document.createElement("option");
    opt.value = t.id;
    opt.textContent = t.name;
    if (t.id === current) opt.selected = true;
    select.appendChild(opt);
  });
}

function getVoice() {
  var dc = getDashboardConfig();
  return dc.voice || "en-oracle";
}

function populateVoiceSelector() {
  var select = document.getElementById("voice-select");
  if (!select) return;
  var current = getVoice();
  select.innerHTML = "";
  Object.keys(VOICES).forEach(function(id) {
    var meta = VOICES[id]._meta || {};
    var opt = document.createElement("option");
    opt.value = id;
    opt.textContent = meta.label || id;
    if (id === current) opt.selected = true;
    select.appendChild(opt);
  });
}

function updateStaticVoiceStrings() {
  // Nav tabs
  document.querySelectorAll(".nav-tab").forEach(function(el) {
    var view = el.dataset.view;
    if (view === "board") el.textContent = t("nav.board");
    else if (view === "list") el.textContent = t("nav.list");
    else if (view === "activity") el.textContent = t("nav.activity");
    else if (view === "stats") el.textContent = t("nav.stats");
  });
  // New Task button
  var newBtn = document.getElementById("new-task-btn");
  if (newBtn) newBtn.textContent = t("btn.new_task");
  // Refresh button
  var refBtn = document.getElementById("refresh-btn");
  if (refBtn) refBtn.textContent = t("btn.refresh");
  // Help button
  var helpBtn = document.getElementById("help-btn");
  if (helpBtn) { helpBtn.title = t("btn.help_title"); helpBtn.lastChild.textContent = " " + t("btn.help"); }
  // Settings header
  var settingsHeader = document.querySelector(".settings-header span");
  if (settingsHeader) settingsHeader.textContent = t("settings.title");
  // Settings button title
  var settingsBtn = document.getElementById("settings-btn");
  if (settingsBtn) settingsBtn.title = t("btn.settings");
  // Loading text
  var loadingP = document.querySelector(".loading p");
  if (loadingP) loadingP.textContent = t("loading");
  // Settings labels and hints
  var themeLabel = document.querySelector('label[for="theme-select"]');
  if (themeLabel) themeLabel.textContent = t("settings.theme_label");
  var themeHint = document.querySelector('#theme-select + .hint, label[for="theme-select"] ~ .hint');
  if (!themeHint) {
    var themeGroup = document.getElementById("theme-select");
    if (themeGroup) themeHint = themeGroup.parentElement.querySelector(".hint");
  }
  if (themeHint) themeHint.textContent = t("settings.theme_hint");
  var voiceLabel = document.querySelector('label[for="voice-select"]');
  if (voiceLabel) voiceLabel.textContent = t("settings.voice_label");
  var voiceHint = document.getElementById("voice-select");
  if (voiceHint) {
    var vh = voiceHint.parentElement.querySelector(".hint");
    if (vh) vh.textContent = t("settings.voice_hint");
  }
  var bgLabel = document.querySelector('label[for="bg-image-input"]');
  if (bgLabel) bgLabel.textContent = t("settings.bg_label");
  var bgHint = document.getElementById("bg-image-input");
  if (bgHint) {
    var bh = bgHint.parentElement.querySelector(".hint");
    if (bh) bh.textContent = t("settings.bg_hint");
  }
  var bgSaveBtn = document.getElementById("bg-image-save");
  if (bgSaveBtn) bgSaveBtn.textContent = t("btn.apply");
  var bgClearBtn = document.getElementById("bg-image-clear");
  if (bgClearBtn) bgClearBtn.textContent = t("btn.clear");
  var laneLabelEl = document.querySelector('#lane-colors-list');
  if (laneLabelEl) {
    var lg = laneLabelEl.parentElement;
    var ll = lg.querySelector("label");
    if (ll) ll.textContent = t("settings.lane_label");
    var lh = lg.querySelector(".hint");
    if (lh) lh.textContent = t("settings.lane_hint");
  }
  var lcSaveBtn = document.getElementById("lane-colors-save");
  if (lcSaveBtn) lcSaveBtn.textContent = t("btn.apply_lane_colors");
  var lcResetBtn = document.getElementById("lane-colors-reset");
  if (lcResetBtn) lcResetBtn.textContent = t("btn.reset_defaults");
  // Create task modal static elements
  var modalHeader = document.querySelector("#create-task-modal .modal-header h2");
  if (modalHeader) modalHeader.textContent = t("modal.create_title");
  var ctCancelBtn = document.getElementById("create-task-cancel");
  if (ctCancelBtn) ctCancelBtn.textContent = t("btn.cancel");
  var ctSubmitBtn = document.getElementById("create-task-submit");
  if (ctSubmitBtn) ctSubmitBtn.textContent = t("btn.create_task");
  // Create task modal labels
  var ctTitleLabel = document.querySelector('label[for="ct-title"]');
  if (ctTitleLabel) ctTitleLabel.textContent = t("label.title");
  var ctTitleInput = document.getElementById("ct-title");
  if (ctTitleInput) ctTitleInput.placeholder = t("placeholder.title");
  var ctTypeLabel = document.querySelector('label[for="ct-type"]');
  if (ctTypeLabel) ctTypeLabel.textContent = t("label.type");
  var ctPriLabel = document.querySelector('label[for="ct-priority"]');
  if (ctPriLabel) ctPriLabel.textContent = t("label.priority");
  var ctDescLabel = document.querySelector('label[for="ct-description"]');
  if (ctDescLabel) ctDescLabel.textContent = t("label.description");
  var ctDescInput = document.getElementById("ct-description");
  if (ctDescInput) ctDescInput.placeholder = t("placeholder.description");
  var ctTagsLabel = document.querySelector('label[for="ct-tags"]');
  if (ctTagsLabel) ctTagsLabel.textContent = t("label.tags");
  var ctTagsInput = document.getElementById("ct-tags");
  if (ctTagsInput) ctTagsInput.placeholder = t("placeholder.tags");
  var ctAssignedLabel = document.querySelector('label[for="ct-assigned"]');
  if (ctAssignedLabel) ctAssignedLabel.textContent = t("label.assigned_to");
  var ctAssignedInput = document.getElementById("ct-assigned");
  if (ctAssignedInput) ctAssignedInput.placeholder = t("placeholder.assigned");
}

// --- Background image ---
function applyBackgroundImage() {
  var app = document.getElementById("app");
  var bg = getBackgroundImage();
  if (bg) {
    app.style.backgroundImage = "url(" + bg + ")";
    app.style.backgroundSize = "cover";
    app.style.backgroundPosition = "center";
    app.style.backgroundRepeat = "no-repeat";
    app.style.backgroundAttachment = "fixed";
    app.style.minHeight = "calc(100vh - 50px)";
  } else {
    app.style.backgroundImage = "";
    app.style.backgroundSize = "";
    app.style.backgroundPosition = "";
    app.style.backgroundRepeat = "";
    app.style.backgroundAttachment = "";
    app.style.minHeight = "";
  }
}

function loadColumnWidthSetting() {
  var dc = (config && config.dashboard) || {};
  var w = dc.column_width || 300;
  var slider = document.getElementById("col-width-slider");
  var label = document.getElementById("col-width-value");
  slider.value = w;
  label.textContent = w + "px";
  document.documentElement.style.setProperty("--col-min-w", w + "px");
}

function loadFontSizeSetting() {
  var dc = (config && config.dashboard) || {};
  var s = dc.font_size || 14;
  var slider = document.getElementById("font-size-slider");
  var label = document.getElementById("font-size-value");
  slider.value = s;
  label.textContent = s + "px";
  document.documentElement.style.setProperty("--card-font-size", s + "px");
}

function loadBackgroundSetting() {
  var input = document.getElementById("bg-image-input");
  input.value = getBackgroundImage();
  applyBackgroundImage();
}

// --- Lane color settings ---
function populateLaneColorSettings() {
  var container = document.getElementById("lane-colors-list");
  if (!config || !config.workflow) return;
  var statuses = config.workflow.statuses || [];
  var html = "";
  statuses.forEach(function(s) {
    var color = getLaneColor(s);
    html += '<div class="lane-color-row">';
    html += '<span class="lane-name">' + esc(s) + '</span>';
    html += '<input type="color" data-status="' + esc(s) + '" value="' + esc(color) + '">';
    html += '</div>';
  });
  container.innerHTML = html;
}

// --- Heat map configuration ---
// All heat timing and appearance knobs live here.
var HEAT_CONFIG = {
  // Duration (ms) for the bar to shrink from 100% to 0%.
  fullDurationMs: 3600000,       // 1 hour

  // Bar visual properties
  barWidth: 3,                   // px
  barBorderRadius: "0 1px 0 0",  // top-right corner only

  // Default color thresholds: checked in order, first match wins.
  // "upTo" is an upper bound in ms; null means "everything else".
  tiers: [
    { upTo: 60000,    cls: "heat-hot",     color: "#ef4444" },  // < 1 min — red
    { upTo: 600000,   cls: "heat-warm",    color: "#f97316" },  // < 10 min — orange
    { upTo: 3600000,  cls: "heat-cooling", color: "#eab308" },  // < 1 hr — yellow
    { upTo: null,     cls: "",             color: null }         // cold
  ],

  // Per-theme color overrides. Only the "color" field is overridden;
  // thresholds (upTo) and class names (cls) stay the same.
  themeColors: {
    // carbon: uses defaults (red / orange / yellow)
    // linear: uses defaults (clean indicator colors on white)
    vaporwave: ["#FF71CE", "#ffb347", "#01CDFE"],   // hot pink / neon orange / cyan
    matrix:    ["#39FF14", "#22aa10", "#145a08"],    // bright green / mid green / dim green
    holographic: ["#ff6b6b", "#ffd93d", "#6bccff"]   // pink / gold / cool blue
  },

  // How often (ms) to refresh heat bars between full data fetches.
  refreshIntervalMs: 5000
};

// --- Heat map helpers ---
function isHeatMapEnabled() {
  if (!config || !config.dashboard || config.dashboard.heat_map_enabled === undefined) return true;
  return !!config.dashboard.heat_map_enabled;
}

function getHeatTier(ts) {
  var cold = HEAT_CONFIG.tiers[HEAT_CONFIG.tiers.length - 1];
  if (!ts) return cold;
  var diffMs = Date.now() - new Date(ts).getTime();
  var theme = getTheme();
  var overrides = HEAT_CONFIG.themeColors[theme] || null;
  for (var i = 0; i < HEAT_CONFIG.tiers.length; i++) {
    var tier = HEAT_CONFIG.tiers[i];
    if (tier.upTo === null || diffMs < tier.upTo) {
      if (overrides && i < overrides.length && tier.color) {
        return { upTo: tier.upTo, cls: tier.cls, color: overrides[i] };
      }
      return tier;
    }
  }
  return cold;
}

function getHeatClass(ts) {
  return getHeatTier(ts).cls;
}

// Returns 0..1 (1 = just changed, 0 = fully cooled).
function getHeatBarRatio(ts) {
  if (!ts) return 0;
  var diffMs = Date.now() - new Date(ts).getTime();
  if (diffMs <= 0) return 1;
  if (diffMs >= HEAT_CONFIG.fullDurationMs) return 0;
  return 1 - (diffMs / HEAT_CONFIG.fullDurationMs);
}

// Build the CSS background value for a heat bar: solid at bottom, fading to transparent.
function heatBarBackground(color) {
  return "linear-gradient(to top, " + color + ", transparent)";
}

function loadHeatMapSetting() {
  var toggle = document.getElementById("heat-map-toggle");
  if (toggle) toggle.checked = isHeatMapEnabled();
}

// --- Board Card Helper ---
function formatHeatAge(ts) {
  if (!ts) return "no ts";
  var diff = Math.floor((Date.now() - new Date(ts).getTime()) / 1000);
  if (diff < 60) return diff + "s";
  if (diff < 3600) return Math.floor(diff / 60) + "m";
  if (diff < 86400) return Math.floor(diff / 3600) + "h";
  return Math.floor(diff / 86400) + "d";
}

function renderBoardCard(t) {
  var heatEnabled = isHeatMapEnabled();
  var heatCls = heatEnabled ? getHeatClass(t.last_status_changed_at) : "";
  var tier = heatEnabled ? getHeatTier(t.last_status_changed_at) : null;
  var ratio = heatEnabled ? getHeatBarRatio(t.last_status_changed_at) : 0;

  var html = '<div class="card' + (heatCls ? " " + heatCls : "") + '" draggable="true" data-task-id="' + esc(t.id) + '" data-task-status="' + esc(t.status || "") + '"';
  if (t.last_status_changed_at) html += ' data-heat-ts="' + esc(t.last_status_changed_at) + '"';
  html += ' ondragstart="window._boardDragStart(event)" ondragend="window._boardDragEnd(event)">';

  // Heat bar: vertical bar on left that shrinks as heat cools (gradient: solid at bottom, fading to transparent)
  if (heatEnabled && tier && tier.color && ratio > 0) {
    html += '<div class="heat-bar" style="background:' + heatBarBackground(tier.color) + ';height:' + (ratio * 100).toFixed(1) + '%;width:' + HEAT_CONFIG.barWidth + 'px"></div>';
  }

  if (t.short_id) {
    html += '<div style="font-size:.7rem;font-weight:600;color:var(--accent-primary);margin-bottom:2px;display:flex;align-items:center;gap:5px">';
    if (t.has_active_session) html += '<span class="active-dot" title="Actively being worked"></span>';
    html += esc(t.short_id);
    // Heat age indicator (text)
    if (heatEnabled && t.last_status_changed_at) {
      var heatColor = tier && tier.color ? tier.color : "var(--text-muted)";
      html += '<span style="font-size:.65rem;color:' + heatColor + ';font-weight:400" title="Last status change">' + formatHeatAge(t.last_status_changed_at) + '</span>';
    }
    html += '</div>';
  } else if (t.has_active_session) {
    html += '<div style="margin-bottom:2px"><span class="active-dot" title="Actively being worked"></span></div>';
  }
  html += '<div class="card-title">' + esc(t.title || "Untitled") + "</div>";
  html += '<div class="card-meta">';
  if (t.priority) html += '<span class="badge pri-' + esc(t.priority) + '">' + esc(t.priority) + "</span>";
  if (t.type) html += '<span class="badge type-badge">' + esc(t.type) + "</span>";
  if (t.has_active_session) html += '<span class="active-badge"><span class="active-dot"></span>Active</span>';
  if (t.assigned_to) html += '<span style="color:var(--text-muted);font-size:.8rem">' + esc(t.assigned_to) + "</span>";
  if (t.comment_count) html += '<span style="color:var(--text-muted);font-size:.75rem;margin-left:auto" title="' + t.comment_count + ' comment' + (t.comment_count === 1 ? '' : 's') + '">\uD83D\uDCAC ' + t.comment_count + "</span>";
  html += "</div></div>";
  return html;
}

// --- Board View ---
function renderBoard() {
  var app = document.getElementById("app");
  if (!config || !tasks) { app.innerHTML = '<div class="loading"><div class="spinner"></div></div>'; return; }

  applyBackgroundImage();

  var statuses = config.workflow ? config.workflow.statuses : [];
  if (tasks.length === 0) {
    app.innerHTML = '<div class="empty"><p>' + esc(t("empty.board")) + '</p><p><button class="btn btn-primary" onclick="window.open(\'https://thelattice.works/getting-started\', \'_blank\')">' + t("empty.board.cta") + '</button></p></div>';
    return;
  }

  var transitions = (config.workflow && config.workflow.transitions) || {};
  var grouped = {};
  statuses.forEach(function(s) { grouped[s] = []; });
  tasks.forEach(function(t) {
    var s = t.status || "unknown";
    if (!grouped[s]) grouped[s] = [];
    grouped[s].push(t);
  });

  var allStatuses = statuses.concat(Object.keys(grouped).filter(function(s) { return !statuses.includes(s); }));
  var colCount = allStatuses.length || 1;

  var html = '<div class="board-wrapper">';

  // Board columns
  html += '<div class="board-scroll-outer"><div class="board-scroll">';
  html += '<div class="board" style="grid-template-columns:repeat(' + colCount + ',var(--col-min-w))">';
  allStatuses.forEach(function(status) {
    var items = grouped[status] || [];
    var cls = "status-" + status.replace(/\s+/g,"_");
    var laneColor = getLaneColor(status);
    html += '<div class="board-col ' + cls + '" data-status="' + esc(status) + '"';
    html += ' ondragover="window._boardDragOver(event)" ondragleave="window._boardDragLeave(event)" ondrop="window._boardDrop(event)">';
    html += '<div class="board-col-header" style="background:' + esc(laneColor) + ';color:var(--text-on-lane)" title="' + esc(getStatusDescription(status)) + '">';
    html += '<span>' + esc(getStatusDisplayName(status)) + '</span>';
    html += '<span class="count">' + items.length + '</span>';
    html += '</div>';
    html += '<div class="board-col-body">';
    if (status === "done" && items.length > 0) {
      // Sub-group done tasks by done_at into "Done Today" and "Done Yesterday"
      var now = new Date();
      var todayStr = now.toISOString().slice(0, 10);
      var yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      var yesterdayStr = yesterday.toISOString().slice(0, 10);
      var doneToday = [];
      var doneYesterday = [];
      items.forEach(function(item) {
        var doneAt = item.done_at;
        if (doneAt && doneAt.slice(0, 10) === todayStr) {
          doneToday.push(item);
        } else if (doneAt && doneAt.slice(0, 10) === yesterdayStr) {
          doneYesterday.push(item);
        } else {
          // Legacy tasks or older — put in yesterday bucket
          doneYesterday.push(item);
        }
      });
      if (doneToday.length > 0) {
        html += '<div class="board-sub-header">Done Today <span class="count">' + doneToday.length + '</span></div>';
        doneToday.forEach(function(t) { html += renderBoardCard(t); });
      }
      if (doneYesterday.length > 0) {
        html += '<div class="board-sub-header">Done Yesterday <span class="count">' + doneYesterday.length + '</span></div>';
        doneYesterday.forEach(function(t) { html += renderBoardCard(t); });
      }
      if (doneToday.length === 0 && doneYesterday.length === 0) {
        html += '<div style="color:var(--text-muted);font-size:.8rem;padding:8px;text-align:center">' + esc(t("empty.lane")) + '</div>';
      }
    } else {
      items.forEach(function(t) { html += renderBoardCard(t); });
      if (items.length === 0) html += '<div style="color:var(--text-muted);font-size:.8rem;padding:8px;text-align:center">' + esc(t("empty.lane")) + '</div>';
    }
    html += "</div></div>";
  });
  html += "</div>"; // close .board
  html += "</div></div>"; // close .board-scroll + .board-scroll-outer
  html += "</div>"; // close .board-wrapper

  app.innerHTML = html;

  // Add click handlers for card → floating detail panel (separate from drag)
  app.querySelectorAll(".card").forEach(function(card) {
    card.addEventListener("click", function(e) {
      // Only open panel if this was a real click, not end of drag
      if (!card.classList.contains("was-dragged")) {
        openDetailPanel(card.dataset.taskId);
      }
      card.classList.remove("was-dragged");
    });
  });

  // Board horizontal scroll — edge shadow indicators
  var scrollEl = app.querySelector(".board-scroll");
  var outerEl = app.querySelector(".board-scroll-outer");
  if (scrollEl && outerEl) {
    var updateShadows = function() {
      var sl = scrollEl.scrollLeft;
      var maxScroll = scrollEl.scrollWidth - scrollEl.clientWidth;
      outerEl.classList.toggle("shadow-left", sl > 2);
      outerEl.classList.toggle("shadow-right", sl < maxScroll - 2);
    };
    scrollEl.addEventListener("scroll", updateShadows, { passive: true });
    // Initial check (deferred so layout is settled)
    requestAnimationFrame(updateShadows);
    // Re-check on resize
    window.addEventListener("resize", updateShadows, { passive: true });
  }

}

// --- Drag and Drop ---
window._boardDragStart = function(e) {
  var card = e.target.closest(".card");
  if (!card) return;
  // Close detail panel when user starts dragging
  if (_detailPanelTaskId) closeDetailPanel();
  draggedTaskId = card.dataset.taskId;
  draggedFromStatus = card.dataset.taskStatus;
  card.classList.add("dragging");
  e.dataTransfer.effectAllowed = "move";
  e.dataTransfer.setData("text/plain", draggedTaskId);

  // Highlight valid drop targets
  var transitions = (config.workflow && config.workflow.transitions) || {};
  var allowedTargets = transitions[draggedFromStatus] || [];
  setTimeout(function() {
    document.querySelectorAll(".board-col").forEach(function(col) {
      var colStatus = col.dataset.status;
      if (colStatus === draggedFromStatus) return;
      if (allowedTargets.includes(colStatus)) {
        col.style.opacity = "1";
      } else {
        col.style.opacity = "0.5";
      }
    });
  }, 0);
};

window._boardDragEnd = function(e) {
  var card = e.target.closest(".card");
  if (card) {
    card.classList.remove("dragging");
    card.classList.add("was-dragged");
  }
  draggedTaskId = null;
  draggedFromStatus = null;
  document.querySelectorAll(".board-col").forEach(function(col) {
    col.classList.remove("drag-over", "drag-invalid");
    col.style.opacity = "";
  });
};

window._boardDragOver = function(e) {
  e.preventDefault();
  var col = e.target.closest(".board-col");
  if (!col || !draggedFromStatus) return;
  var targetStatus = col.dataset.status;
  if (targetStatus === draggedFromStatus) return;

  var transitions = (config.workflow && config.workflow.transitions) || {};
  var allowed = transitions[draggedFromStatus] || [];
  if (allowed.includes(targetStatus)) {
    e.dataTransfer.dropEffect = "move";
    col.classList.add("drag-over");
    col.classList.remove("drag-invalid");
  } else {
    e.dataTransfer.dropEffect = "none";
    col.classList.add("drag-invalid");
    col.classList.remove("drag-over");
  }
};

window._boardDragLeave = function(e) {
  var col = e.target.closest(".board-col");
  if (col) {
    col.classList.remove("drag-over", "drag-invalid");
  }
};

window._boardDrop = async function(e) {
  e.preventDefault();
  var col = e.target.closest(".board-col");
  if (!col || !draggedTaskId || !draggedFromStatus) return;

  var targetStatus = col.dataset.status;
  col.classList.remove("drag-over", "drag-invalid");

  if (targetStatus === draggedFromStatus) return;

  var transitions = (config.workflow && config.workflow.transitions) || {};
  var allowed = transitions[draggedFromStatus] || [];
  if (!allowed.includes(targetStatus)) {
    showToast(tf("toast.invalid_transition", {from: draggedFromStatus, to: targetStatus}), "error");
    return;
  }

  try {
    await apiPost("/api/tasks/" + draggedTaskId + "/status", {
      status: targetStatus,
      actor: "dashboard:web"
    });
    showToast(tf("toast.moved_to", {status: targetStatus}), "success");
    // Refresh tasks and re-render
    tasks = await api("/api/tasks");
    updateAllBadges();
    renderBoard();
  } catch(err) {
    showToast(err.message, "error");
  }
};

// --- List View ---
function renderList() {
  var app = document.getElementById("app");
  if (!config) return;

  var statuses = config.workflow ? config.workflow.statuses : [];
  var types = config.task_types || [];

  var html = '<div class="filters">';
  html += '<input type="text" id="f-search" placeholder="' + esc(t("filter.search")) + '">';
  html += '<select id="f-status"><option value="">' + esc(t("filter.all_statuses")) + '</option>';
  statuses.forEach(function(s) { html += '<option value="'+esc(s)+'">'+esc(s)+"</option>"; });
  html += "</select>";
  html += '<select id="f-type"><option value="">' + esc(t("filter.all_types")) + '</option>';
  types.forEach(function(ty) { html += '<option value="'+esc(ty)+'">'+esc(ty)+"</option>"; });
  html += "</select>";
  html += '<select id="f-priority"><option value="">' + esc(t("filter.all_priorities")) + '</option>';
  ["critical","high","medium","low"].forEach(function(p) { html += '<option value="'+p+'">'+p+"</option>"; });
  html += "</select>";
  html += '<label><input type="checkbox" id="f-archived"> ' + esc(t("filter.show_archived")) + '</label>';
  html += "</div>";
  html += '<div id="list-table"></div>';
  app.innerHTML = html;

  document.getElementById("f-search").addEventListener("input", applyListFilters);
  document.getElementById("f-status").addEventListener("change", applyListFilters);
  document.getElementById("f-type").addEventListener("change", applyListFilters);
  document.getElementById("f-priority").addEventListener("change", applyListFilters);
  document.getElementById("f-archived").addEventListener("change", async function() {
    if (this.checked && archivedTasks === null) {
      try { archivedTasks = await api("/api/archived"); } catch(e) { archivedTasks = []; }
    }
    applyListFilters();
  });

  // If a global nav search was submitted, populate the search box
  if (pendingSearch) {
    document.getElementById("f-search").value = pendingSearch;
    pendingSearch = null;
  }

  applyListFilters();
}

function applyListFilters() {
  var search = (document.getElementById("f-search").value || "").trim().toLowerCase();
  var status = document.getElementById("f-status").value;
  var type = document.getElementById("f-type").value;
  var priority = document.getElementById("f-priority").value;
  var showArchived = document.getElementById("f-archived").checked;

  var items = tasks.slice();
  if (showArchived && archivedTasks) items = items.concat(archivedTasks);

  items = items.filter(function(t) {
    if (search) {
      var titleMatch = (t.title||"").toLowerCase().includes(search);
      // Bare number: exact match on numeric suffix only (e.g. "50" → LAT-50, not LAT-150)
      var bareNum = /^\d+$/.test(search);
      var shortIdMatch = bareNum
        ? (t.short_id && t.short_id.toLowerCase().endsWith("-" + search))
        : (t.short_id||"").toLowerCase().includes(search);
      if (!titleMatch && !shortIdMatch) return false;
    }
    if (status && t.status !== status) return false;
    if (type && t.type !== type) return false;
    if (priority && t.priority !== priority) return false;
    return true;
  });

  if (items.length === 0 && tasks.length === 0) {
    document.getElementById("list-table").innerHTML = '<div class="empty"><p>' + esc(t("empty.list")) + '</p></div>';
    return;
  }
  if (items.length === 0) {
    document.getElementById("list-table").innerHTML = '<div class="empty"><p>' + esc(t("empty.list.filtered")) + '</p></div>';
    return;
  }

  var html = "<table><thead><tr>";
  html += "<th>" + esc(t("table.id")) + "</th><th>" + esc(t("table.title")) + "</th><th>" + esc(t("table.status")) + "</th><th>" + esc(t("table.priority")) + "</th><th>" + esc(t("table.type")) + "</th><th>" + esc(t("table.assigned")) + "</th><th>" + esc(t("table.updated")) + "</th>";
  html += "</tr></thead><tbody>";
  items.forEach(function(t) {
    var displayId = t.short_id || (t.id ? t.id.slice(0,18) + "..." : "?");
    var updated = t.updated_at ? t.updated_at.slice(0,16).replace("T"," ") : "";
    var rowHeatCls = isHeatMapEnabled() ? " " + getHeatClass(t.last_status_changed_at) : "";
    var rowTier = isHeatMapEnabled() ? getHeatTier(t.last_status_changed_at) : null;
    var rowHeatBorder = (rowTier && rowTier.color) ? ' style="border-left:3px solid ' + rowTier.color + '"' : "";
    html += '<tr class="' + rowHeatCls.trim() + '" style="cursor:pointer" onclick="openDetailPanel(\'' + esc(t.id) + '\')">';
    html += '<td class="id-cell"' + rowHeatBorder + ' title="' + esc(t.id) + '">' + (t.short_id ? '<span style="font-weight:600;color:var(--accent-primary)">' + esc(t.short_id) + '</span>' : esc(displayId)) + "</td>";
    html += "<td>" + esc(t.title || "Untitled") + (t.archived ? ' <span class="archived-badge">archived</span>' : "") + (t.comment_count ? ' <span style="color:var(--text-muted);font-size:.75rem" title="' + t.comment_count + ' comment' + (t.comment_count === 1 ? '' : 's') + '">\uD83D\uDCAC ' + t.comment_count + '</span>' : '') + "</td>";
    html += "<td>" + esc(t.status || "") + (t.has_active_session ? ' <span class="active-badge"><span class="active-dot"></span>Active</span>' : "") + "</td>";
    html += "<td>";
    if (t.priority) html += '<span class="badge pri-' + esc(t.priority) + '">' + esc(t.priority) + "</span>";
    html += "</td>";
    html += "<td>" + esc(t.type || "") + "</td>";
    html += "<td>" + esc(t.assigned_to || "") + "</td>";
    html += "<td>" + esc(updated) + "</td>";
    html += "</tr>";
  });
  html += "</tbody></table>";
  document.getElementById("list-table").innerHTML = '<div style="overflow-x:auto">' + html + '</div>';
}

// --- Detail View ---
var _detailTaskId = null;
var _detailPanelTaskId = null;
var _detailPanelTrigger = null;

async function renderDetail(taskId) {
  var app = document.getElementById("app");
  app.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  _detailTaskId = taskId;

  try {
    var results = await Promise.all([
      api("/api/tasks/" + taskId),
      api("/api/tasks/" + taskId + "/events")
    ]);
    var task = results[0];
    var events = results[1];
    var isArchived = !!task.archived;

    var html = '<a href="#/' + esc(currentView) + '" class="back-link">' + t("btn.back") + '</a>';
    html += '<div class="detail">';

    // --- Title (inline editable) ---
    html += '<div class="detail-header">';
    if (isArchived) {
      html += '<div class="detail-title">' + esc(task.title || "Untitled") + ' <span class="archived-badge">ARCHIVED</span></div>';
    } else {
      html += '<div class="detail-title editable" id="detail-title" title="Click to edit">' + esc(task.title || "Untitled") + '</div>';
    }
    if (task.has_active_session) html += '<div style="margin-bottom:8px"><span class="active-badge"><span class="active-dot"></span>Actively being worked</span></div>';

    // --- Status + Action bar ---
    if (!isArchived) {
      html += '<div class="detail-actions">';
      // Status dropdown
      var transitions = (config && config.workflow && config.workflow.transitions) || {};
      var allowed = transitions[task.status] || [];
      html += '<select id="detail-status" title="Change status">';
      html += '<option value="' + esc(task.status) + '" selected>' + esc(getStatusDisplayName(task.status)) + '</option>';
      allowed.forEach(function(s) {
        html += '<option value="' + esc(s) + '">' + esc(getStatusDisplayName(s)) + '</option>';
      });
      html += '</select>';

      // Priority dropdown
      html += '<select id="detail-priority" title="Change priority">';
      ["critical","high","medium","low"].forEach(function(p) {
        html += '<option value="' + esc(p) + '"' + (p === task.priority ? ' selected' : '') + '>' + esc(p) + '</option>';
      });
      html += '</select>';

      // Type dropdown
      var types = (config && config.task_types) || [];
      html += '<select id="detail-type" title="Change type">';
      types.forEach(function(ty) {
        html += '<option value="' + esc(ty) + '"' + (ty === task.type ? ' selected' : '') + '>' + esc(ty) + '</option>';
      });
      html += '</select>';

      // Archive button
      html += '<button class="btn btn-danger btn-sm" id="detail-archive-btn">' + esc(t("btn.archive")) + '</button>';
      html += '</div>';
    } else {
      html += '<div class="detail-meta">';
      if (task.status) html += '<span class="badge badge-stat" title="' + esc(getStatusDescription(task.status)) + '">' + esc(getStatusDisplayName(task.status)) + '</span>';
      if (task.priority) html += '<span class="badge pri-' + esc(task.priority) + '">' + esc(task.priority) + '</span>';
      if (task.type) html += '<span class="badge type-badge">' + esc(task.type) + '</span>';
      html += '</div>';
    }
    html += '</div>';

    // --- Info fields ---
    html += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:8px">';
    if (task.short_id) html += '<div class="detail-field"><dt>' + esc(t("detail.short_id")) + '</dt><dd style="font-weight:600;color:var(--accent-primary)">' + esc(task.short_id) + '</dd></div>';
    var truncId = task.id && task.id.length > 12 ? task.id.slice(0, 12) + "\u2026" : (task.id || "");
    html += '<div class="detail-field" id="tech-id-field"><dt>' + esc(t("detail.tech_id")) + '</dt><dd id="tech-id-value" data-full="' + esc(task.id) + '" data-short="' + esc(truncId) + '" data-expanded="0" style="font-family:monospace;font-size:.8rem;cursor:pointer">' + esc(truncId) + '</dd></div>';

    // Assigned to (editable)
    if (!isArchived) {
      html += '<div class="detail-field"><dt>' + esc(t("detail.assigned_to")) + '</dt><dd>';
      html += '<span class="editable" id="detail-assigned" title="Click to edit">' + esc(task.assigned_to || t("detail.unassigned")) + '</span>';
      html += '</dd></div>';
    } else {
      html += '<div class="detail-field"><dt>' + esc(t("detail.assigned_to")) + '</dt><dd title="' + esc(task.assigned_to || t("detail.unassigned")) + '">' + esc(task.assigned_to || t("detail.unassigned")) + '</dd></div>';
    }

    var infoFields = [
      [t("detail.created_by"), task.created_by], [t("detail.created"), task.created_at], [t("detail.updated"), task.updated_at],
      [t("detail.urgency"), task.urgency]
    ];
    infoFields.forEach(function(pair) {
      if (pair[1]) {
        html += '<div class="detail-field"><dt>' + esc(pair[0]) + '</dt><dd title="' + esc(String(pair[1])) + '">' + esc(String(pair[1])) + '</dd></div>';
      }
    });
    html += '</div>';

    // --- Description (editable) ---
    html += '<div class="detail-section"><h3>' + esc(t("section.description")) + '</h3>';
    if (!isArchived) {
      html += '<pre class="editable" id="detail-description" style="white-space:pre-wrap;font-size:.9rem;min-height:20px" title="Click to edit">' + esc(task.description || t("detail.no_description")) + '</pre>';
    } else {
      html += '<pre style="white-space:pre-wrap;font-size:.9rem">' + esc(task.description || "") + '</pre>';
    }
    html += '</div>';

    // --- Tags (editable) ---
    html += '<div class="detail-section"><h3>' + esc(t("section.tags")) + '</h3>';
    if (!isArchived) {
      var tagStr = (task.tags && task.tags.length) ? task.tags.join(", ") : "";
      html += '<span class="editable" id="detail-tags" title="Click to edit">' + esc(tagStr || t("detail.no_tags")) + '</span>';
    } else if (task.tags && task.tags.length) {
      html += '<div>';
      task.tags.forEach(function(tag) { html += '<span class="badge badge-stat" style="margin-right:4px">' + esc(tag) + '</span>'; });
      html += '</div>';
    }
    html += '</div>';

    if (task.custom_fields && Object.keys(task.custom_fields).length) {
      html += '<div class="detail-section"><h3>' + esc(t("section.custom_fields")) + '</h3><dl>';
      Object.entries(task.custom_fields).forEach(function(pair) {
        html += '<dt>' + esc(pair[0]) + '</dt><dd>' + esc(String(pair[1])) + '</dd>';
      });
      html += '</dl></div>';
    }

    // Relationships
    if (task.relationships_out && task.relationships_out.length) {
      html += '<div class="detail-section"><h3>' + esc(t("section.relationships")) + '</h3><ul class="rel-list">';
      task.relationships_out.forEach(function(r) {
        html += '<li>' + esc(r.type) + ' &rarr; <a href="#/task/' + esc(r.target_task_id) + '">' + esc(r.target_task_id) + '</a>';
        if (r.note) html += ' (' + esc(r.note) + ')';
        html += '</li>';
      });
      html += '</ul></div>';
    }

    // Artifacts
    if (task.artifacts && task.artifacts.length) {
      html += '<div class="detail-section"><h3>' + esc(t("section.artifacts")) + '</h3><ul class="art-list">';
      task.artifacts.forEach(function(a) {
        html += '<li>' + esc(a.id);
        if (a.title) html += ' "' + esc(a.title) + '"';
        if (a.type) html += ' (' + esc(a.type) + ')';
        html += '</li>';
      });
      html += '</ul></div>';
    }

    // Plan — always visible, server scaffolds if file doesn't exist yet
    html += '<div class="detail-section"><h3>' + esc(t("section.plans")) + '</h3>';
    html += '<button class="btn btn-primary btn-sm" onclick="openPlans(\'' + esc(task.id) + '\')" style="margin-top:4px">' + esc(t("btn.show_plan")) + '</button>';
    if (task.plan_exists) {
      html += '<p style="font-size:.75rem;color:var(--text-muted);margin-top:6px"><code>plans/' + esc(task.id) + '.md</code></p>';
    }
    html += '</div>';

    // Notes
    if (task.notes_exists) {
      html += '<div class="detail-section"><h3>' + esc(t("section.notes")) + '</h3>';
      html += '<button class="btn btn-primary btn-sm" onclick="openNotes(\'' + esc(task.id) + '\')" style="margin-top:4px">' + esc(t("btn.show_notes")) + '</button>';
      html += '<p style="font-size:.75rem;color:var(--text-muted);margin-top:6px"><code>notes/' + esc(task.id) + '.md</code></p>';
      html += '</div>';
    }

    // --- Comments section ---
    var comments = (events || []).filter(function(ev) { return ev.type === "comment_added"; });
    html += '<div class="detail-section"><h3>' + esc(t("section.comments")) + ' (' + comments.length + ')</h3>';
    if (!isArchived) {
      html += '<div class="comment-form">';
      html += '<textarea class="form-control" id="detail-comment-text" placeholder="' + esc(t("placeholder.comment")) + '"></textarea>';
      html += '<button class="btn btn-primary btn-sm" id="detail-comment-submit" style="align-self:flex-end">' + esc(t("btn.post")) + '</button>';
      html += '</div>';
    }
    if (comments.length) {
      html += '<div style="margin-top:8px">';
      comments.forEach(function(ev) {
        html += '<div class="comment-item">';
        html += '<div class="comment-meta">' + esc(ev.actor || "") + ' &middot; ' + esc(ev.ts || "") + '</div>';
        html += '<div class="comment-body">' + esc((ev.data && ev.data.body) || "") + '</div>';
        html += '</div>';
      });
      html += '</div>';
    }
    html += '</div>';

    // --- Events (non-comment) ---
    var nonCommentEvents = (events || []).filter(function(ev) { return ev.type !== "comment_added"; });
    if (nonCommentEvents.length) {
      html += '<div class="detail-section"><h3>' + esc(t("section.history")) + ' (' + nonCommentEvents.length + ')</h3>';
      nonCommentEvents.forEach(function(ev) {
        html += '<div class="event-item">';
        html += '<span class="event-ts">' + esc(ev.ts || "") + '</span>';
        html += '<span class="event-type badge badge-stat">' + esc(ev.type || "") + '</span>';
        html += '<span>' + eventSummary(ev) + '</span>';
        html += '<span class="event-actor">' + esc(ev.actor || "") + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    html += '</div>';
    app.innerHTML = html;

    // Wire up interactive elements
    if (!isArchived) {
      _wireDetailActions(taskId, task);
    }

  } catch(e) {
    app.innerHTML = '<a href="#/' + esc(currentView) + '" class="back-link">' + t("btn.back") + '</a>' +
      '<div class="error-box"><p>' + esc(e.message) + '</p><button class="btn" onclick="location.reload()">' + esc(t("btn.retry")) + '</button></div>';
  }
}

// Wire up detail view interactive controls
function _wireDetailActions(taskId, task) {
  // Status change
  var statusSel = document.getElementById("detail-status");
  if (statusSel) {
    statusSel.addEventListener("change", async function() {
      var newStatus = this.value;
      if (newStatus === task.status) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/status", { status: newStatus });
        showToast(tf("toast.status_changed", {status: getStatusDisplayName(newStatus)}), "success");
        tasks = await api("/api/tasks");
        updateAllBadges();
        renderDetail(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.status;
      }
    });
  }

  // Priority change
  var priSel = document.getElementById("detail-priority");
  if (priSel) {
    priSel.addEventListener("change", async function() {
      var newPri = this.value;
      if (newPri === task.priority) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/update", { fields: { priority: newPri } });
        showToast(tf("toast.priority_changed", {value: newPri}), "success");
        tasks = await api("/api/tasks");
        updateAllBadges();
        renderDetail(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.priority;
      }
    });
  }

  // Type change
  var typeSel = document.getElementById("detail-type");
  if (typeSel) {
    typeSel.addEventListener("change", async function() {
      var newType = this.value;
      if (newType === task.type) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/update", { fields: { type: newType } });
        showToast(tf("toast.type_changed", {value: newType}), "success");
        tasks = await api("/api/tasks");
        updateAllBadges();
        renderDetail(taskId);
      } catch(e) {
        showToast(e.message, "error");
        this.value = task.type;
      }
    });
  }

  // Title inline edit
  var titleEl = document.getElementById("detail-title");
  if (titleEl) {
    titleEl.addEventListener("click", function() {
      _inlineEdit(titleEl, task.title || "", function(newVal) {
        if (!newVal.trim()) { showToast(t("error.title_empty"), "error"); return Promise.reject(); }
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { title: newVal.trim() } })
          .then(function() {
            showToast(t("toast.title_updated"), "success");
            api("/api/tasks").then(function(t) { tasks = t; updateAllBadges(); });
            renderDetail(taskId);
          });
      });
    });
  }

  // Description inline edit
  var descEl = document.getElementById("detail-description");
  if (descEl) {
    descEl.addEventListener("click", function() {
      var currentVal = task.description || "";
      _inlineEditTextarea(descEl, currentVal, function(newVal) {
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { description: newVal } })
          .then(function() {
            showToast(t("toast.description_updated"), "success");
            renderDetail(taskId);
          });
      });
    });
  }

  // Assigned to inline edit (with member chips)
  var assignEl = document.getElementById("detail-assigned");
  if (assignEl) {
    assignEl.addEventListener("click", function() {
      if (assignEl.dataset.editing === "true") return;
      assignEl.dataset.editing = "true";

      var wrapper = document.createElement("div");
      var row = document.createElement("div");
      row.className = "inline-edit";
      var input = document.createElement("input");
      input.type = "text";
      input.className = "form-control";
      input.value = task.assigned_to || "";
      var saveBtn = document.createElement("button");
      saveBtn.className = "btn btn-primary btn-sm";
      saveBtn.textContent = t("btn.save");
      var cancelBtn = document.createElement("button");
      cancelBtn.className = "btn btn-sm";
      cancelBtn.textContent = t("btn.cancel");

      row.appendChild(input);
      row.appendChild(saveBtn);
      row.appendChild(cancelBtn);
      wrapper.appendChild(row);

      // Add member chips
      var chips = buildMemberChips(input);
      wrapper.appendChild(chips);

      var parent = assignEl.parentNode;
      parent.replaceChild(wrapper, assignEl);
      input.focus();
      input.select();

      function cancel() { parent.replaceChild(assignEl, wrapper); assignEl.dataset.editing = "false"; }

      cancelBtn.addEventListener("click", cancel);
      input.addEventListener("keydown", function(e) {
        if (e.key === "Escape") cancel();
        if (e.key === "Enter") saveBtn.click();
      });
      saveBtn.addEventListener("click", function() {
        var assignedTo = input.value.trim() || null;
        apiPost("/api/tasks/" + taskId + "/assign", { assigned_to: assignedTo })
          .then(function() {
            showToast(assignedTo ? tf("toast.assigned", {value: assignedTo}) : t("toast.unassigned"), "success");
            api("/api/tasks").then(function(t) { tasks = t; updateAllBadges(); });
            renderDetail(taskId);
          })
          .catch(function(e) {
            showToast(e.message, "error");
            cancel();
          });
      });
    });
  }

  // Tags inline edit
  var tagsEl = document.getElementById("detail-tags");
  if (tagsEl) {
    tagsEl.addEventListener("click", function() {
      var tagStr = (task.tags && task.tags.length) ? task.tags.join(", ") : "";
      _inlineEdit(tagsEl, tagStr, function(newVal) {
        var newTags = newVal.split(",").map(function(t){ return t.trim(); }).filter(Boolean);
        return apiPost("/api/tasks/" + taskId + "/update", { fields: { tags: newTags } })
          .then(function() {
            showToast(t("toast.tags_updated"), "success");
            api("/api/tasks").then(function(t) { tasks = t; updateAllBadges(); });
            renderDetail(taskId);
          });
      });
    });
  }

  // Comment submit
  var commentBtn = document.getElementById("detail-comment-submit");
  if (commentBtn) {
    commentBtn.addEventListener("click", async function() {
      if (commentBtn.disabled) return;
      var textarea = document.getElementById("detail-comment-text");
      var text = textarea.value.trim();
      if (!text) { showToast(t("error.comment_empty"), "error"); return; }
      commentBtn.disabled = true;
      try {
        await apiPost("/api/tasks/" + taskId + "/comment", { body: text });
        showToast(t("toast.comment_added"), "success");
        renderDetail(taskId);
      } catch(e) {
        showToast(e.message, "error");
      } finally {
        commentBtn.disabled = false;
      }
    });

    // Ctrl+Enter to submit
    document.getElementById("detail-comment-text").addEventListener("keydown", function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        commentBtn.click();
      }
    });
  }

  // Archive button
  var archiveBtn = document.getElementById("detail-archive-btn");
  if (archiveBtn) {
    archiveBtn.addEventListener("click", async function() {
      if (!confirm("Archive this task? It will be moved to the archive.")) return;
      try {
        await apiPost("/api/tasks/" + taskId + "/archive", {});
        showToast(t("toast.task_archived"), "success");
        tasks = await api("/api/tasks");
        updateAllBadges();
        location.hash = "#/" + currentView;
      } catch(e) {
        showToast(e.message, "error");
      }
    });
  }

  var techIdVal = document.getElementById("tech-id-value");
  if (techIdVal) {
    techIdVal.addEventListener("click", function(e) {
      e.stopPropagation();
      var d = this, p = d.parentElement;
      if (d.dataset.expanded === "0") {
        d.textContent = d.dataset.full;
        d.style.wordBreak = "break-all";
        p.style.gridColumn = "1 / -1";
        d.dataset.expanded = "1";
      } else {
        d.textContent = d.dataset.short;
        d.style.wordBreak = "";
        p.style.gridColumn = "";
        d.dataset.expanded = "0";
      }
    });
  }
}

// Inline edit: replaces element with input field
function _inlineEdit(el, currentValue, onSave) {
  if (el.dataset.editing === "true") return;
  el.dataset.editing = "true";

  var wrapper = document.createElement("div");
  wrapper.className = "inline-edit";
  var input = document.createElement("input");
  input.type = "text";
  input.className = "form-control";
  input.value = currentValue;
  var saveBtn = document.createElement("button");
  saveBtn.className = "btn btn-primary btn-sm";
  saveBtn.textContent = t("btn.save");
  var cancelBtn = document.createElement("button");
  cancelBtn.className = "btn btn-sm";
  cancelBtn.textContent = t("btn.cancel");

  wrapper.appendChild(input);
  wrapper.appendChild(saveBtn);
  wrapper.appendChild(cancelBtn);

  var parent = el.parentNode;
  parent.replaceChild(wrapper, el);
  input.focus();
  input.select();

  function cancel() { parent.replaceChild(el, wrapper); el.dataset.editing = "false"; }

  cancelBtn.addEventListener("click", cancel);
  input.addEventListener("keydown", function(e) {
    if (e.key === "Escape") cancel();
    if (e.key === "Enter") saveBtn.click();
  });
  saveBtn.addEventListener("click", function() {
    var result = onSave(input.value);
    if (result && result.catch) {
      result.catch(function() { cancel(); });
    }
  });
}

// Inline edit: textarea variant for multiline fields
function _inlineEditTextarea(el, currentValue, onSave) {
  if (el.dataset.editing === "true") return;
  el.dataset.editing = "true";

  var wrapper = document.createElement("div");
  var textarea = document.createElement("textarea");
  textarea.className = "form-control";
  textarea.value = currentValue;
  textarea.style.minHeight = "100px";
  var btnRow = document.createElement("div");
  btnRow.style.cssText = "display:flex;gap:6px;margin-top:6px;justify-content:flex-end";
  var saveBtn = document.createElement("button");
  saveBtn.className = "btn btn-primary btn-sm";
  saveBtn.textContent = t("btn.save");
  var cancelBtn = document.createElement("button");
  cancelBtn.className = "btn btn-sm";
  cancelBtn.textContent = t("btn.cancel");

  btnRow.appendChild(cancelBtn);
  btnRow.appendChild(saveBtn);
  wrapper.appendChild(textarea);
  wrapper.appendChild(btnRow);

  var parent = el.parentNode;
  parent.replaceChild(wrapper, el);
  textarea.focus();

  function cancel() { parent.replaceChild(el, wrapper); el.dataset.editing = "false"; }

  cancelBtn.addEventListener("click", cancel);
  textarea.addEventListener("keydown", function(e) {
    if (e.key === "Escape") cancel();
    if ((e.ctrlKey || e.metaKey) && e.key === "Enter") saveBtn.click();
  });
  saveBtn.addEventListener("click", function() {
    var result = onSave(textarea.value);
    if (result && result.catch) {
      result.catch(function() { cancel(); });
    }
  });
}

function eventSummary(ev) {
  var d = ev.data || {};
  switch(ev.type) {
    case "task_created": return esc(d.title || "");
    case "status_changed": return esc(getStatusDisplayName(d.from||"?") + " \u2192 " + getStatusDisplayName(d.to||"?"));
    case "assignment_changed": return esc((d.from||"unassigned") + " \u2192 " + (d.to||"unassigned"));
    case "field_updated": return esc(d.field + ": " + (d.from||"\u2013") + " \u2192 " + (d.to||"\u2013"));
    case "comment_added": {
      var body = d.body || "";
      if (body.length > 80) body = body.slice(0,77) + "\u2026";
      return '\u201c' + esc(body) + '\u201d';
    }
    case "comment_edited": return "edited comment";
    case "comment_deleted": return "deleted comment";
    case "relationship_added": return esc(d.type||"") + " \u2192 " + esc(d.target_task_id ? d.target_task_id.slice(0,12) : "");
    case "relationship_removed": return esc(d.type||"") + " \u00d7 " + esc(d.target_task_id ? d.target_task_id.slice(0,12) : "");
    case "artifact_attached": return "attached " + esc(d.artifact_id ? d.artifact_id.slice(0,12) : "");
    case "task_archived": return "archived";
    case "task_unarchived": return "restored from archive";
    case "task_short_id_assigned": return esc(d.short_id || "");
    case "reaction_added": return esc(d.emoji||"") + " on comment";
    case "reaction_removed": return "removed " + esc(d.emoji||"") + " from comment";
    case "git_event": return esc((d.ref_type||"ref") + ": " + (d.ref_name||""));
    case "branch_linked": return "branch: " + esc(d.branch||d.branch_name||"");
    case "branch_unlinked": return "unlinked branch: " + esc(d.branch||d.branch_name||"");
    case "resource_added": return "added resource " + esc(d.resource_id ? d.resource_id.slice(0,12) : "");
    case "resource_removed": return "removed resource " + esc(d.resource_id ? d.resource_id.slice(0,12) : "");
    case "resource_updated": return "updated resource " + esc(d.resource_id ? d.resource_id.slice(0,12) : "");
    case "resource_linked": return "linked resource " + esc(d.resource_id ? d.resource_id.slice(0,12) : "");
    case "resource_unlinked": return "unlinked resource " + esc(d.resource_id ? d.resource_id.slice(0,12) : "");
    case "resource_reordered": return "reordered resources";
    default: return esc(ev.type || "");
  }
}

// Event type display labels and badge colors
var EVENT_TYPE_LABELS = {
  task_created: "Created", status_changed: "Status", assignment_changed: "Assigned",
  field_updated: "Updated", comment_added: "Comment", comment_edited: "Edited",
  comment_deleted: "Deleted", relationship_added: "Linked", relationship_removed: "Unlinked",
  artifact_attached: "Artifact", task_archived: "Archived", task_unarchived: "Restored",
  task_short_id_assigned: "Short ID", reaction_added: "Reaction", reaction_removed: "Unreacted",
  git_event: "Git", branch_linked: "Branch", branch_unlinked: "Unbranch",
  resource_added: "Resource", resource_removed: "Removed", resource_updated: "Resource",
  resource_linked: "Linked", resource_unlinked: "Unlinked", resource_reordered: "Reordered"
};
var EVENT_TYPE_COLORS = {
  task_created: "var(--color-success,#22c55e)", status_changed: "var(--accent-primary,#3b82f6)",
  assignment_changed: "var(--color-info,#6366f1)", field_updated: "var(--text-secondary,#888)",
  comment_added: "var(--color-warning,#f59e0b)", comment_edited: "var(--color-warning,#f59e0b)",
  comment_deleted: "var(--color-error,#ef4444)", relationship_added: "var(--accent-secondary,#8b5cf6)",
  relationship_removed: "var(--accent-secondary,#8b5cf6)", artifact_attached: "var(--color-info,#6366f1)",
  task_archived: "var(--text-muted,#999)", task_unarchived: "var(--color-success,#22c55e)",
  branch_linked: "var(--color-info,#6366f1)", branch_unlinked: "var(--text-muted,#999)"
};

function timeAgo(iso) {
  if (!iso) return "";
  var now = Date.now();
  var then = new Date(iso).getTime();
  var diff = Math.max(0, now - then);
  var s = Math.floor(diff / 1000);
  if (s < 60) return s + "s ago";
  var m = Math.floor(s / 60);
  if (m < 60) return m + "m ago";
  var h = Math.floor(m / 60);
  if (h < 24) return h + "h ago";
  var d = Math.floor(h / 24);
  if (d === 1) return "yesterday";
  if (d < 7) return d + "d ago";
  var w = Math.floor(d / 7);
  if (w < 5) return w + "w ago";
  return new Date(iso).toLocaleDateString();
}

function formatDateHeader(iso) {
  if (!iso) return "";
  var d = new Date(iso);
  var now = new Date();
  var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  var target = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  var diff = Math.floor((today - target) / 86400000);
  if (diff === 0) return t("activity.date_today");
  if (diff === 1) return t("activity.date_yesterday");
  if (diff < 7) return d.toLocaleDateString(undefined, { weekday: "long" });
  return d.toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" });
}

// --- Activity View ---
var _activityEvents = [];
var _activityOffset = 0;
var _activityTotal = 0;
var _activityFacets = { types: [], actors: [], tasks: [] };
var _activityFilters = {};
var _activityFocusIdx = -1;
var _activityLimit = 50;
var _activityLoading = false;
var _activityObserver = null;
var _activityHasMore = false;

function _buildActivityQS() {
  var params = [];
  params.push("limit=" + _activityLimit);
  params.push("offset=" + _activityOffset);
  if (_activityFilters.type) params.push("type=" + encodeURIComponent(_activityFilters.type));
  if (_activityFilters.task) params.push("task=" + encodeURIComponent(_activityFilters.task));
  if (_activityFilters.actor) params.push("actor=" + encodeURIComponent(_activityFilters.actor));
  if (_activityFilters.after) params.push("after=" + encodeURIComponent(_activityFilters.after));
  if (_activityFilters.before) params.push("before=" + encodeURIComponent(_activityFilters.before));
  if (_activityFilters.search) params.push("search=" + encodeURIComponent(_activityFilters.search));
  return params.join("&");
}

async function _fetchActivity(initial) {
  if (initial) {
    _activityOffset = 0;
    _activityEvents = [];
    _activityFocusIdx = -1;
  }
  var data = await api("/api/activity?" + _buildActivityQS());
  if (initial) {
    _activityEvents = data.events || [];
  } else {
    _activityEvents = _activityEvents.concat(data.events || []);
  }
  _activityTotal = data.total || 0;
  _activityHasMore = data.has_more || false;
  _activityFacets = data.facets || { types: [], actors: [], tasks: [] };
  return data;
}

function _applyActivityFilter(key, value) {
  if (value) {
    _activityFilters[key] = value;
  } else {
    delete _activityFilters[key];
  }
  renderActivity();
}

// --- Task Picker Dialog ---
function _openTaskPicker() {
  // Remove any existing picker
  var existing = document.querySelector(".task-picker-overlay");
  if (existing) existing.remove();

  var allTasks = _activityFacets.tasks || [];
  var overlay = document.createElement("div");
  overlay.className = "task-picker-overlay";

  var picker = document.createElement("div");
  picker.className = "task-picker";

  var header = document.createElement("div");
  header.className = "task-picker-header";
  var searchInput = document.createElement("input");
  searchInput.type = "text";
  searchInput.placeholder = t("activity.search_tasks");
  searchInput.autofocus = true;
  var closeBtn = document.createElement("button");
  closeBtn.textContent = "\u2715";
  closeBtn.title = "Close";
  header.appendChild(searchInput);
  header.appendChild(closeBtn);
  picker.appendChild(header);

  var listEl = document.createElement("div");
  listEl.className = "task-picker-list";
  picker.appendChild(listEl);
  overlay.appendChild(picker);
  document.body.appendChild(overlay);

  function renderItems(query) {
    var q = (query || "").toLowerCase();
    var filtered = allTasks.filter(function(ti) {
      if (!q) return true;
      if (ti.short_id && ti.short_id.toLowerCase().indexOf(q) !== -1) return true;
      if (ti.title && ti.title.toLowerCase().indexOf(q) !== -1) return true;
      if (ti.id.toLowerCase().indexOf(q) !== -1) return true;
      return false;
    });
    listEl.innerHTML = "";
    if (filtered.length === 0) {
      listEl.innerHTML = '<div class="task-picker-empty">No tasks match</div>';
      return;
    }
    // "Clear filter" option at top
    var clearItem = document.createElement("div");
    clearItem.className = "task-picker-item";
    clearItem.innerHTML = '<span class="tpi-id" style="color:var(--text-muted)">\u2014</span><span class="tpi-title" style="font-style:italic">' + esc(t("activity.all_tasks")) + '</span>';
    clearItem.addEventListener("click", function() {
      _applyActivityFilter("task", "");
      overlay.remove();
    });
    listEl.appendChild(clearItem);

    filtered.forEach(function(ti) {
      var item = document.createElement("div");
      item.className = "task-picker-item";
      if (_activityFilters.task === (ti.short_id || ti.id)) item.className += " selected";
      var idLabel = ti.short_id || ti.id.slice(0, 12);
      // Find status from loaded tasks
      var status = "";
      for (var i = 0; i < tasks.length; i++) {
        if (tasks[i].id === ti.id) { status = tasks[i].status || ""; break; }
      }
      item.innerHTML = '<span class="tpi-id">' + esc(idLabel) + '</span>'
        + '<span class="tpi-title">' + esc(ti.title || "") + '</span>'
        + (status ? '<span class="tpi-status">' + esc(getStatusDisplayName(status)) + '</span>' : '');
      item.addEventListener("click", function() {
        _applyActivityFilter("task", ti.short_id || ti.id);
        overlay.remove();
      });
      listEl.appendChild(item);
    });
  }

  renderItems("");
  searchInput.addEventListener("input", function() { renderItems(this.value); });

  // Close on overlay click or Escape
  overlay.addEventListener("click", function(e) { if (e.target === overlay) overlay.remove(); });
  searchInput.addEventListener("keydown", function(e) {
    if (e.key === "Escape") overlay.remove();
  });
  closeBtn.addEventListener("click", function() { overlay.remove(); });

  setTimeout(function() { searchInput.focus(); }, 50);
}

function _renderActivityFilterBar() {
  var html = '<div class="activity-filters">';

  // Type dropdown
  html += '<select id="activity-type-filter">';
  html += '<option value="">' + esc(t("activity.all_types")) + '</option>';
  _activityFacets.types.forEach(function(tp) {
    var sel = _activityFilters.type === tp ? ' selected' : '';
    var label = EVENT_TYPE_LABELS[tp] || tp.replace(/_/g, ' ');
    html += '<option value="' + esc(tp) + '"' + sel + '>' + esc(label) + '</option>';
  });
  html += '</select>';

  // Actor dropdown
  html += '<select id="activity-actor-filter">';
  html += '<option value="">' + esc(t("activity.all_actors")) + '</option>';
  _activityFacets.actors.forEach(function(a) {
    var sel = _activityFilters.actor === a ? ' selected' : '';
    html += '<option value="' + esc(a) + '"' + sel + '>' + esc(a) + '</option>';
  });
  html += '</select>';

  // Task picker button (replaces dropdown)
  var taskLabel = _activityFilters.task || t("activity.all_tasks");
  html += '<button id="activity-task-picker-btn" class="btn-sm" style="padding:4px 10px;border:1px solid var(--border);border-radius:var(--radius-sm);font-size:.85rem;background:var(--surface);color:var(--text-primary);cursor:pointer">';
  html += esc(taskLabel) + ' \u25BE</button>';

  // Date range quick-select
  html += '<select id="activity-date-filter">';
  var dateOpts = [
    { value: "", label: t("activity.all_time") },
    { value: "today", label: t("activity.today") },
    { value: "week", label: t("activity.this_week") },
    { value: "month", label: t("activity.this_month") },
    { value: "custom", label: t("activity.custom") }
  ];
  var curDate = _activityFilters._dateRange || "";
  dateOpts.forEach(function(opt) {
    var sel = curDate === opt.value ? ' selected' : '';
    html += '<option value="' + esc(opt.value) + '"' + sel + '>' + esc(opt.label) + '</option>';
  });
  html += '</select>';

  // Custom date range inputs (shown when "custom" selected)
  if (_activityFilters._dateRange === "custom") {
    html += '<span class="activity-date-custom">';
    html += esc(t("activity.from")) + ' <input type="datetime-local" id="activity-date-after" value="' + esc((_activityFilters._customAfter || '').slice(0, 16)) + '">';
    html += esc(t("activity.to")) + ' <input type="datetime-local" id="activity-date-before" value="' + esc((_activityFilters._customBefore || '').slice(0, 16)) + '">';
    html += '</span>';
  }

  // Search input
  html += '<input type="text" id="activity-search" placeholder="' + esc(t("activity.search")) + '" value="' + esc(_activityFilters.search || '') + '">';

  // Event count
  var from = _activityEvents.length > 0 ? 1 : 0;
  var to = _activityEvents.length;
  html += '<span class="filter-count">' + esc(t("activity.showing").replace("{from}", from).replace("{to}", to).replace("{total}", _activityTotal)) + '</span>';

  html += '</div>';

  // Active filter pills
  var pills = [];
  if (_activityFilters.type) pills.push({ key: "type", label: EVENT_TYPE_LABELS[_activityFilters.type] || _activityFilters.type });
  if (_activityFilters.actor) pills.push({ key: "actor", label: _activityFilters.actor });
  if (_activityFilters.task) pills.push({ key: "task", label: _activityFilters.task });
  if (_activityFilters._dateRange) {
    var dateLabel = _activityFilters._dateRange;
    if (dateLabel === "custom") dateLabel = t("activity.custom");
    pills.push({ key: "_dateRange", label: dateLabel });
  }
  if (_activityFilters.search) pills.push({ key: "search", label: '\u201c' + _activityFilters.search + '\u201d' });

  if (pills.length > 0) {
    html += '<div class="filter-pills">';
    pills.forEach(function(p) {
      html += '<span class="filter-pill" data-filter-key="' + esc(p.key) + '">' + esc(p.label) + ' <span class="pill-x">\u00d7</span></span>';
    });
    html += '</div>';
  }

  return html;
}

function _renderActivityItem(ev, taskIdMap) {
  var typeLabel = EVENT_TYPE_LABELS[ev.type] || ev.type.replace(/_/g, " ");
  var typeColor = EVENT_TYPE_COLORS[ev.type] || "var(--surface-raised)";
  var taskLabel = taskIdMap[ev.task_id] || (ev.task_id ? ev.task_id.slice(0,12) + "\u2026" : "");
  var ts = timeAgo(ev.ts);

  // Check if task is on the board (in active tasks)
  var onBoard = false;
  for (var i = 0; i < tasks.length; i++) {
    if (tasks[i].id === ev.task_id) { onBoard = true; break; }
  }

  var html = '<div class="activity-item" data-event-id="' + esc(ev.id || '') + '" data-task-id="' + esc(ev.task_id || '') + '" tabindex="-1">';
  html += '<div class="activity-item-main">';
  // Actor first (leftmost)
  html += '<span class="activity-item-actor" data-filter-actor="' + esc(ev.actor || '') + '" title="' + esc(ev.actor || '') + '">' + esc(ev.actor || '') + '</span>';
  html += '<div class="activity-item-top">';
  html += '<span class="activity-type-badge" style="background:' + typeColor + ';color:#fff" data-filter-type="' + esc(ev.type || '') + '" title="' + esc(ev.type || '') + '">' + esc(typeLabel) + '</span>';
  html += '<a href="#/task/' + esc(ev.task_id || '') + '" style="font-weight:600;color:var(--accent-primary);white-space:nowrap">' + esc(taskLabel) + '</a>';
  html += '<span class="activity-item-summary">' + eventSummary(ev) + '</span>';
  html += '</div>';
  html += '<div class="activity-item-meta">';
  html += '<span class="event-ts" title="' + esc(ev.ts || '') + '">' + esc(ts) + '</span>';
  html += '</div>';
  html += '</div>';
  // Expandable detail panel
  html += '<div class="activity-item-detail">';
  html += '<div class="activity-detail-actions">';
  html += '<a class="btn-sm" href="#/task/' + esc(ev.task_id || '') + '">' + esc(t("activity.view_task")) + '</a>';
  html += '<button class="btn-sm activity-nav-board" data-nav-task="' + esc(ev.task_id || '') + '"' + (onBoard ? '' : ' disabled title="Task not on board"') + '>' + esc(t("activity.view_on_board")) + '</button>';
  html += '<button class="btn-sm activity-nav-web" data-nav-task="' + esc(ev.task_id || '') + '">' + esc(t("activity.view_on_web")) + '</button>';
  html += '</div>';
  html += '<div class="activity-detail-json">' + esc(JSON.stringify(ev.data || {}, null, 2)) + '</div>';
  html += '</div>';
  html += '</div>';
  return html;
}

function _renderActivityDayGroups(events, taskIdMap) {
  var html = '';
  var lastDay = '';
  events.forEach(function(ev) {
    var day = formatDateHeader(ev.ts);
    if (day && day !== lastDay) {
      html += '<div class="activity-day-header">' + esc(day) + '</div>';
      lastDay = day;
    }
    html += _renderActivityItem(ev, taskIdMap);
  });
  return html;
}

async function renderActivity() {
  var app = document.getElementById("app");
  app.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  // Clean up previous observer
  if (_activityObserver) { _activityObserver.disconnect(); _activityObserver = null; }
  try {
    await _fetchActivity(true);

    if (_activityTotal === 0 && Object.keys(_activityFilters).length === 0) {
      app.innerHTML = '<div class="empty"><p>' + esc(t("empty.activity")) + '</p></div>';
      return;
    }

    _renderActivityUI(app);
  } catch(e) {
    app.innerHTML = '<div class="error-box"><p>' + esc(e.message) + '</p><button class="btn" onclick="renderActivity()">' + esc(t("btn.retry")) + '</button></div>';
  }
}

function _renderActivityUI(app) {
  // Build task_id -> short_id map from facets + loaded tasks
  var taskIdMap = {};
  tasks.forEach(function(tk) { if (tk.short_id) taskIdMap[tk.id] = tk.short_id; });
  _activityFacets.tasks.forEach(function(ti) { if (ti.short_id) taskIdMap[ti.id] = ti.short_id; });

  var html = '';
  html += _renderActivityFilterBar();
  html += '<div class="activity-list" id="activity-list-container">';

  if (_activityEvents.length === 0) {
    html += '<div style="padding:16px;text-align:center;color:var(--text-muted)">' + esc(t("activity.no_results")) + '</div>';
  } else {
    html += _renderActivityDayGroups(_activityEvents, taskIdMap);
  }

  // Infinite scroll sentinel
  if (_activityHasMore) {
    html += '<div class="activity-scroll-sentinel" id="activity-sentinel"></div>';
    html += '<div class="activity-loading-more" id="activity-loading-more" style="display:none">Loading\u2026</div>';
  }

  html += '</div>';

  app.innerHTML = html;
  _wireActivityEvents(app);
}

function _wireActivityEvents(app) {
  var _searchTimer = null;

  // Filter dropdowns
  var typeSelect = document.getElementById("activity-type-filter");
  if (typeSelect) typeSelect.addEventListener("change", function() { _applyActivityFilter("type", this.value); });

  var actorSelect = document.getElementById("activity-actor-filter");
  if (actorSelect) actorSelect.addEventListener("change", function() { _applyActivityFilter("actor", this.value); });

  // Task picker button
  var taskPickerBtn = document.getElementById("activity-task-picker-btn");
  if (taskPickerBtn) taskPickerBtn.addEventListener("click", _openTaskPicker);

  var dateSelect = document.getElementById("activity-date-filter");
  if (dateSelect) dateSelect.addEventListener("change", function() {
    var val = this.value;
    var now = new Date();
    delete _activityFilters.after;
    delete _activityFilters.before;
    delete _activityFilters._dateRange;
    delete _activityFilters._customAfter;
    delete _activityFilters._customBefore;
    if (val === "today") {
      _activityFilters.after = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
      _activityFilters._dateRange = "today";
    } else if (val === "week") {
      var weekAgo = new Date(now); weekAgo.setDate(weekAgo.getDate() - 7);
      _activityFilters.after = weekAgo.toISOString();
      _activityFilters._dateRange = "week";
    } else if (val === "month") {
      var monthAgo = new Date(now); monthAgo.setMonth(monthAgo.getMonth() - 1);
      _activityFilters.after = monthAgo.toISOString();
      _activityFilters._dateRange = "month";
    } else if (val === "custom") {
      _activityFilters._dateRange = "custom";
    }
    renderActivity();
  });

  // Custom date range inputs
  var dateAfterInput = document.getElementById("activity-date-after");
  var dateBeforeInput = document.getElementById("activity-date-before");
  if (dateAfterInput) {
    dateAfterInput.addEventListener("change", function() {
      var v = this.value;
      _activityFilters._customAfter = v;
      _activityFilters.after = v ? new Date(v).toISOString() : undefined;
      if (!_activityFilters.after) delete _activityFilters.after;
      renderActivity();
    });
  }
  if (dateBeforeInput) {
    dateBeforeInput.addEventListener("change", function() {
      var v = this.value;
      _activityFilters._customBefore = v;
      _activityFilters.before = v ? new Date(v).toISOString() : undefined;
      if (!_activityFilters.before) delete _activityFilters.before;
      renderActivity();
    });
  }

  // Search input with debounce
  var searchInput = document.getElementById("activity-search");
  if (searchInput) {
    searchInput.addEventListener("input", function() {
      var val = this.value;
      clearTimeout(_searchTimer);
      _searchTimer = setTimeout(function() {
        _applyActivityFilter("search", val);
      }, 300);
    });
  }

  // Filter pill removal
  app.querySelectorAll(".filter-pill").forEach(function(pill) {
    pill.addEventListener("click", function() {
      var key = pill.dataset.filterKey;
      if (key === "_dateRange") {
        delete _activityFilters.after;
        delete _activityFilters.before;
        delete _activityFilters._dateRange;
        delete _activityFilters._customAfter;
        delete _activityFilters._customBefore;
        renderActivity();
      } else {
        _applyActivityFilter(key, "");
      }
    });
  });

  // Infinite scroll via IntersectionObserver
  var sentinel = document.getElementById("activity-sentinel");
  if (sentinel && _activityHasMore) {
    if (_activityObserver) _activityObserver.disconnect();
    _activityObserver = new IntersectionObserver(function(entries) {
      if (entries[0].isIntersecting && !_activityLoading && _activityHasMore) {
        _loadMoreActivity();
      }
    }, { rootMargin: "200px" });
    _activityObserver.observe(sentinel);
  }

  // Click-to-expand event detail
  app.querySelectorAll(".activity-item").forEach(function(item) {
    item.addEventListener("click", function(e) {
      // Don't toggle if clicking a link, button, or filter shortcut
      if (e.target.tagName === "A" || e.target.tagName === "BUTTON") return;
      if (e.target.closest && e.target.closest(".activity-detail-actions")) return;
      if (e.target.dataset.filterType) {
        e.stopPropagation();
        _applyActivityFilter("type", e.target.dataset.filterType);
        return;
      }
      if (e.target.dataset.filterActor || (e.target.closest && e.target.closest(".activity-item-actor"))) {
        e.stopPropagation();
        var actorEl = e.target.closest ? e.target.closest(".activity-item-actor") : e.target;
        if (actorEl && actorEl.dataset.filterActor) {
          _applyActivityFilter("actor", actorEl.dataset.filterActor);
        }
        return;
      }
      item.classList.toggle("expanded");
    });
  });

  // Quick-filter shortcuts on type badges
  app.querySelectorAll("[data-filter-type]").forEach(function(el) {
    el.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      _applyActivityFilter("type", el.dataset.filterType);
    });
  });

  // Navigation buttons in expanded detail
  app.querySelectorAll(".activity-nav-board").forEach(function(btn) {
    btn.addEventListener("click", function(e) {
      e.stopPropagation();
      if (btn.disabled) return;
      location.hash = "#/board";
    });
  });
  app.querySelectorAll(".activity-nav-web").forEach(function(btn) {
    btn.addEventListener("click", function(e) {
      e.stopPropagation();
      location.hash = "#/web";
    });
  });

  // Keyboard navigation
  document.addEventListener("keydown", _activityKeyHandler);
}

async function _loadMoreActivity() {
  if (_activityLoading || !_activityHasMore) return;
  _activityLoading = true;
  var loadingEl = document.getElementById("activity-loading-more");
  if (loadingEl) loadingEl.style.display = "block";

  _activityOffset += _activityLimit;
  try {
    await _fetchActivity(false);
    // Append new items to the existing list (avoid full re-render to preserve scroll)
    var container = document.getElementById("activity-list-container");
    if (container) {
      var taskIdMap = {};
      tasks.forEach(function(tk) { if (tk.short_id) taskIdMap[tk.id] = tk.short_id; });
      _activityFacets.tasks.forEach(function(ti) { if (ti.short_id) taskIdMap[ti.id] = ti.short_id; });

      // Get only the new events (the last batch appended)
      var newEvents = _activityEvents.slice(_activityEvents.length - (_activityEvents.length - (_activityOffset - _activityLimit + _activityLimit)));
      // Actually simpler: new events start at the old length
      var prevLen = _activityOffset;
      var freshEvents = _activityEvents.slice(prevLen);

      var sentinel = document.getElementById("activity-sentinel");
      var loadingMore = document.getElementById("activity-loading-more");

      // Build HTML for new events with day grouping continuity
      var lastDay = '';
      // Check last day header from existing content
      var dayHeaders = container.querySelectorAll(".activity-day-header");
      if (dayHeaders.length > 0) lastDay = dayHeaders[dayHeaders.length - 1].textContent;

      var frag = document.createDocumentFragment();
      freshEvents.forEach(function(ev) {
        var day = formatDateHeader(ev.ts);
        if (day && day !== lastDay) {
          var hdr = document.createElement("div");
          hdr.className = "activity-day-header";
          hdr.textContent = day;
          if (sentinel) container.insertBefore(hdr, sentinel);
          else container.appendChild(hdr);
          lastDay = day;
        }
        var tmp = document.createElement("div");
        tmp.innerHTML = _renderActivityItem(ev, taskIdMap);
        var itemEl = tmp.firstChild;
        if (sentinel) container.insertBefore(itemEl, sentinel);
        else container.appendChild(itemEl);

        // Wire click handlers on the new item
        itemEl.addEventListener("click", function(e) {
          if (e.target.tagName === "A" || e.target.tagName === "BUTTON") return;
          if (e.target.closest && e.target.closest(".activity-detail-actions")) return;
          if (e.target.dataset.filterType) { e.stopPropagation(); _applyActivityFilter("type", e.target.dataset.filterType); return; }
          if (e.target.closest && e.target.closest(".activity-item-actor")) { e.stopPropagation(); var a2 = e.target.closest(".activity-item-actor"); if (a2) _applyActivityFilter("actor", a2.dataset.filterActor); return; }
          itemEl.classList.toggle("expanded");
        });
        // Nav buttons
        itemEl.querySelectorAll(".activity-nav-board").forEach(function(btn) {
          btn.addEventListener("click", function(e2) { e2.stopPropagation(); if (!btn.disabled) location.hash = "#/board"; });
        });
        itemEl.querySelectorAll(".activity-nav-web").forEach(function(btn) {
          btn.addEventListener("click", function(e2) { e2.stopPropagation(); location.hash = "#/web"; });
        });
        itemEl.querySelectorAll("[data-filter-type]").forEach(function(el) {
          el.addEventListener("click", function(e2) { e2.preventDefault(); e2.stopPropagation(); _applyActivityFilter("type", el.dataset.filterType); });
        });
      });

      // Remove sentinel + loading if no more
      if (!_activityHasMore) {
        if (sentinel) sentinel.remove();
        if (loadingMore) loadingMore.remove();
        if (_activityObserver) { _activityObserver.disconnect(); _activityObserver = null; }
      }

      // Update the count display
      var countEl = document.querySelector(".filter-count");
      if (countEl) {
        var from2 = _activityEvents.length > 0 ? 1 : 0;
        countEl.textContent = t("activity.showing").replace("{from}", from2).replace("{to}", _activityEvents.length).replace("{total}", _activityTotal);
      }
    }
  } catch(e) {
    // Revert offset on error
    _activityOffset -= _activityLimit;
  }
  _activityLoading = false;
  if (loadingEl) loadingEl.style.display = "none";
}

function _activityKeyHandler(e) {
  if (currentView !== "activity") return;
  // Don't intercept when focus is in an input/select
  var tag = (document.activeElement || {}).tagName;
  if (tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA") {
    if (e.key === "Escape") {
      document.activeElement.blur();
      e.preventDefault();
    }
    return;
  }
  var items = document.querySelectorAll(".activity-item");
  if (!items.length) return;

  if (e.key === "j" || e.key === "ArrowDown") {
    e.preventDefault();
    _activityFocusIdx = Math.min(_activityFocusIdx + 1, items.length - 1);
    _activitySetFocus(items);
  } else if (e.key === "k" || e.key === "ArrowUp") {
    e.preventDefault();
    _activityFocusIdx = Math.max(_activityFocusIdx - 1, 0);
    _activitySetFocus(items);
  } else if (e.key === "Enter" || e.key === " ") {
    e.preventDefault();
    if (_activityFocusIdx >= 0 && _activityFocusIdx < items.length) {
      items[_activityFocusIdx].classList.toggle("expanded");
    }
  } else if (e.key === "o") {
    if (_activityFocusIdx >= 0 && _activityFocusIdx < items.length) {
      var taskId = items[_activityFocusIdx].dataset.taskId;
      if (taskId) location.hash = "#/task/" + taskId;
    }
  } else if (e.key === "Escape") {
    // Clear focus or collapse expanded
    if (_activityFocusIdx >= 0 && _activityFocusIdx < items.length) {
      var focused = items[_activityFocusIdx];
      if (focused.classList.contains("expanded")) {
        focused.classList.remove("expanded");
      } else {
        items.forEach(function(it) { it.classList.remove("focused"); });
        _activityFocusIdx = -1;
      }
    }
  } else if (e.key === "/") {
    e.preventDefault();
    var si = document.getElementById("activity-search");
    if (si) si.focus();
  }
}

function _activitySetFocus(items) {
  items.forEach(function(it, i) {
    if (i === _activityFocusIdx) {
      it.classList.add("focused");
      it.scrollIntoView({ block: "nearest" });
    } else {
      it.classList.remove("focused");
    }
  });
}

// --- Stats View ---
async function renderStats() {
  var app = document.getElementById("app");
  app.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
  try {
    var data = await api("/api/stats");
    if (!data || !data.summary) {
      app.innerHTML = '<div class="empty"><p>' + esc(t("empty.stats")) + '</p></div>';
      return;
    }
    var html = '<div class="stats-view">';

    // Summary cards
    var sum = data.summary;
    html += '<div class="stats-cards">';
    html += '<div class="stats-card"><div class="stats-card-value">' + esc(sum.active_tasks) + '</div><div class="stats-card-label">' + esc(t("stats.active_tasks")) + '</div></div>';
    html += '<div class="stats-card"><div class="stats-card-value">' + esc(sum.archived_tasks) + '</div><div class="stats-card-label">' + esc(t("stats.archived_tasks")) + '</div></div>';
    html += '<div class="stats-card"><div class="stats-card-value">' + esc(sum.total_events) + '</div><div class="stats-card-label">' + esc(t("stats.total_events")) + '</div></div>';
    html += '<div class="stats-card"><div class="stats-card-value">' + esc(sum.active_events) + '</div><div class="stats-card-label">' + esc(t("stats.active_events")) + '</div></div>';
    html += '</div>';

    // WIP alerts
    if (data.wip && data.wip.length > 0) {
      var hasOver = false;
      data.wip.forEach(function(w) { if (w.over) hasOver = true; });
      if (hasOver) {
        html += '<div class="stats-wip-alerts">';
        data.wip.forEach(function(w) {
          if (w.over) {
            html += '<div class="stats-wip-alert">' + esc(t("stats.wip_exceeded")) + ': <strong>' + esc(w.status) + '</strong> &mdash; ' + esc(w.current) + '/' + esc(w.limit) + '</div>';
          }
        });
        html += '</div>';
      }
    }

    // Status distribution (horizontal bars)
    if (data.by_status && data.by_status.length > 0) {
      var maxStatus = 0;
      data.by_status.forEach(function(row) { if (row[1] > maxStatus) maxStatus = row[1]; });
      html += '<div class="stats-section"><h3>' + esc(t("stats.by_status")) + '</h3>';
      data.by_status.forEach(function(row) {
        var pct = maxStatus > 0 ? Math.round((row[1] / maxStatus) * 100) : 0;
        var color = getLaneColor(row[0]);
        html += '<div class="stats-bar-row">';
        html += '<span class="stats-bar-label">' + esc(row[0]) + '</span>';
        html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:' + esc(color) + '"></div></div>';
        html += '<span class="stats-bar-count">' + esc(row[1]) + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    // Distribution tables (priority, type, assignee, tags)
    var distPanels = [];
    if (data.by_priority && data.by_priority.length > 0) {
      distPanels.push({key: "stats.by_priority", rows: data.by_priority});
    }
    if (data.by_type && data.by_type.length > 0) {
      distPanels.push({key: "stats.by_type", rows: data.by_type});
    }
    if (data.by_assignee && data.by_assignee.length > 0) {
      distPanels.push({key: "stats.by_assignee", rows: data.by_assignee});
    }
    if (data.by_tag && data.by_tag.length > 0) {
      distPanels.push({key: "stats.by_tag", rows: data.by_tag});
    }
    if (distPanels.length > 0) {
      html += '<div class="stats-distributions">';
      distPanels.forEach(function(panel) {
        html += '<div class="stats-dist-card"><h4>' + esc(t(panel.key)) + '</h4>';
        html += '<table class="stats-dist-table">';
        panel.rows.forEach(function(row) {
          html += '<tr><td>' + esc(row[0]) + '</td><td class="stats-dist-count">' + esc(row[1]) + '</td></tr>';
        });
        html += '</table></div>';
      });
      html += '</div>';
    }

    // Recently active tasks
    if (data.recently_active && data.recently_active.length > 0) {
      html += '<div class="stats-section"><h3>' + esc(t("stats.recently_active")) + '</h3>';
      html += '<table><thead><tr><th>ID</th><th>' + esc(t("table.title")) + '</th><th>' + esc(t("table.status")) + '</th><th>' + esc(t("table.updated")) + '</th></tr></thead><tbody>';
      data.recently_active.forEach(function(task) {
        html += '<tr>';
        html += '<td class="id-cell"><a href="#/task/' + esc(task.full_id) + '">' + esc(task.id) + '</a></td>';
        html += '<td><a href="#/task/' + esc(task.full_id) + '">' + esc(task.title) + '</a></td>';
        html += '<td><span class="badge badge-stat" title="' + esc(getStatusDescription(task.status)) + '">' + esc(getStatusDisplayName(task.status)) + '</span></td>';
        html += '<td>' + esc(task.updated_ago) + '</td>';
        html += '</tr>';
      });
      html += '</tbody></table></div>';
    }

    // Stale tasks
    if (data.stale && data.stale.length > 0) {
      html += '<div class="stats-section stats-stale"><h3>' + esc(t("stats.stale_tasks")) + '</h3>';
      html += '<table><thead><tr><th>ID</th><th>' + esc(t("table.title")) + '</th><th>' + esc(t("table.status")) + '</th><th>Days Stale</th></tr></thead><tbody>';
      var staleShown = data.stale.slice(0, 10);
      staleShown.forEach(function(task) {
        html += '<tr>';
        html += '<td class="id-cell"><a href="#/task/' + esc(task.full_id) + '">' + esc(task.id) + '</a></td>';
        html += '<td><a href="#/task/' + esc(task.full_id) + '">' + esc(task.title) + '</a></td>';
        html += '<td><span class="badge badge-stat" title="' + esc(getStatusDescription(task.status)) + '">' + esc(getStatusDisplayName(task.status)) + '</span></td>';
        html += '<td>' + esc(typeof task.days_stale === "number" ? task.days_stale.toFixed(1) : task.days_stale) + '</td>';
        html += '</tr>';
      });
      html += '</tbody></table>';
      if (data.stale.length > 10) {
        html += '<p style="font-size:.8rem;color:var(--text-muted);margin-top:4px">...and ' + esc(data.stale.length - 10) + ' more</p>';
      }
      html += '</div>';
    }

    // Busiest tasks
    if (data.busiest && data.busiest.length > 0) {
      html += '<div class="stats-section"><h3>' + esc(t("stats.busiest_tasks")) + '</h3>';
      html += '<table><thead><tr><th>ID</th><th>' + esc(t("table.title")) + '</th><th>Events</th></tr></thead><tbody>';
      data.busiest.forEach(function(task) {
        html += '<tr>';
        html += '<td class="id-cell"><a href="#/task/' + esc(task.full_id) + '">' + esc(task.id) + '</a></td>';
        html += '<td><a href="#/task/' + esc(task.full_id) + '">' + esc(task.title) + '</a></td>';
        html += '<td style="font-weight:600">' + esc(task.event_count) + '</td>';
        html += '</tr>';
      });
      html += '</tbody></table></div>';
    }

    // === Quality Metrics ===
    html += '<div class="stats-metrics-heading">Quality Metrics</div>';

    // Velocity chart (tasks completed per week)
    if (data.velocity && data.velocity.length > 0) {
      var maxVel = 0;
      data.velocity.forEach(function(w) { if (w.count > maxVel) maxVel = w.count; });
      var totalDone = 0;
      data.velocity.forEach(function(w) { totalDone += w.count; });
      html += '<div class="stats-section"><h3>Velocity — Tasks Completed per Week (' + esc(totalDone) + ' total)</h3>';
      html += '<div class="velocity-chart">';
      data.velocity.forEach(function(w) {
        var pct = maxVel > 0 ? Math.round((w.count / maxVel) * 100) : 0;
        html += '<div class="velocity-bar-wrap">';
        html += '<div class="velocity-bar-count">' + (w.count > 0 ? esc(w.count) : '') + '</div>';
        html += '<div class="velocity-bar" style="height:' + Math.max(pct, 2) + '%"></div>';
        html += '<div class="velocity-bar-label">' + esc(w.week.replace(/^\d{4}-/, '')) + '</div>';
        html += '</div>';
      });
      html += '</div></div>';
    }

    // Time in status
    if (data.time_in_status && data.time_in_status.length > 0) {
      var maxTis = 0;
      data.time_in_status.forEach(function(r) { if (r.avg_hours > maxTis) maxTis = r.avg_hours; });
      html += '<div class="stats-section"><h3>Avg Time in Status</h3>';
      data.time_in_status.forEach(function(r) {
        var pct = maxTis > 0 ? Math.round((r.avg_hours / maxTis) * 100) : 0;
        var color = getLaneColor(r.status);
        var label = r.avg_hours >= 24 ? (r.avg_hours / 24).toFixed(1) + 'd' : r.avg_hours.toFixed(1) + 'h';
        html += '<div class="stats-bar-row">';
        html += '<span class="stats-bar-label">' + esc(r.status) + '</span>';
        html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:' + esc(color) + '"></div></div>';
        html += '<span class="stats-bar-count" title="' + esc(r.sample_count) + ' samples">' + esc(label) + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    // Blocked counts
    if (data.blocked) {
      html += '<div class="stats-section"><h3>Blocked</h3>';
      html += '<div class="blocked-cards">';
      html += '<div class="blocked-card"><div class="blocked-card-value' + (data.blocked.currently_blocked > 0 ? ' danger' : '') + '">' + esc(data.blocked.currently_blocked) + '</div><div class="blocked-card-label">Currently Blocked</div></div>';
      html += '<div class="blocked-card"><div class="blocked-card-value">' + esc(data.blocked.total_blocked_episodes) + '</div><div class="blocked-card-label">Total Episodes</div></div>';
      var avgBlk = data.blocked.avg_blocked_hours >= 24 ? (data.blocked.avg_blocked_hours / 24).toFixed(1) + 'd' : data.blocked.avg_blocked_hours.toFixed(1) + 'h';
      html += '<div class="blocked-card"><div class="blocked-card-value">' + esc(avgBlk) + '</div><div class="blocked-card-label">Avg Resolution</div></div>';
      html += '</div></div>';
    }

    // Agent activity
    if (data.agent_activity && data.agent_activity.length > 0) {
      var maxAct = 0;
      data.agent_activity.forEach(function(a) { if (a.event_count > maxAct) maxAct = a.event_count; });
      html += '<div class="stats-section"><h3>Agent & Actor Activity</h3>';
      data.agent_activity.forEach(function(a) {
        var pct = maxAct > 0 ? Math.round((a.event_count / maxAct) * 100) : 0;
        var isAgent = a.actor.startsWith('agent:');
        var chipClass = isAgent ? 'chip-agent' : (a.actor.startsWith('human:') ? 'chip-human' : 'chip-team');
        html += '<div class="stats-bar-row">';
        html += '<span class="stats-bar-label">' + esc(a.actor) + '</span>';
        html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:var(--' + chipClass + '-text)"></div></div>';
        html += '<span class="stats-bar-count">' + esc(a.event_count) + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    html += '<div style="margin-top:2rem;padding-top:1rem;border-top:1px solid var(--border);font-size:.8rem;opacity:.6">';
    html += '<a href="/stats-demo" target="_blank" style="color:var(--accent)">Stats Demo Page</a> — 27 prototype improvements for review';
    html += '</div>';

    html += '</div>';
    app.innerHTML = html;
  } catch(e) {
    app.innerHTML = '<div class="error-box"><p>' + esc(e.message) + '</p><button class="btn" onclick="renderStats()">' + esc(t("btn.retry")) + '</button></div>';
  }
}

// --- Helpers ---
function esc(s) {
  if (s == null) return "";
  return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
}

function showError(msg) {
  document.getElementById("app").innerHTML = '<div class="error-box"><p>' + esc(msg) + '</p><button class="btn" onclick="location.reload()">' + esc(t("btn.retry")) + '</button></div>';
}

// --- Member Chips ---
function buildMemberChips(inputEl) {
  var container = document.createElement("div");
  container.className = "member-chips";
  if (!config || !config.members) return container;

  var members = config.members;
  var prefixIcons = { human: "\ud83d\udc64", agent: "\ud83e\udd16", team: "\ud83d\udc65" };
  var order = ["human", "agent", "team"];

  order.forEach(function(prefix) {
    var list = members[prefix];
    if (!list || !list.length) return;
    list.forEach(function(name) {
      var chip = document.createElement("span");
      chip.className = "member-chip member-chip-" + prefix;
      chip.textContent = (prefixIcons[prefix] || "") + " " + name;
      chip.dataset.actorId = prefix + ":" + name;
      chip.addEventListener("click", function() {
        inputEl.value = chip.dataset.actorId;
        inputEl.focus();
      });
      container.appendChild(chip);
    });
  });

  return container;
}

function populateMemberChips(containerId, inputId) {
  var container = document.getElementById(containerId);
  var input = document.getElementById(inputId);
  if (!container || !input) return;
  container.innerHTML = "";
  var chips = buildMemberChips(input);
  while (chips.firstChild) container.appendChild(chips.firstChild);
}

// --- Create Task Modal ---
function showCreateTaskModal() {
  // Close floating detail panel if open
  if (_detailPanelTaskId) closeDetailPanel();
  var modal = document.getElementById("create-task-modal");
  // Populate type dropdown from config
  var typeSelect = document.getElementById("ct-type");
  typeSelect.innerHTML = "";
  var types = (config && config.task_types) || ["task"];
  types.forEach(function(t) {
    var opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    if (t === "task") opt.selected = true;
    typeSelect.appendChild(opt);
  });
  // Reset form
  document.getElementById("ct-title").value = "";
  document.getElementById("ct-priority").value = config ? (config.default_priority || "medium") : "medium";
  document.getElementById("ct-description").value = "";
  document.getElementById("ct-tags").value = "";
  document.getElementById("ct-assigned").value = "";
  populateMemberChips("ct-assigned-chips", "ct-assigned");
  modal.style.display = "flex";
  document.getElementById("ct-title").focus();
}

function hideCreateTaskModal() {
  document.getElementById("create-task-modal").style.display = "none";
}

document.getElementById("new-task-btn").addEventListener("click", showCreateTaskModal);
document.getElementById("create-task-close").addEventListener("click", hideCreateTaskModal);
document.getElementById("create-task-cancel").addEventListener("click", hideCreateTaskModal);

document.getElementById("create-task-modal").addEventListener("click", function(e) {
  if (e.target === this) hideCreateTaskModal();
});

document.getElementById("create-task-submit").addEventListener("click", async function() {
  var title = document.getElementById("ct-title").value.trim();
  if (!title) {
    showToast(t("error.title_required"), "error");
    return;
  }
  var payload = { title: title };
  var taskType = document.getElementById("ct-type").value;
  if (taskType) payload.type = taskType;
  var priority = document.getElementById("ct-priority").value;
  if (priority) payload.priority = priority;
  var desc = document.getElementById("ct-description").value.trim();
  if (desc) payload.description = desc;
  var tags = document.getElementById("ct-tags").value.trim();
  if (tags) payload.tags = tags.split(",").map(function(t){ return t.trim(); }).filter(Boolean);
  var assigned = document.getElementById("ct-assigned").value.trim();
  if (assigned) payload.assigned_to = assigned;

  try {
    var created = await apiPost("/api/tasks", payload);
    hideCreateTaskModal();
    showToast(tf("toast.task_created", {title: title}), "success");
    tasks = await api("/api/tasks");
    updateAllBadges();
    // Navigate to the new task's detail
    location.hash = "#/task/" + created.id;
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Allow Enter in title to submit
document.getElementById("ct-title").addEventListener("keydown", function(e) {
  if (e.key === "Enter") {
    e.preventDefault();
    document.getElementById("create-task-submit").click();
  }
});

// --- Settings Panel ---
document.getElementById("settings-btn").addEventListener("click", function() {
  document.getElementById("settings-panel").classList.add("open");
});

document.getElementById("settings-close").addEventListener("click", function() {
  document.getElementById("settings-panel").classList.remove("open");
});

// Theme selector
document.getElementById("theme-select").addEventListener("change", async function() {
  var newTheme = this.value;
  applyTheme(newTheme);
  try {
    var result = await apiPost("/api/config/dashboard", {theme: newTheme});
    if (config) config.dashboard = result;
    populateLaneColorSettings();
    if (currentView === "board") renderBoard();
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Column width slider — live update + persist on change
(function() {
  var slider = document.getElementById("col-width-slider");
  var label = document.getElementById("col-width-value");
  var debounceTimer = null;
  slider.addEventListener("input", function() {
    var v = slider.value + "px";
    label.textContent = v;
    document.documentElement.style.setProperty("--col-min-w", v);
  });
  slider.addEventListener("change", function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async function() {
      try {
        var result = await apiPost("/api/config/dashboard", {column_width: Number(slider.value)});
        if (config) config.dashboard = result;
      } catch(e) {
        showToast(e.message, "error");
      }
    }, 300);
  });
})();

// Font size slider — live update + persist on change
(function() {
  var slider = document.getElementById("font-size-slider");
  var label = document.getElementById("font-size-value");
  var debounceTimer = null;
  slider.addEventListener("input", function() {
    var v = slider.value + "px";
    label.textContent = v;
    document.documentElement.style.setProperty("--card-font-size", v);
  });
  slider.addEventListener("change", function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async function() {
      try {
        var result = await apiPost("/api/config/dashboard", {font_size: Number(slider.value)});
        if (config) config.dashboard = result;
      } catch(e) {
        showToast(e.message, "error");
      }
    }, 300);
  });
})();

// Voice selector
document.getElementById("voice-select").addEventListener("change", async function() {
  var newVoice = this.value;
  currentVoice = newVoice;
  try {
    var result = await apiPost("/api/config/dashboard", {voice: newVoice});
    if (config) config.dashboard = result;
    updateStaticVoiceStrings();
    showToast(t("toast.voice_updated"), "success");
    await route(location.hash.slice(1) || "/board");
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Background image: save
document.getElementById("bg-image-save").addEventListener("click", async function() {
  var url = document.getElementById("bg-image-input").value.trim();
  try {
    var result = await apiPost("/api/config/dashboard", {background_image: url || null});
    if (config) config.dashboard = result;
    applyBackgroundImage();
    showToast(t("toast.bg_updated"), "success");
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Background image: clear
document.getElementById("bg-image-clear").addEventListener("click", async function() {
  document.getElementById("bg-image-input").value = "";
  try {
    var result = await apiPost("/api/config/dashboard", {background_image: null});
    if (config) config.dashboard = result;
    applyBackgroundImage();
    showToast(t("toast.bg_cleared"), "success");
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Lane colors: save
document.getElementById("lane-colors-save").addEventListener("click", async function() {
  var inputs = document.querySelectorAll("#lane-colors-list input[type=color]");
  var colors = {};
  inputs.forEach(function(inp) {
    colors[inp.dataset.status] = inp.value;
  });
  try {
    var result = await apiPost("/api/config/dashboard", {lane_colors: colors});
    if (config) config.dashboard = result;
    showToast(t("toast.lane_colors_updated"), "success");
    if (currentView === "board") renderBoard();
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Lane colors: reset
document.getElementById("lane-colors-reset").addEventListener("click", async function() {
  try {
    var themeDefaults = LANE_COLORS_BY_THEME[getTheme()] || DEFAULT_LANE_COLORS;
    var result = await apiPost("/api/config/dashboard", {lane_colors: themeDefaults});
    if (config) config.dashboard = result;
    populateLaneColorSettings();
    showToast(t("toast.lane_colors_reset"), "success");
    if (currentView === "board") renderBoard();
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Heat map toggle
document.getElementById("heat-map-toggle").addEventListener("change", async function() {
  var enabled = this.checked;
  try {
    var result = await apiPost("/api/config/dashboard", {heat_map_enabled: enabled});
    if (config) config.dashboard = result;
    if (currentView === "board") renderBoard();
    else if (currentView === "list") applyListFilters();
  } catch(e) {
    showToast(e.message, "error");
  }
});

// Heat map info popup
document.getElementById("heat-map-info-btn").addEventListener("click", function(e) {
  e.stopPropagation();
  var existing = document.getElementById("heat-map-info-popup");
  if (existing) { existing.remove(); return; }
  var popup = document.createElement("div");
  popup.id = "heat-map-info-popup";
  popup.style.cssText = "position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:200;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius-md,6px);padding:20px 24px;max-width:360px;box-shadow:0 8px 32px rgba(0,0,0,.3)";
  popup.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px"><strong style="font-size:.95rem">Heat Map</strong><button type="button" id="heat-map-info-close" style="background:none;border:none;cursor:pointer;color:var(--text-muted);font-size:1.1rem;padding:0 2px">&times;</button></div>'
    + '<p style="margin:0 0 10px;font-size:.85rem;color:var(--text-secondary);line-height:1.5">The heat map shows how recently a task changed status. A colored left border appears on each card:</p>'
    + '<div style="display:flex;flex-direction:column;gap:6px;margin-bottom:14px">'
    + '<div style="display:flex;align-items:center;gap:8px;font-size:.83rem"><span style="width:14px;height:14px;border-radius:2px;background:#ef4444;flex-shrink:0"></span> <strong>Red</strong> &mdash; changed in the last minute</div>'
    + '<div style="display:flex;align-items:center;gap:8px;font-size:.83rem"><span style="width:14px;height:14px;border-radius:2px;background:#f97316;flex-shrink:0"></span> <strong>Orange</strong> &mdash; changed in the last 10 minutes</div>'
    + '<div style="display:flex;align-items:center;gap:8px;font-size:.83rem"><span style="width:14px;height:14px;border-radius:2px;background:#eab308;flex-shrink:0"></span> <strong>Yellow</strong> &mdash; changed in the last hour</div>'
    + '<div style="display:flex;align-items:center;gap:8px;font-size:.83rem"><span style="width:14px;height:14px;border-radius:2px;background:var(--border-subtle);flex-shrink:0"></span> <strong>No border</strong> &mdash; older than one hour</div>'
    + '</div>'
    + '<p style="margin:0;font-size:.8rem;color:var(--text-muted);line-height:1.4;font-style:italic">Don\'t like one of these? Have your agents change it.</p>';
  document.body.appendChild(popup);
  var overlay = document.createElement("div");
  overlay.id = "heat-map-info-overlay";
  overlay.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;z-index:199;background:rgba(0,0,0,.25)";
  document.body.appendChild(overlay);
  function closePopup() { popup.remove(); overlay.remove(); }
  document.getElementById("heat-map-info-close").addEventListener("click", closePopup);
  overlay.addEventListener("click", closePopup);
});

// --- Nav Events ---
document.querySelectorAll(".nav-tab").forEach(function(el) {
  el.addEventListener("click", function() { location.hash = "#/" + el.dataset.view; });
});

document.getElementById("help-btn").addEventListener("click", function() {
  window.open("https://thelattice.works/getting-started", "_blank");
});

document.getElementById("refresh-btn").addEventListener("click", async function() {
  try {
    var results = await Promise.all([api("/api/config"), api("/api/tasks"), api("/api/graph").catch(function() { return { links: [] }; })]);
    config = results[0];
    tasks = results[1];
    boardGraphLinks = (results[2] && results[2].links) || [];
    archivedTasks = null;
    var dc = (config && config.dashboard) || {};
    if (dc.voice && VOICES[dc.voice]) currentVoice = dc.voice;
    updateAllBadges();
    applyTheme(getTheme());
    populateThemeSelector();
    populateVoiceSelector();
    updateStaticVoiceStrings();
    populateLaneColorSettings();
    loadColumnWidthSetting();
    loadFontSizeSetting();
    loadBackgroundSetting();
    loadHeatMapSetting();
    await route(location.hash.slice(1));
  } catch(e) { showError(e.message); }
});

// --- Auto-refresh ---
var autoRefreshInterval = null;
var AUTO_REFRESH_MS = 5000;

function startAutoRefresh() {
  stopAutoRefresh();
  autoRefreshInterval = setInterval(async function() {
    if (currentView !== "board" && currentView !== "list" && currentView !== "activity" && currentView !== "stats" && currentView !== "cube" && currentView !== "web") return;

    // Cube: revision-based refresh (independent data path)
    if (currentView === "cube") {
      try {
        var cubeGen = cubeRenderGeneration;
        var graphData = await api("/api/graph");
        if (cubeGen !== cubeRenderGeneration) return;
        if (currentView !== "cube") return;
        if (graphData.revision && graphData.revision !== cubeCurrentRevision) {
          updateCubeData(graphData);
        }
      } catch (e) { /* server may be restarting */ }
      return;
    }

    // Web: dual-source revision refresh
    if (currentView === "web") {
      try {
        var webGen = webRenderGeneration;
        var results = await Promise.all([
          api("/api/graph"),
          api("/api/git").catch(function() { return { available: false }; })
        ]);
        if (webGen !== webRenderGeneration) return;
        if (currentView !== "web") return;
        var newWebRevision = (results[0].revision || "") + ":" + ((results[1] && results[1].head_commit) || "");
        if (newWebRevision !== webCurrentRevision) {
          updateWebData(results[0], results[1]);
        }
      } catch (e) { /* server may be restarting */ }
      return;
    }

    try {
      var fetchPromises = [api("/api/tasks"), api("/api/config")];
      if (currentView === "board") fetchPromises.push(api("/api/graph").catch(function() { return { links: [] }; }));
      var fetchResults = await Promise.all(fetchPromises);
      var newTasks = fetchResults[0];
      var newConfig = fetchResults[1];
      if (fetchResults[2]) boardGraphLinks = (fetchResults[2] && fetchResults[2].links) || [];
      // Only re-render if data actually changed
      var tasksChanged = JSON.stringify(newTasks) !== JSON.stringify(tasks);
      var configChanged = JSON.stringify(newConfig) !== JSON.stringify(config);
      if (tasksChanged || configChanged) {
        tasks = newTasks;
        config = newConfig;
        updateAllBadges();
        if (configChanged) {
          var dca = (config && config.dashboard) || {};
          if (dca.voice && VOICES[dca.voice]) currentVoice = dca.voice;
          applyTheme(getTheme());
          populateThemeSelector();
          populateVoiceSelector();
          updateStaticVoiceStrings();
          populateLaneColorSettings();
          loadColumnWidthSetting();
          loadFontSizeSetting();
          loadBackgroundSetting();
          loadHeatMapSetting();
        }
        await route(location.hash.slice(1));
        // Silently refresh floating detail panel if open and no active edit
        if (_detailPanelTaskId && tasksChanged) {
          var dpBody = document.getElementById("dp-body");
          if (dpBody && !dpBody.querySelector("input:focus, textarea:focus")) {
            try {
              var dpResults = await Promise.all([
                api("/api/tasks/" + _detailPanelTaskId),
                api("/api/tasks/" + _detailPanelTaskId + "/events")
              ]);
              if (_detailPanelTaskId) _renderPanelContent(_detailPanelTaskId, dpResults[0], dpResults[1]);
            } catch(ex) { /* panel data fetch failed, ignore */ }
          }
        }
      }
    } catch(e) {
      // Silently ignore refresh errors — server may be restarting
    }
  }, AUTO_REFRESH_MS);
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

// --- Heat bar tick: lightweight DOM-only update between data fetches ---
var _heatBarInterval = null;
function startHeatBarTick() {
  stopHeatBarTick();
  _heatBarInterval = setInterval(function() {
    if (!isHeatMapEnabled() || currentView !== "board") return;
    var cards = document.querySelectorAll(".card[data-heat-ts]");
    for (var i = 0; i < cards.length; i++) {
      var ts = cards[i].getAttribute("data-heat-ts");
      var bar = cards[i].querySelector(".heat-bar");
      var ratio = getHeatBarRatio(ts);
      var tier = getHeatTier(ts);
      if (ratio <= 0 || !tier.color) {
        if (bar) bar.style.height = "0%";
        continue;
      }
      if (bar) {
        bar.style.height = (ratio * 100).toFixed(1) + "%";
        bar.style.background = heatBarBackground(tier.color);
      }
    }
  }, HEAT_CONFIG.refreshIntervalMs);
}
function stopHeatBarTick() {
  if (_heatBarInterval) { clearInterval(_heatBarInterval); _heatBarInterval = null; }
}

// Pause auto-refresh when tab is hidden to avoid unnecessary requests
document.addEventListener("visibilitychange", function() {
  if (document.hidden) {
    stopAutoRefresh();
    stopHeatBarTick();
  } else {
    startAutoRefresh();
    startHeatBarTick();
  }
});

// --- Global Nav Search ---
(function() {
  var wrap = document.getElementById("nav-search");
  var btn = document.getElementById("nav-search-btn");
  var input = document.getElementById("nav-search-input");

  function openSearch() {
    wrap.classList.add("open");
    input.tabIndex = 0;
    btn.setAttribute("aria-expanded", "true");
    input.focus();
  }

  function closeSearch(clearValue) {
    wrap.classList.remove("open");
    input.tabIndex = -1;
    btn.setAttribute("aria-expanded", "false");
    if (clearValue) input.value = "";
    input.blur();
  }

  btn.addEventListener("click", function() {
    if (wrap.classList.contains("open")) {
      submitNavSearch();
    } else {
      openSearch();
    }
  });

  input.addEventListener("keydown", function(e) {
    if (e.key === "Enter") { e.preventDefault(); submitNavSearch(); }
    if (e.key === "Escape") { closeSearch(true); }
  });

  // Close on outside click
  document.addEventListener("click", function(e) {
    if (!wrap.contains(e.target) && wrap.classList.contains("open")) {
      closeSearch(false);
    }
  });

  // Global keyboard shortcut: "/" to open search
  document.addEventListener("keydown", function(e) {
    if (e.key === "/" && !e.ctrlKey && !e.metaKey && !e.altKey) {
      var tag = (e.target.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "select" || e.target.isContentEditable) return;
      e.preventDefault();
      openSearch();
    }
  });

  function submitNavSearch() {
    var q = (input.value || "").trim();
    if (!q) { closeSearch(false); return; }
    pendingSearch = q;
    closeSearch(true);
    location.hash = "#/list";
    // If already on list view, re-render to apply the search
    if (currentView === "list") renderList();
  }
})();

// --- Expose utilities for external modules (cube3d.js) ---
window._lattice = {
  api: api,
  apiPost: apiPost,
  esc: esc,
  showToast: showToast,
  getLaneColor: getLaneColor,
  getStatusDisplayName: getStatusDisplayName,
  getStatusDescription: getStatusDescription,
  getConfig: function() { return config; },
  getCurrentView: function() { return currentView; },
  ghMode: ghMode
};

// --- Boot ---
ghMode.init();
init().then(function() { startAutoRefresh(); startHeatBarTick(); });

})();
</script>
</body>
</html>
